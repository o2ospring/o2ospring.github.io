[{"categories":["MCU"],"content":"涉及 MCU 相关知识","date":"2018-08-06","objectID":"/mcu/","tags":["MCU"],"title":"【MCU 专题文章索引】","uri":"/mcu/"},{"categories":["MCU"],"content":"前言 记录我使用 MCU 软硬件一些经验，涉及 STM8、STM32F103、STM32F429 等单片机，以及单片机内部资源的应用，Keil MDK、IAR、STM32CubeMX 等工具基本使用！ ","date":"2018-08-06","objectID":"/mcu/:0:1","tags":["MCU"],"title":"【MCU 专题文章索引】","uri":"/mcu/"},{"categories":["MCU"],"content":"索引 👉 STM32CubeMX 基本使用 👉 linux-STM32F开发㈠-makefile 构建与使用 👉 linux-STM32F开发㈡-调试器的安装与使用 👉 linux-STM32F开发㈢-在线调试工具CGDB 👉 linux-ESP32编译-工程命令行编译笔记 👉 J-link 调试器日志打印工具-RTT 👉 ARM-Cortex-M 系列 MCU 错误追踪库-CmBacktrace 👉 Keil MDK-获取编译后的 ROM, RAM 大小 👉 Keil MDK-在已运行 MCU 上中途插入调试 👉 Keil 4 与 Keil 5 的兼容性 👉 ACM32F403RE 国产 MCU 试用笔记 ","date":"2018-08-06","objectID":"/mcu/:0:2","tags":["MCU"],"title":"【MCU 专题文章索引】","uri":"/mcu/"},{"categories":["linux"],"content":"涉及 linux/Ubuntu 相关知识","date":"2018-08-05","objectID":"/linux/","tags":["linux"],"title":"【linux 专题文章索引】","uri":"/linux/"},{"categories":["linux"],"content":"前言 记录我学习 linux 基础知识、终端命令的使用、编程编译环境的应用，以及在 linux（Ubuntu）操作系统环境下各类工具软件的安装、配置、使用！ ","date":"2018-08-05","objectID":"/linux/:0:1","tags":["linux"],"title":"【linux 专题文章索引】","uri":"/linux/"},{"categories":["linux"],"content":"索引 👉 linux 学习索引 👉 linux-系统-Ubuntu 系统与工具 👉 linux-命令-linux 基本命令使用 👉 linux-编译-linux 编译构建工具 👉 linux-调试-linux 调试仿真工具 👉 linux-语法-正则表达式 regex 👉 linux-脚本-轻巧的脚本语言 lua 👉 linux-工具-linux 模拟环境 cygwin 👉 linux-工具-linux 模拟工具 UnxUtils 👉 linux-工具-linux 模拟环境 WSL 👉 linux-工具-linux 模拟环境 Termux 👉 linux-工具-命令帮助工具 tldr 👉 linux-工具-纯文本编辑器 vi 👉 linux-工具-纯文本编辑器 nano 👉 linux-工具-中文输入工具 wubi 👉 linux-工具-网络终端工具 ssh 👉 linux-工具-网络文件系统 nfs 👉 linux-工具-开发环境 JDK 👉 linux-工具-开发工具 Eclipse 👉 linux-工具-代码版本管理工具 git 👉 linux-工具-博客生成工具 Hugo 👉 linux-工具-博客生成工具 Hexo 👉 linux-工具-网站 PPT 生成工具 Slidev 👉 linux-工具-电子书制作工具 gitbook 👉 linux-工具-网站 node 包管理器 npm 👉 linux-STM32F开发㈠-makefile 构建与使用 👉 linux-STM32F开发㈡-调试器的安装与使用 👉 linux-STM32F开发㈢-在线调试工具CGDB 👉 linux-ESP32编译-工程命令行编译笔记 ","date":"2018-08-05","objectID":"/linux/:0:2","tags":["linux"],"title":"【linux 专题文章索引】","uri":"/linux/"},{"categories":["software"],"content":"各种软件技术的介绍","date":"2018-08-04","objectID":"/software/","tags":["软件"],"title":"【software 软件技术索引】","uri":"/software/"},{"categories":["software"],"content":"前言 软件技术包括：编程语言、编程算法、编程思维、数据处理、开源应用模块的使用、实时操作系统的使用等，涉及 C、Lua、RT-thread、FreeRTOS、ucOS、json、MD5、GUI 等等相关技术！ ","date":"2018-08-04","objectID":"/software/:0:1","tags":["软件"],"title":"【software 软件技术索引】","uri":"/software/"},{"categories":["software"],"content":"索引 👉 Markdown 语法与工具 👉 C 语言总结与提高 👉 本人 C 语言编程规范 👉 面向对象思维方式的 C 语言实现方法 👉 面向对象模块设计的 C 语言实现方法 👉 X-MACRO 数据与代码序列化 👉 MD5 对数据加密与校验 👉 CRC 数据校验原理和应用 👉 json 基本语法介绍 👉 regex 正则表达式语法 👉 lua 脚本基本语法 👉 git 分布式代码版本管理工具 👉 cygwin 之 unix 模拟环境 👉 MinGW-w64 编译套件(GNU 工具集) 👉 attribute-section 编译属性-数据拼接 👉 attribute-aligned 编译属性-地址对齐 👉 attribute-packed 编译属性-字节对齐 👉 attribute-weak 编译属性-弱符号 👉 attribute-un/used 编译属性-未用警告 👉 attribute-at 编译属性-地址指定 👉 FreeRTOS 实时操作系统应用笔记 👉 Serial Studio 数据可视化工具 👉 Visual Scope 串口虚拟示波器工具 👉 UPDesktop 快捷启动工具 👉 常用开发辅助工具 ","date":"2018-08-04","objectID":"/software/:0:2","tags":["软件"],"title":"【software 软件技术索引】","uri":"/software/"},{"categories":["hardware"],"content":"各种硬件技术的介绍","date":"2018-08-03","objectID":"/hardware/","tags":["硬件"],"title":"【hardware 硬件技术索引】","uri":"/hardware/"},{"categories":["hardware"],"content":"前言 硬件技术包括：电路设计、PCB 设计、硬件总线、模块方案、强弱电、实验室测试、产品认证，以及 EDA 等相关工具的使用，涉及 Altium Designer、PADS、WIFI、bluetooth、CAN、RS-485 等等相关技术！ ","date":"2018-08-03","objectID":"/hardware/:0:1","tags":["硬件"],"title":"【hardware 硬件技术索引】","uri":"/hardware/"},{"categories":["hardware"],"content":"索引 👉 RGB 屏与 MIPI 屏基本知识 👉 小电路多学问 👉 常用开发辅助工具 ","date":"2018-08-03","objectID":"/hardware/:0:2","tags":["硬件"],"title":"【hardware 硬件技术索引】","uri":"/hardware/"},{"categories":["blog"],"content":"记录使用相关工具搭建个人博客的过程","date":"2018-08-02","objectID":"/blog/","tags":["博客"],"title":"【blog 搭建知识索引】","uri":"/blog/"},{"categories":["blog"],"content":"前言 本人不是搞网站开发的，对建站一窍不通，本专题只是记录我搭建个人博客过程的笔记，希望这些笔记能帮助那些像我一样的小白们！本专题的内容包含了 GitBook 电子书、网页 PPT、Hexo、Hugo 博客构建，其中 Hugo 是由 Go 语言实现简单而高效的静态网页构造工具，安装时不需要安装任何依赖软件，很适合我们这些小白搭建免费的个人博客。 ","date":"2018-08-02","objectID":"/blog/:0:1","tags":["博客"],"title":"【blog 搭建知识索引】","uri":"/blog/"},{"categories":["blog"],"content":"索引 👉 网站 node 包管理器 npm 👉 博客生成工具 Hugo 👉 博客生成工具 Hexo 👉 网站 PPT 生成工具 Slidev 👉 电子书制作工具 gitbook ","date":"2018-08-02","objectID":"/blog/:0:2","tags":["博客"],"title":"【blog 搭建知识索引】","uri":"/blog/"},{"categories":["other"],"content":"冬季皮肤干痒的解决之道","date":"2025-12-05","objectID":"/20251205/","tags":["其它"],"title":"冬季皮肤干痒的解决之道","uri":"/20251205/"},{"categories":["other"],"content":"前言 每到冬天，皮肤干痒就成了我的“深夜噩梦”——即便涂了补水润肤露或锁水凡士林，依旧会痒到深夜惊醒，严重影响睡眠。后来通过 AI 查询结合自身情况分析，发现问题根源与肤质特性、生活习惯及保湿方案密切相关，经过针对性调整后，终于彻底摆脱了干痒困扰。 ","date":"2025-12-05","objectID":"/20251205/:0:1","tags":["其它"],"title":"冬季皮肤干痒的解决之道","uri":"/20251205/"},{"categories":["other"],"content":"一、干痒反复的核心原因剖析 肤质先天因素：属于极度干燥+敏感肌，皮脂分泌量少，皮肤自身修复能力弱，屏障功能本就脆弱，冬季水分流失加快后，干痒问题会被急剧放大； 生活习惯误区：洗完澡后用干毛巾用力擦身，看似擦干了水分，实则严重破坏皮肤屏障，导致水分加速流失，加剧干燥； 恶性循环效应：干痒时忍不住抓挠，而抓挠会进一步损伤皮肤屏障，让皮肤更敏感、更易干痒，形成“越抓越痒、越痒越抓”的闭环。 ","date":"2025-12-05","objectID":"/20251205/:0:2","tags":["其它"],"title":"冬季皮肤干痒的解决之道","uri":"/20251205/"},{"categories":["other"],"content":"二、三重修护方案：习惯调整+屏障修复+精准保湿 针对问题根源，制定了“习惯管理+修复屏障+持续保湿”的全方位解决方案，核心是替代传统保湿产品、优化洗护流程、强化保湿效率： 更换核心护理产品：放弃单纯补水的润肤露或仅锁水的凡士林，选择兼具“皮肤屏障修复成分+强效保湿成分+锁水成分”的修护霜/身体霜，从根源修复受损屏障，而非临时补水锁水； 优化洗澡流程：洗澡水温控制在 40℃ 以内，避免高温刺激皮肤；洗澡时间缩短至 5-10 分钟，减少皮肤水分流失；选用温和无皂基的沐浴露，杜绝过度清洁破坏皮脂膜； 掌握正确保湿时机：洗完澡后用毛巾轻轻拍干身体（避免摩擦），在皮肤仍带湿润感的 3 分钟内，立刻厚涂修护霜——此时角质层充满水分，保湿霜能最大化锁住水分，效果事半功倍； 重点部位强化护理：对特别干燥、瘙痒频发的部位，厚涂修护霜并轻柔按摩促进吸收；睡前可再补涂一次，夜间集中修护受损屏障。 ","date":"2025-12-05","objectID":"/20251205/:0:3","tags":["其它"],"title":"冬季皮肤干痒的解决之道","uri":"/20251205/"},{"categories":["other"],"content":"三、修护霜/身体霜推荐清单 结合 AI 推荐及实际使用体验，整理了适合干敏肌的修复产品清单，方便根据自身需求选择： 产品名称 核心成分 主要功效 适用肤质/场景 参考渠道 理肤泉 Lipikar AP+M Triple Repair 身体霜 神经酰胺、乳木果油、烟酰胺、温泉水 48小时长效保湿，修复皮肤脂质屏障，舒缓干燥不适 极干性、敏感肌，获国家湿疹协会认可 海外 Ulta 官网 丝塔芙 致润保湿身体乳 鲸蜡醇、矿脂 基础修护，长效保湿，配方极简温和无负担 敏感肌、医美术后修护 线上及线下渠道 CeraVe 适乐肤 长效润泽修护霜 三重神经酰胺、透明质酸 24小时长效保湿，深度修复皮肤屏障，强化锁水能力 敏感肌、极干性肌肤日常护理 线上及线下渠道 妮维雅 极润低敏修护乳霜 (无香版) 配方温和无香精 基础保湿、舒缓干痒，温和不刺激 敏感肌（如酒糟肌），秋冬日常使用 @cosme 等平台 薇诺娜 舒敏保湿身体乳 神经酰胺复合物、舒缓植萃 精准修护受损屏障，缓解泛红、干痒等敏感症状 干敏肌、医美术后、换季脆弱肌 线上及线下渠道 产品选择原则： 预算充足、追求全面修护效果：优先选 理肤泉 Lipikar AP+M 或 CeraVe 修护霜，屏障修复能力强，保湿续航久； 偏好成分极简、温和安心：丝塔芙致润保湿身体乳 和 妮维雅极润低敏修护乳霜 是经典款，配方简单无多余添加，适配各类敏感肌； 皮肤极度敏感、伴随泛红干痒：薇诺娜舒敏保湿身体乳 专为敏感肌设计，舒缓修护针对性更强。 ","date":"2025-12-05","objectID":"/20251205/:0:4","tags":["其它"],"title":"冬季皮肤干痒的解决之道","uri":"/20251205/"},{"categories":["other"],"content":"四、最终效果 我最终选择了 理肤泉 Lipikar AP+M 身体霜（京东购买），严格按照上述方案执行后，困扰已久的干痒问题彻底解决——如今无论是白天日常活动，还是夜间睡眠，皮肤都保持水润舒适，再也没有出现过痒到惊醒的情况，冬季皮肤护理终于回归安心状态。 ","date":"2025-12-05","objectID":"/20251205/:0:5","tags":["其它"],"title":"冬季皮肤干痒的解决之道","uri":"/20251205/"},{"categories":["software","linux"],"content":"简单介绍 Termux 的安装及使用","date":"2025-11-17","objectID":"/20251117/","tags":["Termux","linux 工具/应用"],"title":"Termux 之 unix 模拟环境","uri":"/20251117/"},{"categories":["software","linux"],"content":" /* 一键按钮悬浮左下角样式 */ #toggleAll { font-size: 10px; position: fixed; left: 15px; bottom: 15px; z-index: 9999; box-shadow: 0 2px 8px rgba(0,0,0,0.2); transition: background 0.3s ease; } #toggleAll:hover { background: #eee; } 一键展开全部 ","date":"2025-11-17","objectID":"/20251117/:0:0","tags":["Termux","linux 工具/应用"],"title":"Termux 之 unix 模拟环境","uri":"/20251117/"},{"categories":["software","linux"],"content":"前言 Termux /ˈtɜːrmʌks/ 是一款在 Android 设备上运行的终端模拟器，支持 Linux 命令行环境，无需 root 即可使用，适合开发者、极客进行轻量编程、服务器管理等操作。但它不是简单的模拟器，而是在安卓系统里原生运行的 Linux 环境—— 基于 Debian 发行版，支持 apt 包管理，能直接安装 Python、Git、Node.js 等工具，而且不需要 root 权限。 ","date":"2025-11-17","objectID":"/20251117/:0:1","tags":["Termux","linux 工具/应用"],"title":"Termux 之 unix 模拟环境","uri":"/20251117/"},{"categories":["software","linux"],"content":"Termux 安装 1、下载安装 直接在安卓手机浏览器打开【链接】下载； 下载完成后，直接打开 apk 文件安装即可。 为了 Termux 正常运行，请允许自启动权限。 默认源为国外，下载速度较慢，可切换清华国内源提速： nano $PREFIX/etc/apt/sources.list #编辑源配置文件，将 https://mirror.sjtu.edu.cn/termux/termux-main/ #国外源替换为国内源 https://mirror.tuna.tsinghua.edu.cn/termux/apt/termux-main/ #按Ctrl+O保存，Ctrl+X退出 ","date":"2025-11-17","objectID":"/20251117/:0:2","tags":["Termux","linux 工具/应用"],"title":"Termux 之 unix 模拟环境","uri":"/20251117/"},{"categories":["software","linux"],"content":"Termux 应用 1、事前准备 安装常备工具 pkg update \u0026\u0026 pkg upgrade -y #更新包管理器（需要较长时间，平时可不用运行） pkg install git -y #安装 git工具（为拉取博客网站源文件准备） pkg install wget -y #安装wget工具（为下载hugo准备） #-----按需安装----- #pkg install python #安装 Python #pkg install nodejs #安装 Node.js #pkg install openjdk-17 #安装 Java #pkg install clang #安装 clang #pkg uninstall wget #卸载wget工具（卸载软件演示，pkg remove 相同作用，可加选项 --purge 同时清除配置文件） 2、终端应用 2.1、在 Termux 命令窗口中安装运行 hugo 静态网站生成器： 应用案例：在手机上运行基于 hugo 生成的个人博客网站： #-----下载并安装hugo----- wget https://github.com/gohugoio/hugo/releases/download/v0.92.0/hugo_0.92.0_Linux-ARM64.tar.gz #下载`hugo`（注意安卓设备的 CPU 架构，多数是 arm64） tar -zxvf hugo_0.92.0_Linux-ARM64.tar.gz -C tmp/ #解压`hugo`二进制执行文件（官方编译好的执行文件，无需要任何依赖） mv tmp/hugo /data/data/com.termux/files/usr/bin/ #并移到Termux环境变量目录（在此目录可以看到其它工具执行文件） hugo version #验证hugo是否可用（显示：hugo v0.92.0-B3549403+extended linux/amd64 BuildDate=2022-01-12T08:23:18Z VendorInfo=gohugoio） #-----下载并启动我的博客网站----- git clone https://github.com/o2ospring/mywebsite.git #拉取博客网站源文件 cd mywebsite #进入博客网站根目录 hugo server #运行hugo启动网站（退出：按Ctrl+c） 按提示在安卓手机浏览器输入 http://localhost:1313/，即可在本地浏览我的博客（网站）！ 2.2、在 Termux 命令窗口中命令后加\u0026让程序后台运行： 应用案例：hugo 启动网站，会一直占用命令窗口，在命令后加\u0026让其后台运行： cd mywebsite #进入博客网站根目录 hugo server \u0026 #运行hugo启动网站 #最后会返回到命令输入行：~/mywebsite $ ■ 此时命令窗口可继续输入其他命令（如ls），浏览器访问博客（网站）也一切正常，这表明 hugo server 仍在 Termux 后台正常运行！ 2.3、在 Termux 中打开多个会话窗口： Termux 可以打开多个会话窗口同时工作，操作如下： 3、访问手机 Termux 可以访问安卓系统的文件和文件夹，但需要手动授权并通过特定路径访问，默认情况下无法直接访问系统目录（出于保护机制）。以下是具体方法： termux-setup-storage #执行授权命令（完成受权后，生成 ~/storage/ 文件夹，其下面有手机相关文件夹软链接） ls ~/storage/ #查手机相关文件夹 #rm -rf ~/storage #Termux没有提供取消授权命令，只能通过删除软链接文件夹来取消访问权 执行后会弹出系统权限请求，点击「允许」，授权后 Termux 会在其目录下创建一个 storage 文件夹，用于映射手机的各类存储路径。例如： Termux 路径 对应安卓系统路径（示例） 说明 ~/storage/shared 手机内部存储根目录，如 /storage/emulated/0/ 可访问下载、文档、图片等 ~/storage/downloads 下载文件夹，如 /storage/emulated/0/Download/ 直接访问下载的文件 ~/storage/pictures 图片文件夹，如 /storage/emulated/0/Pictures/ 包含相册、截图等 ~/storage/dcim 相机文件夹，如 /storage/emulated/0/DCIM/Camera/ 相机拍摄的照片/视频 ~/storage/music 音乐文件夹，如 /storage/emulated/0/Music/ 音频文件 ~/storage/movies 视频文件夹，如 /storage/emulated/0/Movies/ 视频文件 略 略 略 ","date":"2025-11-17","objectID":"/20251117/:0:3","tags":["Termux","linux 工具/应用"],"title":"Termux 之 unix 模拟环境","uri":"/20251117/"},{"categories":["software","linux"],"content":"Termux 结语 1、结束语 Termux 绝对值得一试。它可能不会让你彻底抛弃电脑，但会成为你「碎片化时间」里的高效工具。毕竟，真正的生产力工具，从来都不是「必须坐在电脑前」才能用的。 // 获取按钮和所有折叠段落 const toggleBtn = document.getElementById('toggleAll'); const collapsibles = document.querySelectorAll('.collapsible'); let isAllOpen = false; // 初始状态：全部展开 // 一键切换逻辑 toggleBtn.addEventListener('click', () = { isAllOpen = !isAllOpen; collapsibles.forEach(detail = { detail.open = isAllOpen; // 控制所有details的open属性 }); // 更新按钮文字 toggleBtn.textContent = isAllOpen ? '一键折叠全部' : '一键展开全部'; }); ","date":"2025-11-17","objectID":"/20251117/:0:4","tags":["Termux","linux 工具/应用"],"title":"Termux 之 unix 模拟环境","uri":"/20251117/"},{"categories":["software","linux"],"content":"简单介绍 WSL 的安装及使用","date":"2025-11-09","objectID":"/20251109/","tags":["WSL","linux 工具/应用"],"title":"WSL 之 unix 模拟环境","uri":"/20251109/"},{"categories":["software","linux"],"content":" /* 一键按钮悬浮左下角样式 */ #toggleAll { font-size: 10px; position: fixed; left: 15px; bottom: 15px; z-index: 9999; box-shadow: 0 2px 8px rgba(0,0,0,0.2); transition: background 0.3s ease; } #toggleAll:hover { background: #eee; } 一键展开全部 ","date":"2025-11-09","objectID":"/20251109/:0:0","tags":["WSL","linux 工具/应用"],"title":"WSL 之 unix 模拟环境","uri":"/20251109/"},{"categories":["software","linux"],"content":"前言 Windows Subsystem for Linux (WSL) 是微软开发的 Windows 系统组件，能让用户在 Windows 上直接运行完整的 Linux 发行版，无需虚拟机或双系统。（官方帮助文档：WSL 文档） ","date":"2025-11-09","objectID":"/20251109/:0:1","tags":["WSL","linux 工具/应用"],"title":"WSL 之 unix 模拟环境","uri":"/20251109/"},{"categories":["software","linux"],"content":"WSL 简介 1、核心特性 原生集成：与 Windows 系统深度融合，可直接访问 Windows 文件系统（如 C 盘、D 盘），也支持 Linux 与 Windows 程序相互调用。 轻量高效：无需单独分配硬件资源，启动速度快，资源占用远低于传统虚拟机。 完整 Linux 体验：支持主流 Linux 发行版（如 Ubuntu、Debian、Fedora），包含完整的 Linux 命令行工具、包管理器和软件生态。 双系统互通：可在 WSL 中使用 Windows 的环境变量，也能在 Windows 命令行（CMD/PowerShell）中调用 Linux 命令。 2、版本差异 WSL 1 与 2 差异 版本 核心特点 适用场景 WSL 1 基于翻译层实现，启动更快 简单命令行操作、轻量开发 WSL 2 基于 Hyper-V 虚拟机技术，支持完整 Linux 内核 复杂开发环境、容器（Docker）、图形界面应用 3、适用场景 开发者在 Windows 上搭建 Linux 开发环境，无需切换系统。 运行 Linux 专属工具、脚本或服务（如 Shell 脚本、Node.js、Python 后端）。 学习 Linux 系统操作，无需单独安装 Linux 系统。 适配跨平台项目，确保开发环境与生产环境（Linux 服务器）一致。 4、注意事项 硬件要求：WSL 2 需开启 CPU 虚拟化功能（需在 BIOS 中设置），部分对硬件要求极高的 Linux 应用（如 3D 渲染）可能兼容性有限。 系统要求：WSL 2 要求 Windows 10 版本 2004 及更高版本（内部版本 19041 及更高版本）。 ","date":"2025-11-09","objectID":"/20251109/:0:2","tags":["WSL","linux 工具/应用"],"title":"WSL 之 unix 模拟环境","uri":"/20251109/"},{"categories":["software","linux"],"content":"WSL 安装 1、开启电脑虚拟化 1.1、重启电脑，进入 BIOS/UEFI。 1.2、开机时按特定键（通常是 F2、Del、F12 或 Esc，具体取决于主板型号）。 1.3、找到虚拟化设置（通常在 Advanced 或 CPU Configuration 中）： Intel CPU：启用 Intel Virtualization Technology（VT-x）； AMD CPU：启用 SVM Mode（等同于 AMD-V）。 1.4、保存设置并退出（通常按 F10）。 1.5、重启电脑进入系统确认，右键点击任务栏/任务管理器： 1.6、验证 Hypervisor 是否启动 以管理员身份运行 Windows PowerShell： bcdedit /enum | findstr hypervisorlaunchtype #验证 Hypervisor 是否启动 #如果显示 Off，则执行下面指令 hypervisorlaunchtype Auto #启动 Hypervisor，可使用上行指令查看是否启动成功 #重启电脑，此功能才能生效!!! 2、开启子系统功能 2.1、通过图形界面开启子系统功能： “开始/Windows 系统/控制面板/程序” 2.2、使用命令在线更新 WSL： 打开命令窗口 “开始/Windows PowerShell/Windows PowerShell” 右键点击选择 “以管理员身份运行” 运行： wsl --update #更新 WSL 内核 2.3、WSL 有 WSL1 和 WSL2，推荐使用 WSL2（性能更好） 以管理员身份运行 Windows PowerShell，设置使用 WSL2： wsl --set-default-version 2 #设置默认 WSL 版本为 2 2.4、其它操作方法 ● 通过命令窗口开启子系统功能： 以管理员身份运行 Windows PowerShell，开启子系统功能： dism.exe /online /enable-feature /featurename:Microsoft-Windows-Subsystem-Linux /all /norestart #启用 WSL 功能（不指定版本，默认安装 WSL2） dism.exe /online /enable-feature /featurename:VirtualMachinePlatform /all /norestart #启用虚拟机平台（WSL2 必需） Restart-Computer #重启计算机（必须） ● 使用离线安装包更新 WSL： 直接打开 WSL 微软官方 GitHub 仓库下载最新版本，例如：wsl.2.6.1.0.x64.msi，下载完后直接点击文件安装即可。 3、在线安装子系统 3.1、通过在线方式安装子系统： 以管理员身份运行 Windows PowerShell，在线安装指定发行版： wsl --list --online #列出可安装的 Linux 发行版（例如：根据显示安装 Ubuntu-22.04） wsl --install -d Ubuntu-22.04 #在线安装指定发行版：Ubuntu-22.04（默认安装到C盘，不支持指定路径） #而 wsl --install 会默认安装 Ubuntu 版本 PS：一般情况下 C 盘空间比较紧张，建议使用【离线导入】方法安装到 D 盘！譬如：先在线安装子系统，导出离线包；再卸载此子系统，导入离线包。 4、离线导入子系统 4.1、离线包来源： 从 微软文档 下载官方离线包（如 Ubuntu2204-221101.AppxBundle），但不要双击它，否则被强行安装到C盘。使用 7-Zip 或 WinRAR 将 Ubuntu2204-221101.AppxBundle/Ubuntu_2204.1.7.0_x64.appx/rootfs.tar.gz （tar 格式文件）提取出来（注：因为在第二级文件，所以需要手动进行两次解压） 从现有子系统中导出： #------【方式一】导出 .tar 镜像------ wsl --shutdown #强制关闭所有子系统（避免一些子系统干扰） wsl --list --verbose #查看已安装的发行版（例如：根据显示导出 Ubuntu-22.04） wsl --export Ubuntu-22.04 C:\\temp\\Ubuntu-22.04-1.tar #导出已安装的 Linux 发行版：Ubuntu-22.04 【备注：请事先创建 C:\\temp 文件夹】 #------【方式二】导出.vhdx 文件------ wsl --shutdown #强制关闭所有子系统（避免一些子系统干扰） wsl --list --verbose #查看已安装的发行版（例如：根据显示导出 Ubuntu-22.04） wsl --export Ubuntu-22.04 D:\\WSL\\Ubuntu-22.04-2\\Ubuntu-22.04-2.vhdx --vhd #导出已安装的 Linux 发行版：Ubuntu-22.04（备注：请事先创建 D:\\WSL\\Ubuntu-22.04-2 文件夹） #或直接复制虚拟磁盘文件，路径通常为 %USERPROFILE%\\AppData\\Local\\Packages\\\u003c发行版Package\u003e\\LocalState\\ext4.vhdx 在已有 Docker 镜像导出： #------【方式三】导出 .tar 镜像------ docker ps -a #读出容器 ID，如：0301d8f4bc6e ocker export 0301d8f4bc6e \u003e centos8.tar #导出 Docker 镜像 4.2、通过离线方式导入子系统： 从离线包导入子系统： #------【方式一】从 .tar 镜像导入------ wsl --shutdown #强制关闭所有子系统（避免一些子系统干扰） wsl --import Ubuntu-22.04-1 D:\\WSL\\Ubuntu-22.04-1 C:\\temp\\Ubuntu-22.04-1.tar --version 2 #【备注：请事先创建 D:\\WSL\\Ubuntu-22.04-1 文件夹】 #从离线包导入 Linux 发行版：Ubuntu-22.04（实际命名为 Ubuntu-22.04-1）（--version 2：指定使用 WSL2（推荐）如果只有 WSL2 可省略）（会在目标目录生成一个单一的 .vhdx 虚拟磁盘文件） wsl --list --verbose #查看已安装的发行版（此时可看到导入的 Ubuntu-22.04-1） wsl --shutdown #强制关闭所有子系统（避免一些子系统干扰） wsl -d Ubuntu-22.04-1 #启动子系统：Ubuntu-22.04（实际命名为 Ubuntu-22.04-1） # 为 Ubuntu-22.04 创建用户 adduser myname #创建一个新用户（用户名为 myname）（如果用户不存在，则执行时会提示设置密码（输入时不显示，输完按回车），还会询问用户的全名、房间号等信息（可直接按回车跳过）） usermod -aG sudo myname #将新用户添加到 sudo 用户组（用户名为 myname）（-a：表示 “追加”，-G：指定加入 sudo 组） echo -e \"[user]\\ndefault=myname\" | sudo tee -a /etc/wsl.conf #设置默认登录用户（默认登录 myname 用户，而非默认的 root 用户）（/etc/wsl.conf 是 WSL 核心配置文件）（-a表示追加内容，| 表示通过管道写入，tee 表将内容输出到文件并同时显示在终端） vi /etc/wsl.conf #使用 vi 查看配置文件是否正确（按 Esc 再输入 :q! 退出） exit #退出子系统（关闭子系统） wsl --shutdown #强制关闭所有子系统（避免一些子系统干扰） wsl -d Ubuntu-22.04-1 #启动子系统：Ubuntu-22.04（实际命名为 Ubuntu-22.04-1） #------【方式二】从.vhdx 文件导入------ wsl --shutdown #强制关闭所有子系统（避免一些子系统干扰） wsl --import-in-place Ubuntu-22.04-2 D:\\WSL\\Ubuntu-22.04-2\\Ubuntu-22.04-2.vhdx ###注意：命令是 --import-in-place #从离线包导入 Linux 发行版：Ubuntu-22.04（实际命名为 Ubuntu-22.04-2）（一旦导入成功，该子系统会被 WSL 永久记录（除非手动卸载））（.vhdx 是虚拟磁盘文件，是完整的 WSL 根文件系统镜像） wsl --list --verbose #查看已安装的发行版（此时可看到导入的 Ubuntu-22.04-2） wsl --shutdown #强制关闭所有子系统（避免一些子系统干扰） wsl -d Ubuntu-22.04-2 #启动子系统：Ubuntu-22.04（实际命名为 Ubuntu-22.04-2） # 为 Ubuntu-22.04 创建用户 adduser myname #创建一个新用户（用户名为 myname）（如果用户不存在，则执行时会提示设置密码（","date":"2025-11-09","objectID":"/20251109/:0:3","tags":["WSL","linux 工具/应用"],"title":"WSL 之 unix 模拟环境","uri":"/20251109/"},{"categories":["software","linux"],"content":"WSL 使用 1、子系统启动 1.1、子系统启动、设置及问题处理： 命令窗口运行子系统（以管理员身份运行 Windows PowerShell） 问题：提示拒绝访问，而无法启动子系统 解决：运行 wsl --shutdown（注意：本指令会关闭所有子系统）后再马上执行〖启动子系统〗命令！ 直接在开始菜单打开子系统 问题：打开子系统窗口闪退 解决：在 Windows PowerShell 命令窗口执行wsl -d Ubuntu-22.04命令运行该子系统后，再在开始菜单打开子系统！ 设置子系统复制粘贴快捷键 复制内容后，直接右键点击窗口输入区即可粘贴。 2、子系统应用 2.1、在子系统里跨文件系统编译一个工程： 应用案例：在子系统上编译【D盘】的 ESP32 工程 sudo apt-get update #准备安装软件工具（更新包管理器） sudo apt-get install git wget flex bison gperf python3 python3-pip python3-venv cmake ninja-build ccache libffi-dev libssl-dev dfu-util libusb-1.0-0 #先安装编译ESP32所需软件工具（具体过程这里不细述） cd /mnt/d/esp32_xxx/projs/hello_world #进入【用户工程】目录 export IDF_GITHUB_ASSETS=\"dl.espressif.cn/github_assets\" #设置临时环境变量（注意事项：如下↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓） ../../esp-idf-v5.1/install.sh esp32,esp32c2 #安装目标芯片工具（之前已安装，★这里不用重复操作★，否则可能要删除 $HOME/.espressif/ 和用户工程 build/，再执行上面两行命令） . ../../esp-idf-v5.1/export.sh #通过脚本设置当前环境变量 idf.py fullclean #清除之前编译所有文件 idf.py build #编译工程并且输出固件 #-------------------------------------------------- #---如果用到 USB 烧录固件，先要进行连接 USB 操作--- #---具体操作方法请看下一节【子系统 USB】内容介绍--- #------------------------------------------------------------------------------------------------------------------- # #sudo usermod -a -G dialout $USER #将用户添加到[dialout]组（配置串口写操作权限，★只需操作一次即可★） # #reboot #修改后要重启电脑 （配置串口写操作权限，★只需操作一次即可★） # idf.py -p /dev/ttyUSB0 flash #通过串口下载固件（比如 Windows 下的 COM3 串口，Linux 下的 /dev/ttyUSB0 串口） # idf.py -p /dev/ttyUSB0 monitor #通过串口监控调试（Ctrl+] 组合键退出监视） #------------------------------------------------------------------------------------------------------------------- PS：个人更建议将工程放置于子系统中进行编译构建，代码编辑工作则在 Windows 环境下完成，兼顾编译稳定性与编辑便捷性。 PS：对比 VMware 虚拟机与 WSL 的跨文件系统操作，VMware 相关系统或工具极易出现因文件所有权问题无法正常运行！ 3、子系统 USB 3.1、在子系统里使用 USB 设备： 在 WSL2 中连接 USB 设备，需要安装【USB/IP】服务端和客户端。 首先打开两个命令窗口：以管理员身份打开 PowerShell，在另外窗口启动子系统（Ubuntu）。 安装 USB/IP 服务端：在 Windows 上安装（如 usbipd-win_5.3.0_x64.msi）。 安装 USB/IP 客户端：在 Ubuntu 上安装（如 usbip-utils 2.0），命令如下： sudo apt update #准备安装软件工具（更新包管理器） sudo apt install linux-tools-generic hwdata #安装 USB/IP 客户端（用于连接 Windows 的 USB 设备） sudo update-alternatives --install /usr/local/bin/usbip usbip /usr/lib/linux-tools/*-generic/usbip 20 #设置`usbip`命令的执行工具（创建工具链软链接） #usbip version #查看 usbip 版本（如 usbip-utils 2.0） USB/IP 服务端上连接：在 Windows PowerShell 上操作 usbipd list #列出 Win 的 USB 设备（找到的目标设备 BUSID，如 1-3）（如果没启动则 Start-Service usbipd 启动服务，命令 Get-Service usbipd 可查看服务运行状态） usbipd bind --busid 1-3 #将目标设备【绑定】到【WSL】（加载的目标设备 BUSID，如 1-3）（绑定后状态：1-3 10c4:ea60 Silicon Labs CP210x USB to UART Bridge (COM4) Shared） usbipd attach --wsl --busid 1-3 #将目标设备【附加】到【子系统客户端】 （附加后状态：1-3 10c4:ea60 Silicon Labs CP210x USB to UART Bridge (COM4) Attached） #usbipd detach --busid 1-3 #将目标设备【分离】自【子系统客户端】 （分离后状态：1-3 10c4:ea60 Silicon Labs CP210x USB to UART Bridge (COM4) Shared） #usbipd unbind --busid 1-3 #将目标设备【解绑】自【WSL】（移除的目标设备 BUSID，如 1-3）（解绑后状态：1-3 10c4:ea60 Silicon Labs CP210x USB to UART Bridge (COM4) Not shared） USB/IP 客户端上查看：在子系统（Ubuntu）上操作 lsusb #查看已连接的 USB 设备（可查看到 USB 一些信息） ls -l /dev/tty* #查看串口设备（若为开发板/传感器）（如串口设备通常显示为 /dev/ttyUSB0 或 /dev/ttyACM0） #例如看到：crw-rw---- 1 root dialout 188, 0 Nov 14 20:42 /dev/ttyUSB0 4、Ubuntu 与 Windows 互访 4.1、Ubuntu 与 Windows 互访及问题处理： Ubuntu 访问 Windows 文件(夹)，例如访问 C 盘，在 WSL 命令窗口直接运行cd /mnt/c/即可访问。 Windows 访问 Ubuntu 文件(夹)，在 Windows 系统文件浏览器地址栏输入\\\\wsl$，即可看到已安装的 Linux 发行版，双击进入其文件系统（如\\\\wsl$\\Ubuntu-22.04\\home\\你的用户名）。在 Windows PowerShell 命令窗口也是这样访问，例如：cd \\\\wsl$\\Ubuntu-22.04 进入目录访问即可。 问题：提示无权限访问，并弹出提示窗口 解决：在 Windows PowerShell 命令窗口中执行wsl -d Ubuntu-22.04命令启动该子系统后，Windows 即可恢复对 Ubuntu 文件(夹)的正常访问！ PS：有一个开源工具 WSLHostPatcher 可用于解决 Windows 访问 Ubuntu 文件(夹)问题，具体方法请自行测试！ 5、安装运行 Linux 图形应用 5.1、安装运行 Linux 图形应用： 对 Windows 及 WSL 版本要求： 要求 WSL2 及 Windows 10 内部版本 19044+。 在 Windows 安装虚拟 GPU 驱动程序： 根据电脑硬件选择下载安装即可：英特尔、AMD、NVIDIA。 在 Ubuntu 安装图形应用，如 gedit： sudo apt update sudo apt install gedit 6、WSL 常用命令速查表 6.1、WSL 常用命令速查表： 常用命令及功能 命令 功能 示例 wsl --update 更新 WSL 内核 略 wsl --status 查看 WSL 状态信息 略 wsl --set-default-version 2 设置默认 WSL 版本为 2 略 wsl --list --verbose 查看已安装的[发行版][运行状态][WSL版本] wsl -l -v（简写） ws","date":"2025-11-09","objectID":"/20251109/:0:4","tags":["WSL","linux 工具/应用"],"title":"WSL 之 unix 模拟环境","uri":"/20251109/"},{"categories":["software","linux"],"content":"WSL 比较 点击展开内容 Cygwin、UnxUtils 和 WSL（Windows Subsystem for Linux）都是为 Windows 提供类 Unix 工具或环境的方案，但三者的设计目标、技术原理和适用场景差异显著。以下从核心定位、功能特性、适用场景等维度进行对比： 一、核心定位与技术原理 工具 核心定位 技术原理 UnxUtils 轻量的 Unix 命令移植工具集，仅提供常用 Unix 命令的 Windows 可执行文件。 将单个 Unix 命令（如 grep、sed）直接编译为 Windows 原生 .exe，无需依赖层，直接在 CMD/PowerShell 中运行。 Cygwin 提供 类 Unix 工具链与开发环境，支持编译和运行 Unix 程序。 通过 cygwin1.dll 模拟 Linux 系统调用，将 Unix 程序的系统调用翻译为 Windows 调用，需通过 Cygwin 工具链重新编译程序。 WSL 提供 完整的 Linux 发行版环境，支持原生 Linux 二进制程序和生态。 WSL 1 基于翻译层，WSL 2 基于轻量虚拟机和完整 Linux 内核，直接运行原生 Linux 程序（无需重新编译）。 二、核心功能对比 功能维度 UnxUtils Cygwin WSL（以 WSL 2 为主） 工具覆盖范围 仅包含基础命令（约 100+，如 ls、awk），无包管理。 包含完整工具链（gcc、bash、ssh 等），支持通过 apt-cyg 扩展。 支持所有 Linux 发行版工具（通过 apt/yum 安装），覆盖开发、服务、容器等全场景。 兼容性 仅支持命令的基础功能，部分参数与原生 Unix 有差异（如路径处理）。 需通过 Cygwin 编译的程序才能运行，部分复杂 Unix 程序可能不兼容。 直接运行原生 Linux 二进制文件（.deb/.rpm），兼容性接近真实 Linux 系统。 性能 极轻量，单命令启动快，无额外开销。 系统调用翻译有开销，IO 密集型任务（如文件操作）较慢。 本地文件系统性能接近原生 Linux，访问 Windows 文件稍慢，整体性能远高于前两者。 文件系统互通 直接使用 Windows 路径（如 C:\\），无权限模拟。 映射 Windows 磁盘为 /cygdrive/c，模拟 Linux 权限（有限）。 挂载 Windows 磁盘到 /mnt/c，Windows 可通过 \\\\wsl$ 访问 WSL 文件，权限管理完整。 生态与扩展性 无扩展性，仅固定命令集。 支持编译 Unix 程序，可搭建简单开发环境（如 C 语言）。 支持完整 Linux 生态：服务（nginx、MySQL）、容器（Docker）、图形应用（WSLg）等。 系统要求 无特殊要求，支持所有 Windows 版本。 支持 Windows 7+，无需虚拟化功能。 需 Windows 10 2004+ 或 11，WSL 2 需开启 CPU 虚拟化。 资源占用 极低（仅单个 .exe 文件）。 中等（依赖 cygwin1.dll 和工具集）。 较高（包含 Linux 内核），但远低于传统虚拟机。 三、适用场景 选择 UnxUtils 的情况 临时轻量需求：仅需少数 Unix 命令（如 grep 文本搜索、tar 解压），无需复杂环境。 快速集成：在 CMD/PowerShell 脚本中直接调用 Unix 命令，无需额外配置环境。 旧系统或资源受限：适用于 Windows XP 等老旧系统，或对资源占用有严格限制的场景。 选择 Cygwin 的情况 跨平台开发：需要在 Windows 上编译针对 Unix/Linux 的程序（依赖 Cygwin 工具链）。 中等复杂度工具链：需要 bash 脚本、make 编译、ssh 远程等功能，但无需完整 Linux 生态。 不支持 WSL 的系统：如 Windows 7，或无法开启虚拟化的设备。 选择 WSL 的情况 深度开发环境：需要完整 Linux 工具链（如 Python/Node.js 后端、systemd 服务）。 容器与云原生：使用 Docker、Kubernetes 等工具，或开发云原生应用（与生产环境一致）。 复杂脚本与服务：运行依赖 Linux 特有库的程序（如 ffmpeg 高级功能、科研软件）。 图形应用：需要运行 Linux GUI 程序（如 VS Code 远程、GIMP 等）。 四、总结 工具 优势 劣势 一句话定位 UnxUtils 极轻量、零配置、兼容性广 功能有限、无扩展性、命令兼容性一般 “Unix 命令的 Windows 便携版” Cygwin 支持开发工具链、可编译 Unix 程序 性能一般、兼容性依赖编译、配置较繁琐 “类 Unix 开发模拟器” WSL 原生 Linux 体验、完整生态、高性能 系统版本要求高、需虚拟化、资源占用较高 “Windows 中的 Linux 子系统” 选择建议： 简单命令需求 → UnxUtils； 跨平台编译或老旧系统 → Cygwin； 开发、容器、完整 Linux 环境 → WSL（首选 WSL 2）。 // 获取按钮和所有折叠段落 const toggleBtn = document.getElementById('toggleAll'); const collapsibles = document.querySelectorAll('.collapsible'); let isAllOpen = false; // 初始状态：全部展开 // 一键切换逻辑 toggleBtn.addEventListener('click', () = { isAllOpen = !isAllOpen; collapsibles.forEach(detail = { detail.open = isAllOpen; // 控制所有details的open属性 }); // 更新按钮文字 toggleBtn.textContent = isAllOpen ? '一键折叠全部' : '一键展开全部'; }); ","date":"2025-11-09","objectID":"/20251109/:0:5","tags":["WSL","linux 工具/应用"],"title":"WSL 之 unix 模拟环境","uri":"/20251109/"},{"categories":["linux"],"content":"linux 纯文本编辑器 nano 的基本使用","date":"2025-11-08","objectID":"/20251108/","tags":["nano","linux 工具/应用"],"title":"linux 纯文本编辑器 nano","uri":"/20251108/"},{"categories":["linux"],"content":" /* 一键按钮悬浮左下角样式 */ #toggleAll { font-size: 10px; position: fixed; left: 15px; bottom: 15px; z-index: 9999; box-shadow: 0 2px 8px rgba(0,0,0,0.2); transition: background 0.3s ease; } #toggleAll:hover { background: #eee; } 一键展开全部 ","date":"2025-11-08","objectID":"/20251108/:0:0","tags":["nano","linux 工具/应用"],"title":"linux 纯文本编辑器 nano","uri":"/20251108/"},{"categories":["linux"],"content":"前言 nano 是一款轻量级、易用的纯文本编辑器，广泛应用于 Linux 和类 Unix 系统中。它以简单直观的操作方式著称，特别适合新手用户，同时也能满足日常文本编辑需求。 ","date":"2025-11-08","objectID":"/20251108/:0:1","tags":["nano","linux 工具/应用"],"title":"linux 纯文本编辑器 nano","uri":"/20251108/"},{"categories":["linux"],"content":"简介 nano 核心特点 1、轻量小巧：安装包体积小，启动速度快，对系统资源占用极低，适合在服务器、嵌入式设备等资源有限的环境中使用。 2、操作简单：无需记忆复杂的快捷键组合（与 Vim 相比），界面底部会直接显示常用操作的快捷键提示，降低学习成本。 3、功能实用：支持基本的文本编辑功能（如复制、粘贴、查找替换、行号显示等），同时也包含一些进阶特性（如语法高亮、自动缩进、多文件编辑等）。 4、兼容性好：默认预装在多数 Linux 发行版（如 Ubuntu、Debian、CentOS 等）中，无需额外安装即可使用。 PS：nano 虽不如 Vim 或 Emacs 功能强大，但胜在简洁易用，是 Linux 终端中处理文本编辑任务的高效工具。 ","date":"2025-11-08","objectID":"/20251108/:0:2","tags":["nano","linux 工具/应用"],"title":"linux 纯文本编辑器 nano","uri":"/20251108/"},{"categories":["linux"],"content":"使用 nano 打开文本 nano test.txt # 编辑 test.txt，若不存在则创建 nano -l test.txt # 显示行号 nano -m test.txt # 启用鼠标支持（可点击移动光标） nano -t test.txt # 编辑完成后自动保存并退出（适合脚本中使用） nano 编辑文本 Ctrl + O：保存当前文件（按 Enter 确认文件名） Ctrl + X：退出 nano（若文件未保存，会提示是否保存） 直接使用箭头键　：移动光标（箭头键：↑, ↓, ←, →） Shift + 箭头键　：选择文本（箭头键：↑, ↓, ←, →） Shift + Home/End：选择光标前面/后面一行文本 Ctrl + K ：剪切当前行文本/剪切选中文本 Ctrl + U ：粘贴已剪切的内容。 Delete　：删除文本（向后删除） Backspace：删除文本（向前删除） Ctrl + W：查找文本（输入关键词后按 Enter，按 Alt + W 查找下一个） Ctrl + \\：查找并替换文本 Ctrl + C：显示当前光标位置（行号、列号） Ctrl + G：打开帮助文档（查看所有快捷键） // 获取按钮和所有折叠段落 const toggleBtn = document.getElementById('toggleAll'); const collapsibles = document.querySelectorAll('.collapsible'); let isAllOpen = false; // 初始状态：全部展开 // 一键切换逻辑 toggleBtn.addEventListener('click', () = { isAllOpen = !isAllOpen; collapsibles.forEach(detail = { detail.open = isAllOpen; // 控制所有details的open属性 }); // 更新按钮文字 toggleBtn.textContent = isAllOpen ? '一键折叠全部' : '一键展开全部'; }); ","date":"2025-11-08","objectID":"/20251108/:0:3","tags":["nano","linux 工具/应用"],"title":"linux 纯文本编辑器 nano","uri":"/20251108/"},{"categories":["MCU"],"content":"ESP32 工程在 linux 和 Windows 命令窗口下的编译笔记","date":"2025-10-25","objectID":"/20251025/","tags":["ESP32"],"title":"linux-ESP32编译-工程命令行编译笔记","uri":"/20251025/"},{"categories":["MCU"],"content":" /* 一键按钮悬浮左下角样式 */ #toggleAll { font-size: 10px; position: fixed; left: 15px; bottom: 15px; z-index: 9999; box-shadow: 0 2px 8px rgba(0,0,0,0.2); transition: background 0.3s ease; } #toggleAll:hover { background: #eee; } 一键展开全部 ","date":"2025-10-25","objectID":"/20251025/:0:0","tags":["ESP32"],"title":"linux-ESP32编译-工程命令行编译笔记","uri":"/20251025/"},{"categories":["MCU"],"content":"前言 在之前公司某项目开发中，团队选用 ESP32 模块为核心，我主导架构规划与核心模块开发时，需要先攻克工程编译环节，之后才能调试模块和审查相关同事代码。研读【ESP32 官方教程】发现，其内容虽全面但排布零散，对急需上手的开发者而言易陷入信息冗余的困扰。 我一贯主张“先落地应用，再深研细节”，这与校园“先学理论再实践”的模式不同。项目中开发者更需快速打通编译流程的实操方案，因此我结合本次开发经验，整理出这份聚焦实操的快速应用笔记。笔记省略冗余理论，直击编译关键步骤与技巧，助力读者快速实现工程编译，后续再逐步深挖技术细节。 ","date":"2025-10-25","objectID":"/20251025/:0:1","tags":["ESP32"],"title":"linux-ESP32编译-工程命令行编译笔记","uri":"/20251025/"},{"categories":["MCU"],"content":"一、工程文件夹概况 假设工程根目录为：esp32_xxx 假设新建用户工程：esp32_xxx/projs/aaa/ 假设复制案例工程：esp32_xxx/projs/hello_world/ 官方仓库工程平台：esp32_xxx/esp-idf-v5.1/ 备注：“官方工程平台” 在电脑中应当只有一份，不建议在每个用户工程文件夹里都放一份！ ","date":"2025-10-25","objectID":"/20251025/:0:2","tags":["ESP32"],"title":"linux-ESP32编译-工程命令行编译笔记","uri":"/20251025/"},{"categories":["MCU"],"content":"二、ESP32 工程的新建与复制（Ubuntu 20.04.1 LTS 下操作） 1、装工具和拉取仓库 sudo apt-get update #准备安装所需软件包 sudo apt-get install git wget flex bison gperf python3 python3-pip python3-venv cmake ninja-build ccache libffi-dev libssl-dev dfu-util libusb-1.0-0 #安装全部所需软件包（具体过程这里不细述）（备注：无论系统还是工具都需要较新的版本，如：ESP-IDF 需要 CMake 3.16 或以上版本） mkdir esp32_xxx #新建【esp32_xxx】文件夹 cd esp32_xxx #进入【esp32_xxx】文件夹 git clone --recursive --single-branch -b release/v5.1 https://github.com/espressif/esp-idf.git #单独拉取仓库分支【release/v5.1】，并包括仓库子模块 ##git submodule update --init --recursive #（★本指令不能使用，因仓库.gitmodules文件里url网址指向了本地子模块而非外网子模块，除非你手动下载子模块放到本地指定目录下★）如果上面有些子模块因网络原因导致拉取失败，可通过这条命令进行检测并拉取子模块（父仓库中记录的特定版本） mv esp-idf esp-idf-v5.1 #文件夹【esp-idf】改名为【esp-idf-v5.1】 sudo chmod -R 777 ../esp32_xxx #强置【esp32_xxx】目录内所有文件具备【可读+写+执行】权限（防止因权限导致异常问题，★只需设置一次即可★） mkdir projs #新建【projs】文件夹 2、假设新建用户工程 #sudo chmod -R 777 ../esp32_xxx #强置【esp32_xxx】目录内所有文件具备【可读+写+执行】权限（防止因权限导致异常问题，★只需设置一次即可★） cd esp-idf-v5.1/ #进入【ESP-IDF】工具目录（目录为 esp32_xxx/esp-idf-v5.1/） export IDF_GITHUB_ASSETS=\"dl.espressif.cn/github_assets\" #设置临时环境变量，为运行`install.sh`安装工具时优先选择乐鑫【国内】下载服务器（因国外服务缓慢，所以临时修改。备注：国外服务器为 \"dl.espressif.com/github_assets\"） ./install.sh esp32,esp32c2 #安装两目标芯片工具（安装在 $HOME/.espressif/）（安装所有：./install.sh all）（可使用 idf.py --list-targets 可查看支持的所有目标芯片） #〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓 #〓如果更换了官方工程的版本或路径，需要执行上面两行命令重新【安装两目标芯片工具】！极端情况下可能要【先】删除 $HOME/.espressif/ 和用户工程 build/ #〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓 . ./export.sh #通过脚本设置当前环境变量，为运行`idf.py`准备（注意：最前面的`. `表示将环境变量导出到当前 shell 中，否则脚本所设置的环境在其运行完后就会消失） cd ../projs/ #进入用户自定义目录（目录为 esp32_xxx/projs/） idf.py create-project aaa #新建工程（将得到应用工程为 esp32_xxx/projs/aaa/） cd aaa/ #进入用户工程（即工程目录为 esp32_xxx/projs/aaa/），此时可发现包括 main 目录（默认源文件存放处）、CMakeLists.txt 等核心配置文件，可直接基于此结构进行代码开发 idf.py set-target esp32c2 #选择具体一款目标芯片并恢复默认配置【只有新建工程才操作，★★否则会破坏原工程与芯片强相关的配置★★】（使用 idf.py --list-targets 可查看支持的所有目标芯片）（使用 idf.py docs 命令将在浏览器中打开工程[目标芯片]和[ESP-IDF版本]对应的文档）（中途失败再运行前，手动删除 esp32_xxx/projs/aaa/build 文件夹） idf.py menuconfig #进入图形配置界面可配置相关程序模块（本例 esp32c2 测试板的晶振是 26 MHz，需要修改配置：Component config ---\u003e Hardware Settings ---\u003e Main XTAL Config ---\u003e Main XTAL frequency ---\u003e 26 MHz，按 S 键保存，并按 Q 键退出） idf.py reconfigure #重新运行 CMake【当从源代码树中添加或删除了文件，或需要修改 CMake 缓存变量时，才有必要使用该命令，★而平时不需要运行★】 #编译代码：略……（如 idf.py build） #烧录固件：略……（如 idf.py -p /dev/ttyUSB0 flash） 3、假设复制案例工程 #sudo chmod -R 777 ../esp32_xxx #强置【esp32_xxx】目录内所有文件具备【可读+写+执行】权限（防止因权限导致异常问题，★只需设置一次即可★） cd esp-idf-v5.1/ #进入【ESP-IDF】工具目录（目录为 esp32_xxx/esp-idf-v5.1/） export IDF_GITHUB_ASSETS=\"dl.espressif.cn/github_assets\" #设置临时环境变量，为运行`install.sh`安装工具时优先选择乐鑫【国内】下载服务器（因国外服务缓慢，所以临时修改。备注：国外服务器为 \"dl.espressif.com/github_assets\"） ./install.sh esp32,esp32c2 #安装两目标芯片工具（安装在 $HOME/.espressif/）（安装所有：./install.sh all）（可使用 idf.py --list-targets 可查看支持的所有目标芯片） #〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓 #〓如果更换了官方工程的版本或路径，需要执行上面两行命令重新【安装两目标芯片工具】！极端情况下可能要【先】删除 $HOME/.espressif/ 和用户工程 build/ #〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓 cp -r examples/get-started/hello_world ../projs/ #直接复制示例工程(文件夹)（目录为 esp32_xxx/esp-idf-v5.1/examples/） cd ../projs/hello_world #进入用户工程（即工程目录为 esp32_xxx/projs/hello_world/），此时可发现包括 main 目录（默认源文件存放处）、CMakeLists.txt 等核心配置文件，可直接基于此结构进行代码开发 . ../../esp-idf-v5.1/export.sh #通过脚本设置当前环境变量，为运行`idf.py`准备（注意：最前面的`. `表示将环境变量导出到当前 shell 中，否则脚本所设置的环境在其运行完后就会消失） #idf.py set-target esp32c2 #选择具体一款目标芯片并恢复默认配置【只有新建工程才操作，★★否则会破坏原工程与芯片强相关的配置★★】(hello_world 默认目标芯片是 esp32)（使用 idf.py --list-targets 可查看支持的所有目标芯片）（使用 idf.py docs 命令将在浏览器中打开工程[目标芯片]和[ESP-IDF版本]对应的文档）（中途失败再运行前，手动删除 esp32_xxx/projs/hello_world/build 文件夹） idf.py menuconfig #进入图形配置界面可配置相关程序模块（例如 esp32c2 测试板的晶振是 26 MHz，需要修改配置：Component config ---\u003e Hardware Settings ---\u003e Main XTAL Config ---\u003e Main XTAL frequency ---\u003e 26 MHz，按 S 键保存，并按 Q 键退出） idf.py reconfigure #重新运行 CMake【当从源代码树中添加或删除了文件，或需要修改 CMake 缓存变量时，才有必要使用该命令，★而平时不需要运行★】 #编译代码：略……（如 idf.py build） #烧录固件：略……（如 idf.py ","date":"2025-10-25","objectID":"/20251025/:0:3","tags":["ESP32"],"title":"linux-ESP32编译-工程命令行编译笔记","uri":"/20251025/"},{"categories":["MCU"],"content":"三、ESP32 工程的编译与烧录（Ubuntu 20.04.1 LTS 下操作） 1、安装工具 #sudo apt-get update #准备安装所需软件包（之前已安装，★这里不用重复操作★） #sudo apt-get install git wget flex bison gperf python3 python3-pip python3-venv cmake ninja-build ccache libffi-dev libssl-dev dfu-util libusb-1.0-0 #安装全部所需软件包（之前已安装，★这里不用重复操作★）（备注：无论操作系统还是工具都需要较新的版本，如：ESP-IDF 需要 CMake 3.16 或以上版本） #cd esp32_xxx/esp-idf-v5.1/ #进入【ESP-IDF】工具目录（目录为 esp32_xxx/esp-idf-v5.1/） #export IDF_GITHUB_ASSETS=\"dl.espressif.cn/github_assets\" #设置临时环境变量，为运行`install.sh`安装工具时优先选择乐鑫【国内】下载服务器（因国外服务缓慢，所以临时修改。备注：国外服务器为 \"dl.espressif.com/github_assets\"） #./install.sh esp32,esp32c2 #安装两目标芯片工具（之前已安装，★这里不用重复操作★）（安装在 $HOME/.espressif/）（安装所有：./install.sh all）（可使用 idf.py --list-targets 可查看支持的所有目标芯片） #〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓 #〓如果更换了官方工程的版本或路径，需要执行上面两行命令重新【安装两目标芯片工具】！极端情况下可能要【先】删除 $HOME/.espressif/ 和用户工程 build/ #〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓 2、编译代码 #sudo chmod -R 777 esp32_xxx #强置【esp32_xxx】目录内所有文件具备【可读+写+执行】权限（防止因权限导致异常问题，★只需设置一次即可★） cd esp32_xxx/projs/aaa #进入【用户工程】目录（本例应用工程为 esp32_xxx/projs/aaa/ ，其里面包含 main 应用文件夹） . ../../esp-idf-v5.1/export.sh #通过脚本设置当前环境变量，为运行`idf.py`准备（注意：最前面的`. `表示将环境变量导出到当前 shell 中，否则脚本所设置的环境在其运行完后就会消失） #rm dependencies.lock #删除之前编译配置文件（★初次拷贝用户工程时才删除★）（当你更改工程文件夹【名称】或【路径】时，删除它并执行 idf.py fullclean 为重新全编译准备） idf.py fullclean #清除之前编译所有文件（需要重新全编译才运行本命令）（它会删除用户工程目录下 build/ 里的所有文件(夹)，所以用户不要在此文件夹放置有用的文件） idf.py build #编译工程并且输出固件（固件输出至用户工程目录下：build/aaa.bin） #idf.py size 命令将编译并显示应用程序大小，包括占用的 RAM 和 flash 及各部分的大小 #idf.py size-components 相比上面命令还会显示组件大小 #idf.py size-files 相比上面命令还会显示源文件大小 #idf.py --version 查看其版本号 #idf.py --help 可查更多命令 3、烧录固件 #sudo usermod -a -G dialout $USER #将用户添加到[dialout]组（配置串口写操作权限，★只需操作一次即可★） #reboot #修改后要重启电脑 （配置串口写操作权限，★只需操作一次即可★） idf.py -p /dev/ttyUSB0 flash #通过串口下载固件（比如 Windows 下的 COM3 串口，Linux 下的 /dev/ttyUSB0 串口） idf.py -p /dev/ttyUSB0 monitor #通过串口监控调试（Ctrl+] 组合键退出监视） 4、其它 PS：关于 dependencies.lock 引起的错误（点击展开） 因dependencies.lock配置文件会锁定组件的路径，若您修改了工程文件夹的名称或路径，则在执行编译时会出现错误。此时需将该文件中所有path:设置的组件路径更新为当前路径（原因：此前执行idf.py build会将组件路径记录为绝对路径）。解决方法示例如下： # ------《方法一》------ # 将 path: /home/o2o/workspace/esp32_xxx/esp-components/espressif__esp-modbus # 改为 path: ../../esp-components/espressif__esp-modbus # ------《方法二》------ rm dependencies.lock idf.py fullclean 备注：《方法一》只是说明错误产生原因，实际操作请使用《方法二》 PS：全编译成功最后面提示信息（点击展开） [100%] Built target aaa.elf Scanning dependencies of target gen_project_binary [100%] Generating binary image from built executable esptool.py v4.10.0 Creating esp32c2 image... Merged 1 ELF section Successfully created esp32c2 image. Generated /home/o2o/workspace/esp32_xxx/projs/aaa/build/aaa.bin [100%] Built target gen_project_binary Scanning dependencies of target app_check_size aaa.bin binary size 0x1bd90 bytes. Smallest app partition is 0x100000 bytes. 0xe4270 bytes (89%) free. [100%] Built target app_check_size Scanning dependencies of target app [100%] Built target app Project build complete. To flash, run this command: /home/o2o/.espressif/python_env/idf5.1_py3.8_env/bin/python ../../esp-idf-v5.1/components/esptool_py/esptool/esptool.py -p (PORT) -b 460800 --before default_reset --after hard_reset --chip esp32c2 write_flash --flash_mode dio --flash_size 2MB --flash_freq 60m 0x0 build/bootloader/bootloader.bin 0x8000 build/partition_table/partition-table.bin 0x10000 build/aaa.bin or run 'idf.py -p (PORT) flash' 备注：最后提示烧录固件两种方法： esptool.py命令适合量产烧录。因为可将esptool.py封装成esptool.exe工具，根据上面编译信息编写烧录脚本（如：Download_COM22.bat），可点击【量产烧录】了解！ idf.py命令适合调试烧录。 PS：重编译成功最后面提示信息（点击展开） [100%] Built target aaa.elf [100%] Built target gen_project_binary aaa.bin binary size 0x1bd90 bytes. Smallest app partition is 0x100000 bytes. 0xe4270 bytes (89%) free. [100%] Built target app_check_size [100%] Built target app Project build complete. To flash, run this command: /home/o2o/.espressif/python_env/idf5.1_py3.8_env/bin/python ../../esp-idf-v5.1/components/esptool_py/esptool/esptool.py -p (PORT) -b 460800 --before default_rese","date":"2025-10-25","objectID":"/20251025/:0:4","tags":["ESP32"],"title":"linux-ESP32编译-工程命令行编译笔记","uri":"/20251025/"},{"categories":["MCU"],"content":"四、ESP32 工程的编译与烧录（Windows 10 下操作） 1、安装工具 1、直接打开【ESP-IDF 工具安装器】下载在线安装版；或者下移网页，在《Download links to available releases and mirrors.》表单里下载离线版本，例如【Offline Installer v5.1】。 2、点击安装文件（强烈建议使用默认安装路径），其中在《安装前系统检查》界面中如出现提示请点击〈应用修复〉，在《选择组件》界面中根据实际勾选组件（不清楚可全选）。 3、最后在安装完成界面勾选全部选项，即可完成安装并打开 CMD 和 PowerShell 两个命令窗口（备注：在电脑桌面会生成这两个快捷方式文件）。 4、正常情况下，两命令窗口会提示“您现在可以编译 ESP-IDF 项目，转到项目目录并运行idf.py build编译代码”。 2、编译代码 1、在桌面上复制粘贴【ESP-IDF 5.1 PowerShell】命令窗口快捷图标，再“右击/属性/快捷方式/起始位置”填写用户工程目录，例如【C:\\Users\\pc\\Desktop\\esp32_xxx\\projs\\aaa】，最后点“确定”保存退出。 2、双击刚才创建的命令窗口快捷图标，接着运行下面命令： ..\\..\\esp-idf-v5.1\\export.ps1 #通过脚本设置当前环境变量，为运行`idf.py`准备（如果是 ESP-IDF 5.1 CMD 命令窗口，脚本为 export.bat） #rm dependencies.lock #删除之前编译配置文件（★初次拷贝用户工程时才删除★）（当你更改工程文件夹【名称】或【路径】时，删除它并执行 idf.py fullclean 为重新全编译准备） idf.py fullclean #清除之前编译所有文件（需要重新全编译才运行本命令）（它会删除用户工程目录下 build/ 里的所有文件(夹)，所以用户不要在此文件夹放置有用的文件） idf.py build #编译工程并且输出固件（固件输出至用户工程目录下：build/aaa.bin） #idf.py size 命令将编译并显示应用程序大小，包括占用的 RAM 和 flash 及各部分的大小 #idf.py size-components 相比上面命令还会显示组件大小 #idf.py size-files 相比上面命令还会显示源文件大小 #idf.py --version 查看其版本号 #idf.py --help 可查更多命令 3、烧录固件 idf.py -p COM3 flash #通过串口下载固件（比如 Windows 下的 COM3 串口，Linux 下的 /dev/ttyUSB0 串口） idf.py -p COM3 monitor #通过串口监控调试（Ctrl+] 组合键退出监视） 4、其它 PS：关于 dependencies.lock 引起的错误（点击展开） 因dependencies.lock配置文件会锁定组件的路径，若您修改了工程文件夹的名称或路径，则在执行编译时会出现错误。此时需将该文件中所有path:设置的组件路径更新为当前路径（原因：此前执行idf.py build会将组件路径记录为绝对路径）。直接执行下面命令解决： rm dependencies.lock idf.py fullclean PS：在 Windows 系统下编译的时长和问题（点击展开） 在 Windows 系统下全编译有时耗时超过 30 分钟，因涉及版本和不稳定问题，建议在 Linux 下编译代码 命令窗口有时运行过程中会卡往不动，可能是稳定性问题引起，只能重新运行命令重试 PS：关于 ESP-IDF 工具的路径长度问题（点击展开） ESP-IDF 工具的路径不能超过 90 个字符，路径过长可能会导致构建失败！所以无论上面安装或用户项目工程的工具，都不能过长或有空格、特殊字符之类！ PS：安装 ESP-IDF 工具会安装以下组件（点击展开） 内置的 Python 交叉编译器 OpenOCD CMake 和 Ninja 编译工具 ESP-IDF PS：Windows 平台工具链的标准设置 PS：idf.py 前端工具 PS：快速入门 ","date":"2025-10-25","objectID":"/20251025/:0:5","tags":["ESP32"],"title":"linux-ESP32编译-工程命令行编译笔记","uri":"/20251025/"},{"categories":["MCU"],"content":"五、ESP32 固件量产烧录方法（Windows 10 下操作） 1、量产烧录 编译完成后（编译信息），提示可使用 esptool.py 命令烧录固件，该方法适用于量产场景。用户可将 esptool.py 封装为 esptool.exe 可执行文件，并配合编译信息编写自动化烧录脚本，以提升操作效率。您可下载并解压【ESP32固件烧录演示.zip】案例文件，查看在 Windows 环境下的具体烧录流程。其中，Download_COM22.bat 脚本及其参数说明如下： @echo off ::-----------基于编译输出的最后信息复制并修改得出如下命令----------- .\\esptool.exe -p COM22 -b 460800 --before default_reset --after hard_reset --chip esp32c2 write_flash --flash_mode dio --flash_size 2MB --flash_freq 60m 0x0 bootloader.bin 0x8000 partition-table.bin 0x10000 aaa.bin ::-----------命令窗口不退出----------- pause exit 操作方法很简单：使用文本编辑工具打开Download_COM22.bat文件，将其中的COM22修改为电脑检测到的实际串口号，保存后双击Download_COM22.bat脚本即可执行烧录操作。 2、参数解释 基础参数 -p COM22：指定与 ESP32 连接的串口。Windows 系统用 COM* 表示，Linux 一般是 /dev/ttyUSB*。 -b 460800：设置烧录时的波特率，影响数据传输速度。 复位与芯片类型参数 --before default_reset：烧录前的复位操作，default_reset 会通过控制 DTR/RTS 引脚让 ESP32 复位并进入下载模式。 --after hard_reset：烧录完成后，通过硬件复位（重启）ESP32。 --chip esp32c2：明确目标芯片型号为 ESP32C2，工具会据此调整通信协议和参数。 闪存参数 write_flash：执行固件写入操作。 --flash_mode dio：设置闪存的工作模式，dio（双输入输出）是 ESP32 常用模式，支持更高数据传输率。 --flash_freq 60m：设置闪存的工作频率为 60MHz，影响数据读写速度。 --flash_size 2MB：指定闪存的总容量，需与硬件实际容量匹配。 分区与文件参数 0x1000 bootloader.bin：将引导加载程序写入地址 0x1000。 0x8000 partition-table.bin：分区表定义了闪存如何划分，需写入地址 0x8000。 0xd000 ota_data_initial.bin：OTA 数据初始化文件，写入地址 0xd000。 0x10000 littlefs.bin：把文件系统（如 LittleFS）烧录到地址0x10000。 0x40000 aaa.bin：将应用程序固件（如 aaa.bin）写入地址 0x40000。 这些地址按照 ESP32 官方规定的标准烧录位置（配置文件：esp32_xxx/projs/aaa/partitions.csv），一般情况下不要随意更改，否则可能导致设备无法启动或功能异常。 ","date":"2025-10-25","objectID":"/20251025/:0:6","tags":["ESP32"],"title":"linux-ESP32编译-工程命令行编译笔记","uri":"/20251025/"},{"categories":["MCU"],"content":"六、工程重要文件解释 PS：.espressif（点击展开） .espressif是一个 由 ESP-IDF 工具链自动创建的隐藏文件夹，主要用于存储 ESP32 开发所需的工具链、SDK 组件、缓存文件及配置信息，是 ESP-IDF 开发环境的核心依赖目录。 备注：通过【install.sh】会自动生成.espressif文件夹及下载并配置所需文件。默认位于用户主目录下：Windows：C:\\Users\\\u003c用户名\u003e\\.espressif；Linux/macOS：/home/\u003c用户名\u003e/.espressif。 PS：sdkconfig（点击展开） sdkconfig文件是项目的核心配置文件，用于存储 ESP-IDF（Espressif IoT Development Framework）的编译选项和参数。它决定了 ESP32 芯片的功能特性、外设配置、内存分配以及应用程序的行为。 备注：运行【idf.py set-target】命令将清除 build 目录，并重新生成sdkconfig文件，原来的 sdkconfig 文件保存为sdkconfig.old。此命令主要影响与芯片强相关的配置，其他配置会尽量保留，不会完全恢复到 “全新工程” 的默认状态。如果需要彻底重置配置，可以手动删除工程目录下的sdkconfig文件（该文件保存了所有配置项），之后重新执行【idf.py menuconfig】会生成全新的默认配置。 PS：CMakeLists.txt（点击展开） CMakeLists.txt文件是用于指导 CMake 构建系统如何编译和链接项目代码（如：头文件搜索路径、源文件路径列表、项目名称等），在 ESP32 工程中会包含多个 CMakeLists.txt 文件。 PS：linker.lf（点击展开） linker.lf（.ld后缀的文件）是链接脚本（Linker Script），用于指导链接器（如 GCC 的 ld）如何将编译后的目标文件（.o）和库文件组合成最终的可执行文件或固件。链接脚本的核心作用是定义内存布局和指定代码 / 数据段的放置位置。 PS：idf_component.yml（点击展开） idf_component.yml是一个关键配置文件，用于定义和管理 ESP-IDF（Espressif IoT Development Framework）组件的元数据、依赖关系及构建参数。它是 ESP-IDF v4.0 及后续版本中组件管理系统的核心组成部分，替代了早期版本使用的 component.mk 和 Kconfig 文件的部分功能。 PS：dependencies.lock（点击展开） dependencies.lock文件是用于锁定项目依赖组件版本和配置的重要文件，它确保项目在不同环境中构建时依赖的组件版本和来源保持一致，避免因依赖更新导致的兼容性问题。 备注：当dependencies.lock文件不存在时，执行【idf.py build】编译代码时会重新生成！ PS：partitions.csv（点击展开） partitions.csv是一个关键配置文件，用于定义 flash 存储器的分区表。ESP32 的 flash 空间需要被划分为多个区域，分别存储程序代码、文件系统、OTA 更新数据、校准数据等。 备注：运行【idf.py build】过程中会调用【parttool.py】读取partitions.csv相关参数！ PS：Kconfig.projbuild（点击展开） Kconfig.projbuild是一个关键的配置文件，用于定义项目级别的编译选项和配置项。它基于 Kconfig 系统，允许开发者通过菜单驱动的界面（如 idf.py menuconfig）交互式地配置项目参数，并将配置结果保存到sdkconfig文件中。 // 获取按钮和所有折叠段落 const toggleBtn = document.getElementById('toggleAll'); const collapsibles = document.querySelectorAll('.collapsible'); let isAllOpen = false; // 初始状态：全部展开 // 一键切换逻辑 toggleBtn.addEventListener('click', () = { isAllOpen = !isAllOpen; collapsibles.forEach(detail = { detail.open = isAllOpen; // 控制所有details的open属性 }); // 更新按钮文字 toggleBtn.textContent = isAllOpen ? '一键折叠全部' : '一键展开全部'; }); ","date":"2025-10-25","objectID":"/20251025/:0:7","tags":["ESP32"],"title":"linux-ESP32编译-工程命令行编译笔记","uri":"/20251025/"},{"categories":["other"],"content":"面试某企业时，对其二人组电控团队职能构成的思考","date":"2025-10-24","objectID":"/20251024/","tags":["其它"],"title":"关于软硬兼修二人组电控团队的看法","uri":"/20251024/"},{"categories":["other"],"content":"今日面试一家餐饮自动化设备企业（商业奶茶机等，很看好这类行业），得知其电控组仅师徒两人，且需兼顾软硬件工作。结合行业经验，我想聊聊这种架构的局限，以及专业三人组的核心价值。 ","date":"2025-10-24","objectID":"/20251024/:0:0","tags":["其它"],"title":"关于软硬兼修二人组电控团队的看法","uri":"/20251024/"},{"categories":["other"],"content":"师徒二人组：便利背后的隐忧 师徒模式的优势很直接：磨合成本低，经验传承直接。但两人兼顾软硬件的架构，暗藏不少风险。 首先是抗风险能力弱。若师徒任一离职，项目大概率停摆——一人掌握核心软硬件技能，交接难度极高。其次是效率与质量瓶颈，软硬件兼顾看似全能，实则容易顾此失彼，很难在单一领域做到极致，影响机器电控系统的稳定性。最后是人才储备难题，这种模式下新人需同时精通软硬件，招人门槛高，不利于团队扩张。 ","date":"2025-10-24","objectID":"/20251024/:0:1","tags":["其它"],"title":"关于软硬兼修二人组电控团队的看法","uri":"/20251024/"},{"categories":["other"],"content":"专业三人组：分工带来的质效提升 更优的架构是“硬件+软件+全能组长”的三人组，核心在于“专业分工+统筹把控”。 硬件工程师专注电路设计、元器件选型等硬件核心；软件工程师深耕程序开发、逻辑优化；组长则是“桥梁型人才”，既要懂软硬件，更要抓统筹——对接其他小组、制定技术标准、搭建研发平台、攻克核心模块。 这种架构的优势很明显：一是各司其职，专业人做专业事，研发效率和系统稳定性双双提升；二是抗风险强，单人离职不影响整体进度，新人只需专精单一领域，招人更易；三是可复用性高，组长搭建的架构和标准，能直接复用给后续同类电器研发，加速产品迭代。 ","date":"2025-10-24","objectID":"/20251024/:0:2","tags":["其它"],"title":"关于软硬兼修二人组电控团队的看法","uri":"/20251024/"},{"categories":["other"],"content":"对企业长期发展的关键价值 对企业而言，电控系统是核心竞争力。三人组架构不仅能提升现有产品质量，更能筑牢技术根基。 专业分工让技术沉淀更扎实，硬件的稳定性、软件的流畅性都有专人把控；组长搭建的研发平台和标准，能让后续新品研发少走弯路。更重要的是，稳定的团队架构能避免因人员流动导致的技术断层，为企业持续抢占市场提供保障。 团队架构的优化，从来不是“人多”的简单加法，而是“专业匹配”的乘法。从师徒二人到专业三人组，本质是从“经验驱动”转向“体系驱动”——这或许是这家企业电控组突破瓶颈的关键一步。 ","date":"2025-10-24","objectID":"/20251024/:0:3","tags":["其它"],"title":"关于软硬兼修二人组电控团队的看法","uri":"/20251024/"},{"categories":["other"],"content":"曾经希望永远不用发出去的感言","date":"2025-08-22","objectID":"/20250822/","tags":["其它"],"title":"曾经希望永远不用发出去的感言","uri":"/20250822/"},{"categories":["other"],"content":"一、前言 职场虽像一场需要认真演绎的戏，但并肩前行的我们，从来都是彼此信赖的战友。这段藏在心底、盼着永远不必说出口的感言，终究还是要带着几分惋惜，在今天讲出来。请记得这个特殊的日子 —— 2025 年 8 月 22 日，而这段感言，落笔于 8 月 30 日的微信朋友圈！ ","date":"2025-08-22","objectID":"/20250822/:0:1","tags":["其它"],"title":"曾经希望永远不用发出去的感言","uri":"/20250822/"},{"categories":["other"],"content":"二、感言 ● 四十四年前的今天，我赤手空拳来到这世间；如今站在新的人生路口，心中满是感恩。 ● 很庆幸职业生涯里，能遇见一家可靠的企业，更遇到一位有前瞻眼光的掌舵人。岗位上的朝夕耕耘，不仅让我习得专业本领，更沉淀了踏实做事的初心与扛责前行的勇气。这段并肩同行的时光，早已成了我行囊里最坚实的力量。 ● 也感谢一起打拼的伙伴们，那些共克难题时的聚力、分享喜悦时的笑意，每一段细碎日常，都温暖又珍贵。 ● 未来，我会带着这段经历赋予的力量重新起航：依旧认真生活，始终努力向前。 ","date":"2025-08-22","objectID":"/20250822/:0:2","tags":["其它"],"title":"曾经希望永远不用发出去的感言","uri":"/20250822/"},{"categories":["software"],"content":"UPDesktop 快捷启动工具","date":"2023-05-19","objectID":"/20230519/","tags":["工具"],"title":"UPDesktop 快捷启动工具","uri":"/20230519/"},{"categories":["software"],"content":"前言 像我们做开发的，要装一大堆的软件/工具，桌面变得杂乱无章。今天为大家介绍一款小众工具 UPDesktop：是一款非常简单易用的桌面快速启动程序，支持多级分组，也支持界面简单换肤，包含各种辅助功能，让你可以调整分辨率，快捷启动软件，软件分类等等。 ","date":"2023-05-19","objectID":"/20230519/:0:1","tags":["工具"],"title":"UPDesktop 快捷启动工具","uri":"/20230519/"},{"categories":["software"],"content":"工具 1、下载 直接到网上下载即可，这是作者提供的下载地址：http://url.xrdz.net/updesktop（如果打不开链接，可到本人【共享盘】下载） 2、安装 直接将压缩包解压到系统应用软件目录，例如：D:\\Program Files (x86)\\UPDesktop PS：得益于免安装特性，它可直接复制到其他电脑使用，不用重新设置参数和菜单！ 3、配置 一、首先在 UPDesktop 建好分类和分组： 二、接着将软件直接拖拽到 UPDesktop ： 三、将 UPDesktop 设置为类似开始菜单： 四、对某些软件隐藏名称、路径、启动： ● 更多软件说明，可查看官方截个图：UPDesktop/软件图片/ ● 备份软件配置，直接备份文件夹即可：UPDesktop/data/ ● 同类软件还有：GeekDesk、lucy、Maye、MayeLite 等等… 4、问题 在电脑重新上电后，UPDesktop 偶尔出现“通知区域图标-启动”和“失去焦点后-自动隐藏面板”功能失效，这就需要我们手动打开软件，打配置菜单的“常规”与“动作”，重新勾选“通知区域图标”和“失去焦点后”选项，退出配置菜单即可恢复正常。 ","date":"2023-05-19","objectID":"/20230519/:0:2","tags":["工具"],"title":"UPDesktop 快捷启动工具","uri":"/20230519/"},{"categories":["software"],"content":"简单介绍面向对象模块设计的 C 语言实现方法","date":"2023-02-22","objectID":"/20230222/","tags":["面向对象"],"title":"面向对象模块设计的 C 语言实现方法","uri":"/20230222/"},{"categories":["software"],"content":"一、前言 网上的面向对象编程文章往往是描述面向对象的思维（看了之后反而是“云里雾里”、很虚的感觉），至于如何使用代码来编写对象基本上没提及。那我们如何使用 C 语言来编写面向对象模块呢？ ","date":"2023-02-22","objectID":"/20230222/:0:1","tags":["面向对象"],"title":"面向对象模块设计的 C 语言实现方法","uri":"/20230222/"},{"categories":["software"],"content":"二、面向对象模块的设计导向 一、面向对象设计基本概念 面向对象编程 OOP（Object Oriented Programming）三个基本特征：封装、继承、多态。 封装：根据职责将属性(参数)和方法(行为)封装到一个抽象的类中。 继承：指可以让某个类型的对象获得另一个类型的对象的属性的方法。 多态：以封装和继承为前提，相同的方法调用不同的子类对象，产生不同的执行结果。 二、面向对象设计最终目标 ● 在同一应用工程中，不需要增加、修改、复制代码，一份代码可“最大限度”复用。 ● 例如：一个键盘对象模块，应用程序可以使用它“最大限度”地创建出多个键盘应用。 三、面向对象设计实施方法 1、总设计的原则为共性业务由对象模块处理；个性业务由应用模块处理。 2、对象模块只有操作代码而没有全局变量（相当于一台制作包子机器）； 3、应用模块提供全局变量（对象结构体）（相当于制作包子的原材料）。 4、对象结构体格式由对象模块定义，包括：属性（参数），方法（行为）。 5、属性（参数）主要是对相关功能参数描述，它通过变量来描述功能参数； 6、方法（行为）则是与上下层程序对接关联，它通过函数指针来关联操作。 7、关于方法（行为）的函数指针：用于通知上层程序和调用下层硬件驱动。 8、对象模块为应用模块提供业务操作函数，例如：读、写这类操作函数。 四、小结 “封装、继承、多态”是面向对象编程的思维，是“虚体”；“属性、方法”是面向对象编程的实现方法，是“实体”。使用 C 语言编程时，“属性”则是通过变量来描述功能参数，“方法”则是通过函数指针来关联上下层程序，最后由对象模块为应用层提供业务操作函数。 ","date":"2023-02-22","objectID":"/20230222/:0:2","tags":["面向对象"],"title":"面向对象模块设计的 C 语言实现方法","uri":"/20230222/"},{"categories":["software"],"content":"三、面向对象模块的组织结构 第一类（主要针对静态固有的软硬件资源，例如：COM串口、文件操作等） 1、打开操作（配置属性 → 注册方法 → 打开操作） 2、关闭操作 3、读操作 4、写操作 5、其它操作 一、例如本人编写的红外发送模块的【打开操作】： //红外发送模块提供的业务操作函数 extern int xt_irsend_open(xt_irsend_obj_t *p_ob); extern int xt_irsend_close(xt_irsend_obj_t *p_ob); extern int xt_irsend_send(xt_irsend_obj_t *p_ob, const uint16_t *pd, uint16_t size, uint8_t xus, uint8_t khz); xt_irsend_obj_t app_irsend_obj; //声明红外发送服务对象 //配置属性 app_irsend_obj.end_us = 100000; //【属性】发完1帧红外码后强行插入间隔时间（单位:us） app_irsend_obj.ir_khz = 38; //【属性】红外载波频率（预设）（单位:KHz） app_irsend_obj.ir_num = 0; //【属性】红外发送通道编号（＜IRSEND_SUM） app_irsend_obj.send_buf_size = sizeof(app_irsend_buf); //【属性】红外发送缓冲大小（单位：字节） app_irsend_obj.p_send_buf = app_irsend_buf; //【属性】红外发送缓冲 //注册方法 app_irsend_obj.p_irsend_open_fn = app_irsend_open_cb; //【应用服务】注册红外发送服务[打开]操作成功的协同回调 app_irsend_obj.p_irsend_close_fn = app_irsend_close_cb; //【应用服务】注册红外发送服务[关闭]操作成功的协同回调 app_irsend_obj.p_irsend_complete_fn = app_irsend_complete_cb; //【应用服务】注册红外发送刚刚[完成]的通知回调 app_irsend_obj.p_hw_open_fn = 0; //【硬件服务】注册硬件驱动程序（0:本应用不提供硬件驱动程序） //打开对象 if (xt_irsend_open(\u0026app_irsend_obj) \u003c 0) { rt_kprintf(\"xt_irsend_open return error!\\r\\n\"); } 备注：因个人喜好及习惯问题，配置属性和注册方法直接对对象赋值，没有提供函数操作（例如初始或注册操作函数：xt_irsend_attribute_init()、xt_irsend_method_reg()）！注意只有打开对象前才这样操作，之后绝对不能直接修改对象数据！ 二、例如网友写的类 rt_thread 操作系统【设备管理】： typedef struct cola_device cola_device_t; struct cola_device_ops { int (*init) (cola_device_t *dev); int (*open) (cola_device_t *dev, int oflag); int (*close) (cola_device_t *dev); int (*read) (cola_device_t *dev, int pos, void *buffer, int size); int (*write) (cola_device_t *dev, int pos, const void *buffer, int size); int (*control)(cola_device_t *dev, int cmd, void *args); }; struct cola_device { const char *name; //设备名称 struct cola_device_ops *dops; //设备操作 struct cola_device *next; //设备链表 }; //1.1.设备注册---------- int cola_device_register(cola_device_t *dev); //2.1.设备查找---------- cola_device_t *cola_device_find(const char *name); //2.2.设备读------------ int cola_device_read(cola_device_t *dev, int pos, void *buffer, int size); //2.3.设备写------------ int cola_device_write(cola_device_t *dev, int pos, const void *buffer, int size); //2.4.设备控制---------- int cola_device_ctrl(cola_device_t *dev, int cmd, void *arg); //一、上电初始化设备 void led_register(void) { led_gpio_init(); //网友的案例中是直接初始硬件，没有使用设备驱动来初始化硬件，也没有做[打开][关闭][读][写]服务 led_dev.dops = \u0026ops; //static struct cola_device_ops ops = { .control = led_ctrl }; ←───────┘ led_dev.name = \"led\"; cola_device_register(\u0026led_dev); } //二、应用层使用设备 void app_main(void) { app_led_dev = cola_device_find(\"led\"); while (1) { cola_device_ctrl(app_led_dev, LED_TOGGLE, 0); delay_ms(500); } } 设备管理从更高的角度来设计对象，可以统一所有硬件操作函数，统一所有硬件管理，非常值得我们学习和使用的面向对象编程！ 第二类（主要针对可动态复用的软硬件资源，例如：抽象设备、信号量等） 1、创建操作（申请内存 → 初始化 → 返回句柄） 2、删除操作 3、读操作 4、写操作 5、其它操作 例如 RT-thread 实时操作系统的信号量【创建操作】： rt_sem_t p_sem = RT_NULL; //创建对象 if ((p_sem = rt_sem_create(\"sem\", 0, RT_IPC_FLAG_FIFO)) == RT_NULL) { rt_kprintf(\"rt_sem_create return error!\\r\\n\"); } ","date":"2023-02-22","objectID":"/20230222/:0:3","tags":["面向对象"],"title":"面向对象模块设计的 C 语言实现方法","uri":"/20230222/"},{"categories":["software"],"content":"四、面向对象模块的内部处理 一、静态面向对象的开关互斥处理 因为对象是一个大数据综合体，每一步的操作必定出现临界问题，也就是共享资源竞争问题。其中打开与关闭对象的处理原则如下： 1、首先“判断是否存在” 2、接着“先占有再使用” 3、然后“进行相关操作” 4、最后“清除占用标志” 在“占有”期间，如果此时执行关闭操作，则会返回出错或忙！表明对象正打开中（打开操作还没完成），不能进行关闭操作！ ","date":"2023-02-22","objectID":"/20230222/:0:4","tags":["面向对象"],"title":"面向对象模块设计的 C 语言实现方法","uri":"/20230222/"},{"categories":["linux"],"content":"linux 命令帮助工具 tldr 的安装与使用","date":"2023-02-15","objectID":"/20230215/","tags":["linux 工具/应用"],"title":"linux 命令帮助工具 tldr","uri":"/20230215/"},{"categories":["linux"],"content":"tldr 的简介 tldr（Too Long Didn’t Read 太长不看）是开源的命令帮助工具。像本人一样记性不好的同学，经常忘记命令的用法，使用系统自带工具 man 来查看命令帮助，这些官方注释“又长又臭”，很多时候宁愿百度也不愿意看它！因为很多时候我们只需简单应用，给出几个常用选项参数及几个高频使用例子即可。tldr 就是为此而生：清晰的排版、言简的说明、只收集高频使用的实际例子！ ","date":"2023-02-15","objectID":"/20230215/:0:1","tags":["linux 工具/应用"],"title":"linux 命令帮助工具 tldr","uri":"/20230215/"},{"categories":["linux"],"content":"Ubuntu 平台 1、tldr 的安装 tldr 提供好几种的安装方法，当你系统有编译器时，可以自己编译安装；也可以使用其它工具来安装，但受系统环境影响可能会失败（本人使用好几个 npm 版本来安装都没成功）！ 1、从源码编译 git clone https://github.com/tldr-pages/tldr-c-client.git # 使用 git 下载源代码 cd tldr-c-client # 进入目录 sudo ./deps.sh # 安装依赖（注意：一定要加 sudo 权限操作，否则会操作失败） sudo make # 编译 tldr sudo make install # 安装 tldr 2、使用 npm 安装 npm install -g tldr # 本人使用好几个 npm 版本来安装都没成功！ 3、使用 python pip 安装 pip3 install tldr 4、使用 homebrew 安装 brew install tldr # MacOS 系统下安装 2、tldr 的使用 用法很简单，在 tldr 后面加入要查看的命令再回车即可。 tldr tar # 查看 tar 命令使用帮助 ","date":"2023-02-15","objectID":"/20230215/:0:2","tags":["linux 工具/应用"],"title":"linux 命令帮助工具 tldr","uri":"/20230215/"},{"categories":["other"],"content":"对集中式控制系统优缺点的分析","date":"2022-10-18","objectID":"/20221018/","tags":["其它"],"title":"对集中式控制系统优缺点的分析","uri":"/20221018/"},{"categories":["other"],"content":"一、内容 结合自己使用经验和网上搜索到的相关知识，对集中式控制系统作简单的分析。总体来说，集中式控制系统架构简单、数据集中处理，有很大的优点，但也有很大的缺点！ 技术 优点 缺点 部署结构 部署结构简单，只有主机和终端两级关系 因为主机需要管理全部终端，随着终端增加，主机处理数据增多，系统会变得越来越臃肿 集中管理 信息与控制集中管理，具有控制关系简单，能实现统一的数据收集、数据处理、数据存储、过程监视、过程控制等 由于大量功能集于一身，也把危险集中在主机身上，主机一旦发生故障（如:主机网线松脱），将导致系统全面瘫痪 联动控制 所有控制都经过主机，控制时序得以保证 所有控制都经过主机，需要排队处理，当终端或数据越多时，响应速度就会变得很慢（时效性低） 工程布线 线路拓扑简单，所有线缆统一拉向主机（终端非共用系统网络，终端线路出现问题不会影响到系统网络） 线缆过多，民用受空间限制；难预留线缆，扩展性不友好 参考资料： 集中式控制系统有什么优缺点、集中型计算机控制系统-百度百科、集中式系统-百度百科、工业控制网络常用通信协议。 知识扩展： 集中式控制系统：实现功能及资源统一控制。 分布式控制系统：实现分散控制和分级控制，采用多层分级、合作自治的结构形式。采用分级递阶结构，每一级由若干子系统组成，每一个子系统实现若干特定的有限目标，形成金字塔结构。 ","date":"2022-10-18","objectID":"/20221018/:0:1","tags":["其它"],"title":"对集中式控制系统优缺点的分析","uri":"/20221018/"},{"categories":["MCU","linux"],"content":"linux-STM32F开发㈢-在线调试工具CGDB","date":"2022-09-16","objectID":"/20220916/","tags":["GDB","ARM Cortex-M"],"title":"linux-STM32F开发㈢-在线调试工具CGDB","uri":"/20220916/"},{"categories":["MCU","linux"],"content":"一、前言 GDB（GNU symbolic debugger）是 Linux 平台下使用最多的一款调试器，常用命令虽不多，但操作起来真心不方便。操作不方便、代码不能高亮、不能边看代码边调试，这几点应该是造成很多人不愿意长期使用的原因（后来集成 TUI 模式有所改善，在调试窗口按Ctrl+X+A进入/退出 TUI 模式）。CGDB 可以看作 GDB 的界面增强版，用来替代 GDB 的 gdb-tui。CGDB 主要功能是在调试时进行代码的同步显示，这无疑增加了调试的方便性，提高了调试效率。由于界面类似 vi，符合 unix/linux 下开发人员习惯，所以如果熟悉 gdb 和 vi，几乎可以立即使用 CGDB。 ","date":"2022-09-16","objectID":"/20220916/:0:1","tags":["GDB","ARM Cortex-M"],"title":"linux-STM32F开发㈢-在线调试工具CGDB","uri":"/20220916/"},{"categories":["MCU","linux"],"content":"二、安装 1、arm-none-eabi-gdb 的安装 arm-none-eabi-gcc（包含 arm-none-eabi-gdb）为 ARM 框架、无供应商、无系统、嵌入式二进制接口的交叉编译器，一般适合 ARM7、Cortex-M、Cortex-R 内核的芯片使用，它使用的是 newlib 这个专用于嵌入式系统的 C 库，用于编译裸机程序（u-boot、kernel、单片机程序），但是不能编译 Linux 应用程序。注意：交叉编译器目前都是 32 位执行程序，依赖 32 位库，事前需要安装 ia32-libs（网文）或 lsb-core。进入网页选择你需要的版本下载：官网最新版、官网 2021 版、Ubuntu-launchpad 软件开发者平台 及依赖 lsb-core。补充：关于 Windows 版本，为直接安装文件，双击安装即可，还有安装后需要手工加入环境变量【如图】。 ###################################### # 一、安装较新版本的 arm-none-eabi-gcc ###################################### wget https://developer.arm.com/-/media/Files/downloads/gnu-rm/10.3-2021.10/gcc-arm-none-eabi-10.3-2021.10-x86_64-linux.tar.bz2 # 下载交叉编译器压缩包 sudo tar -xjvf gcc-arm-none-eabi-10.3-2021.10-x86_64-linux.tar.bz2 -C /usr/lib/gcc # 将交叉编译器压缩包解压到：/usr/lib/gcc sudo gedit /etc/profile # 打开环境变量,在文件最后添加内容：export PATH=$PATH:/usr/lib/gcc/gcc-arm-none-eabi-10.3-2021.10/bin source /etc/profile # 使能环境变量。 sudo apt-get install lsb-core # 64位操作系统需要安装32位依赖库：lsb-core （arm-none-eabi-gcc 用到） sudo apt-get install lib32ncurses5 # 64位操作系统需要安装32位依赖库：lib32ncurses5（arm-none-eabi-gdb 用到） arm-none-eabi-gcc -v # 查看版本(验证是否安装成功) arm-none-eabi-gdb --version # 查看版本(验证是否安装成功) ###################################### # 二、arm-none-eabi-gcc 多版本处理方法 ###################################### #####加gcc版本优先级方法##### # 注意要把之前在环境变量加入的软件执行文件路径移除，否则可能会冲突！ sudo update-alternatives --install /usr/bin/arm-none-eabi-gcc arm-none-eabi-gcc /usr/lib/gcc/gcc-arm-none-eabi-5_4-2016q3/bin/arm-none-eabi-gcc 999 --slave /usr/bin/arm-none-eabi-addr2line arm-none-eabi-addr2line /usr/lib/gcc/gcc-arm-none-eabi-5_4-2016q3/bin/arm-none-eabi-addr2line --slave /usr/bin/arm-none-eabi-ar arm-none-eabi-ar /usr/lib/gcc/gcc-arm-none-eabi-5_4-2016q3/bin/arm-none-eabi-ar --slave /usr/bin/arm-none-eabi-as arm-none-eabi-as /usr/lib/gcc/gcc-arm-none-eabi-5_4-2016q3/bin/arm-none-eabi-as --slave /usr/bin/arm-none-eabi-c++ arm-none-eabi-c++ /usr/lib/gcc/gcc-arm-none-eabi-5_4-2016q3/bin/arm-none-eabi-c++ --slave /usr/bin/arm-none-eabi-c++filt arm-none-eabi-c++filt /usr/lib/gcc/gcc-arm-none-eabi-5_4-2016q3/bin/arm-none-eabi-c++filt --slave /usr/bin/arm-none-eabi-cpp arm-none-eabi-cpp /usr/lib/gcc/gcc-arm-none-eabi-5_4-2016q3/bin/arm-none-eabi-cpp --slave /usr/bin/arm-none-eabi-elfedit arm-none-eabi-elfedit /usr/lib/gcc/gcc-arm-none-eabi-5_4-2016q3/bin/arm-none-eabi-elfedit --slave /usr/bin/arm-none-eabi-g++ arm-none-eabi-g++ /usr/lib/gcc/gcc-arm-none-eabi-5_4-2016q3/bin/arm-none-eabi-g++ --slave /usr/bin/arm-none-eabi-gcc-ar arm-none-eabi-gcc-ar /usr/lib/gcc/gcc-arm-none-eabi-5_4-2016q3/bin/arm-none-eabi-gcc-ar --slave /usr/bin/arm-none-eabi-gcc-nm arm-none-eabi-gcc-nm /usr/lib/gcc/gcc-arm-none-eabi-5_4-2016q3/bin/arm-none-eabi-gcc-nm --slave /usr/bin/arm-none-eabi-gcc-ranlib arm-none-eabi-gcc-ranlib /usr/lib/gcc/gcc-arm-none-eabi-5_4-2016q3/bin/arm-none-eabi-gcc-ranlib --slave /usr/bin/arm-none-eabi-gcov arm-none-eabi-gcov /usr/lib/gcc/gcc-arm-none-eabi-5_4-2016q3/bin/arm-none-eabi-gcov --slave /usr/bin/arm-none-eabi-gcov-tool arm-none-eabi-gcov-tool /usr/lib/gcc/gcc-arm-none-eabi-5_4-2016q3/bin/arm-none-eabi-gcov-tool --slave /usr/bin/arm-none-eabi-gdb arm-none-eabi-gdb /usr/lib/gcc/gcc-arm-none-eabi-5_4-2016q3/bin/arm-none-eabi-gdb --slave /usr/bin/arm-none-eabi-gdb-py arm-none-eabi-gdb-py /usr/lib/gcc/gcc-arm-none-eabi-5_4-2016q3/bin/arm-none-eabi-gdb-py --slave /usr/bin/arm-none-eabi-gprof arm-none-eabi-gprof /usr/lib/gcc/gcc-arm-none-eabi-5_4-2016q3/bin/arm-none-eabi-gprof --slave /usr/bin/arm-none-eabi-ld arm-none-eabi-ld /usr/lib/gcc/gcc-arm-none-eabi-5_4-2016q3/bin/arm-none-eabi-ld --slave /usr/bin/arm-none-eabi-ld.bfd arm-none-eabi-ld.bfd /usr/lib/gcc/gcc-arm-none-eabi-5_4-2016q3/bin/arm-none-eabi-ld.bfd --slave /usr/bin/arm-none-eabi-nm arm-none-eabi-nm /usr/lib/gcc/gcc-arm-none-eabi-5_4-2016q3/bin/arm-none-eabi-nm --slave /usr/bin/arm-none-eabi-objcopy arm-none-eabi-objcopy /usr/lib/gcc/gcc-arm-none-eabi-5_4-2016q3/bin/arm-none-eabi-objcopy --slave /usr/bin/arm-none-eabi-objdump arm-none-eabi-objdump /usr/li","date":"2022-09-16","objectID":"/20220916/:0:2","tags":["GDB","ARM Cortex-M"],"title":"linux-STM32F开发㈢-在线调试工具CGDB","uri":"/20220916/"},{"categories":["MCU","linux"],"content":"三、使用 ■【使用的演示工程说明】■ 本案例为基于【5_rt-thread】演示工程（工程路径：5_rt-thread/bsp/stm32/stm32f103-atk-warshipv3），烧录/调试前要对工程进行编译（编译记得加-g选项 ），最终生成固件及调试文件！【特别说明】：因 CGDB（v0.8.0）要求 GDB（arm-none-eabi-gdb） 版本≥7.12，但使用 arm-none-eabi-gcc 10.3 编译时出现编译器与 rt-thread V4.0.3 操作系统有几个宏名称相同的错误！目前处理方法：编译使用 arm-none-eabi-gcc 5.4 旧版来编译，调试使用 arm-none-eabi-gcc 10.3 新版来调试！备注：选择 arm-none-eabi-gcc 工作版本请看上面章节！ 1、arm-none-eabi-gdb 的基本使用 1.1、第一步：在命令窗口启动 OpenOCD 服务 前提条件： 输入命令： sudo openocd -f interface/jlink_swd.cfg -f target/stm32f1x.cfg # 配置文件完整路径：/usr/local/share/openocd/scripts/ 下的 interface/stlink-v2.cfg 和 target/stm32f1x.cfg 结果如下： 备注-1：启动 gdb 对 C/C++ 程序的调试，必须要在编译前就加上 -g 选项！ 备注-2：在 Windows 系统下，j-link 的原厂应用驱动软件，也提供 GDB 对接服务，直接打开【J-Link GDB Server】可视界面操作即可！ 1.2、第二步：在另一命令窗口运行 GDB 调试 ############################################## # ①、在 shell 命令窗口运行 ############################################## # 1.1、运行 gdb arm-none-eabi-gdb ./build/gcc/rt-thread.elf ############################################## # ②、在 gdb 命令窗口运行（输入命令后回车） ############################################## # 2.0、修改 gdb 本次连接超时时间（防止openocd与仿真器速度低造成超时） set remotetimeout 60 #修改超时时间 #show remotetimeout #查看超时时间 # 2.1、连接 openocd target remote localhost:3333 # 2.2、复位并暂停处理器（monitor表示向外部服务传送命令） monitor reset halt # 2.3、下载固件（实测无需复位暂停处理器直接load也可以） load # 2.4、设置临时断点（main函数） tb main # 2.5、运行程序 c 运行结果： 2、CGDB 的基本使用 2.1、第一步：查看 arm-none-eabi-gdb 版本 # 查看版本，用于验证其是否可正常工作 arm-none-eabi-gdb --version # CGDB（v0.8.0）要求 gdb 版本≥7.12 ############################################## # 出现问题：提示信息显示找不到 libncurses.so.5 ############################################## arm-none-eabi-gdb: error while loading shared libraries: libncurses.so.5: cannot open shared object file: No such file or directory ############################################## # 解决方法：安装所需32位依赖库 lib32ncurses5 ！ ############################################## sudo apt-get install lib32ncurses5 备注-1：启动 gdb 对 C/C++ 程序的调试，必须要在编译前就加上 -g 选项！ 备注-2：CGDB（v0.8.0）要调用 arm-none-eabi-gdb，要求 gdb 的版本必须大于等于 7.12 2.2、第二步：在命令窗口启动 OpenOCD 服务 前提条件： 输入命令： sudo openocd -f interface/jlink_swd.cfg -f target/stm32f1x.cfg # 配置文件完整路径：/usr/local/share/openocd/scripts/ 下的 interface/jlink_swd.cfg 和 target/stm32f1x.cfg 结果如下： 2.3、第三步：在另一命令窗口运行 CGDB 调试 ############################################## # ①、在 shell 命令窗口运行 ############################################## # 1.1、运行 cgdb cgdb -d arm-none-eabi-gdb ./build/gcc/rt-thread.elf ############################################## # ②、在 cgdb 命令窗口运行（输入命令后回车） ############################################## # 2.0、修改 gdb 本次连接超时时间（防止openocd与仿真器速度低造成超时） set remotetimeout 60 #修改超时时间 #show remotetimeout #查看超时时间 # 2.1、连接 openocd target remote localhost:3333 # 2.2、复位并暂停处理器（monitor表示向外部服务传送命令） monitor reset halt # 2.3、下载固件（实测无需复位暂停处理器直接load也可以） load # 2.4、设置临时断点（main函数） tb main # 2.5、运行程序 c 运行结果： 备注-1：启动 gdb 对 C/C++ 程序的调试，必须要在编译前就加上 -g 选项！ 备注-2：CGDB（v0.8.0）要调用 arm-none-eabi-gdb，要求 gdb 的版本必须大于等于 7.12 3、CGDB/OpenOCD 使用总结 ########连接USB ######## 虚拟机/可移动设备/SEGGER J-Link/连接 ########下载固件######## sudo openocd -f interface/jlink_swd.cfg -f target/stm32f1x.cfg -c init -c \"reset halt; wait_halt; flash write_image erase out/project.hex\" -c reset -c shutdown # 备注：/usr/local/share/openocd/scripts/ 下的 interface/jlink_swd.cfg 和 target/stm32f1x.cfg #(1)####调试程序######## #【在一个命令窗口启动openocd服务】 # 备注：编译要加[-g]选项！ sudo openocd -f interface/jlink_swd.cfg -f target/stm32f1x.cfg #(2) #【在另一命令窗口启动cgdb+gdb服务】 cgdb -d arm-none-eabi-gdb ./build/gcc/rt-thread.elf #（也可先运行命令 cgdb -d arm-none-eabi-gdb 进入gdb后再运行命令 file ./build/gcc/rt-thread.elf 装载调试文件） set remotetimeout 60 # 在cgdb里:修改gdb本次连接超时时间（防止openocd与仿真器速度低造成超时） target remote localhost:3333 # 在cgdb里:连接openocd服务（但会提示：首选GDB命令为 target extended-remote localhost:3333 而不是 target remote localhost:3333） monitor reset halt # 在cgdb里:复位并暂停处理器（monitor表示向外部服务传送命令） load # 在cgdb里:装载调试固件（实测无需复位暂停处理器直接load也可以） tb main # 在cgdb里:在main函数设置临时断点 c # 在cgdb里:运行程序（可用 ctrl+c 强制退出运行，暂停运行时可 monitor reset halt 复位程序，再 c 运行程序） ########一键调试######## #【适合Makefile里执行“一键调试”】 # 注意：要事先处理libusb的操作权限！具体请查","date":"2022-09-16","objectID":"/20220916/:0:3","tags":["GDB","ARM Cortex-M"],"title":"linux-STM32F开发㈢-在线调试工具CGDB","uri":"/20220916/"},{"categories":["MCU","linux"],"content":"三、扩展 1、IDE 集成开发环境的组成 组件 说明 代码编辑工具 IDE 直接使用 QScitinal 这类的编辑器库 代码智能提示 IDE 后台调用 clang 工具 语法错误检测 IDE 后台调用 gcc 或者 clang 对代码语法错误动态检测 工程文件组织 IDE 使用的是 makefile，后台调用 make 工具 编译 IDE 后台调用 gcc 或者 clang 编译器编译 调试器 IDE 后台调用 OpenOCD 连接调试器和板子 下载 IDE 后台调用 OpenOCD 命令下载固件 调试 IDE 后台调用 gdb，给 gdb 发命令，gdb 再给 OpenOCD 发命令，OpenOCD 再指挥调试器控制板子。实现单步执行，查看变量值，寄存器等 2、CGDB/GDB 应用及命令知识 《linux-调试-linux 调试仿真工具》 ","date":"2022-09-16","objectID":"/20220916/:0:4","tags":["GDB","ARM Cortex-M"],"title":"linux-STM32F开发㈢-在线调试工具CGDB","uri":"/20220916/"},{"categories":["other"],"content":"对技术型创业团队的看法","date":"2022-08-28","objectID":"/20220828/","tags":["其它"],"title":"对技术型创业团队的看法","uri":"/20220828/"},{"categories":["other"],"content":"一、内容 对技术型创业团队，有两个重要组成部分，一个前端，另一个是后端。前端主要是负责制定产品需求和开拓市场，后端主要是产品开发（可能还会包括生产等）。前方需要勇往直前地向前冲锋陷阵，后方需要为前方战士提供足够强大的枪支弹药。枪支弹药犹如基石，只有稳固基石，才能保证战士用力向前蹬。如果基石不稳，战士很容易倒下！当前方为我们找到了切入点，后方需要提供锋利坚硬的刀并用力劈下去。如果刀不锋利，劈不进；如果刀不坚硬，很容易碎掉；如果不用力，无法劈石头。从技术来说，如何做到提供“足够强大的枪支弹药”和“锋利坚硬的刀”？做开发的同学都知道，全新开发一款设备/产品，必定是存在或多或少的问题。就算是启用资深工程师来开发，也不能保证百分百无错误！本人刚做设计时，软硬件都做，后来专注软件方面设计，所以本文主要从软件技术的角度去分析如何保证设计尽可能不出问题…… 待续…… ","date":"2022-08-28","objectID":"/20220828/:0:1","tags":["其它"],"title":"对技术型创业团队的看法","uri":"/20220828/"},{"categories":["MCU","linux"],"content":"linux-STM32F开发㈡-调试器的安装与使用","date":"2022-08-08","objectID":"/20220808/","tags":["Makefile","ARM Cortex-M"],"title":"linux-STM32F开发㈡-调试器的安装与使用","uri":"/20220808/"},{"categories":["MCU","linux"],"content":"一、前言 对于单片机的开发，我们离不开仿真器（烧录器）的使用，平常我们都是图形界面下操作，而本文主要介绍命令窗口下的仿真器驱动安装与使用。目前的 DSP、FPGA、ARM、部分单片机等主流芯片均支持 JTAG 协议，也就是说绝大部分仿真器都是 JTAG 接口。JTAG（Joint Test Action Group 联合测试行动小组）作为一项国际标准测试协议（IEEE 1149.1 兼容），主要用于芯片内部测试和调试。SWD（Serial Wire Debug 串行线调试）是 ARM 设计的协议，用于对其微控制器进行编程和调试。支持 JTAG 接口必定支持 SWD，而且 SWD 使用引脚更少、速度更快、稳定性更好、且支持打印调试信息！ ","date":"2022-08-08","objectID":"/20220808/:0:1","tags":["Makefile","ARM Cortex-M"],"title":"linux-STM32F开发㈡-调试器的安装与使用","uri":"/20220808/"},{"categories":["MCU","linux"],"content":"二、安装 1、j-link 应用驱动安装 待续…… 2、st-link 应用驱动安装 官方开源驱动、ST-Link 的安装教程 待续…… 3、OpenOCD 应用驱动安装 OpenOCD（Open On-Chip Debugger）是一个开源的 JTAG 上位机调试程序，支持驱动 st-link、j-link 等多种主流的调试器，支持 ARM7、ARM9、ARM10、ARM11 和 Cortex（如：STM32F103） 等多种内核处理器。听说它是一位国外研究生在上学时构思与完成的软件，更多介绍可到【开源中国】看看。OpenOCD 以提供源码方式来编译及安装，所以事先需要安装 make、gcc 工具！关于 OpenOCD 下载，进入【代码仓库站点】，点击里面的 Download 按钮下载 【openocd-0.11.0.zip】 压缩包。如果你没编译条件，也可直接【下载】第三方编译好的软件，解压后配置环境变量即可（执行文件所在目录，如：openocd-0.11.0-5/bin/）。特别说明：由于 OpenOCD 是上位机软件（是仿真器与调试软件之间的连接器），压根不能驱动仿真器，所以事先需要安装 USB 硬件驱动程序 【libusb】！资料：官网、官方手册。扩展：【openOCD RISC-V 版】为 RISC-V 处理器专用版，具体参考【网文】；【OpenOCD for Windows】为已编译好的 Windows 版，直接复制到对应目录并加入环境变量即可使用！ 3.1、linux 系统下安装： unzip -q openocd-0.11.0.zip # 解压zip压缩包 cd openocd-0.11.0/ # 进入刚才解压出的文件夹 sudo apt-get install libusb-1.0-0-dev # 安装依赖Libusb库（./configure时会检查libusb组件，找不到会显示：- USB .... no） ./configure # 进行自动默认配置（在最后可以看到支持的调试器类型以及是否已打开） # ./configure --enable-jlink # 如果你使用调试器是J-Link，但默认配置里它没被打开，运行本行命令！ # ./configure -h # 当你的是其它调试器，运行帮助命令查看具体是哪条选项来打开调试器。 make # 编译OpenOCD软件（OpenOCD可以使用gcc和clang两个编译器进行编译） sudo make install # 安装OpenOCD软件（默认安装到 /usr/local/share/openocd/） openocd -v # 查看OpenOCD版本（用于验证是否安装成功，当前版本为：0.11.0） 3.2、安装不正确出现的问题： 3.2.1、libusb 组件的安装问题 3.2.2、烧录固件提示找不到驱动 4、libusb USB 低层硬件驱动介绍 libusb 是一个由 C 语言开发的开源库，可帮助开发者在应用层面上直接与 USB 硬件进行通讯，它属于通用的 USB 硬件驱动库，可跨平台移植。安装 libusb 的目的，其实就是因为 OpenOCD 只把 J-link 等仿真器当作普通的 USB 设备来使用，不使用 J-link 自带的仿真器驱动程序。注意：由于 libusb 操作需要 ROOT 权限，需要手工配置普通用户拥有读写权限！资料：libusb 新官网、libusb 旧官网、libusb Windows 版、libusb sourceforge 下载、libusb github 下载。 4.1、linux 系统下的编译安装： tar -xjvf libusb-1.0.26.tar.bz2 # 解压压缩包 cd libusb-1.0.26 # 进入刚才解压出的文件夹 ./configure --build=x86_64-linux --disable-udev # 进行基本配置（Windows系统选项参数貌似为：--build=mingw32） # ./configure -h # 可查看一些选项参数内容 make # 编译libusb软件 sudo make install # 安装libusb软件（默认安装到 /usr/local/lib/） 4.2、Windows 系统下的安装工具： 在 Windows 系统下，我们把 j-link 原厂驱动转换成 openocd 可以识别的 Libusb-WinUSB 驱动之后，j-flash、j-Men 等软件就无法使用了，也无法在 Keil 中使用 j-link 烧录和调试程序。如果想使用这些工具，就必须把驱动还原回去，这时候 USBDriverTool 软件就派上用场了。在 USBDriverTool 软件界面上操作如下： a）先插好 j-link 然后在 j-link 设备上单击右键； b）转换：选择Install Libusb-WinUSB即可完成驱动的转换。 c）恢复：选择Restore default driver即可恢复原驱动。 补充：关于【USBDriverTool】与【Zadig】两款驱动工具，可以阅读【解决 openocd 无法识别 jlink 问题】的博文介绍。 4.3、linux 系统下的 root 权限操作： 在 linux 系统下操作 USB 设备，必须需要 root 权限，由于 OpenOCD 需要调用 libusb 驱动库来操作 USB 设备，所以在后面介绍的openocd命令前面都加入sudo的权限操作！每次手工输入openocd前增加sudo还无所谓，但在自动脚本执行就不允许加sudo了，要事前设置当前用户拥有指定 USB 设备的操作权限。因为【st-link 官方开源驱动】与【OpenOCD】都是使用 libusb 来驱动 USB 设备，所以它们的设置方法是一样的。如果是使用 st-link，直接使用 stlink 开源代码中 stlink/config/udev/rules.d/目录下对应的配置文件（如:49-stlinkv1.rules）；如果使用 j-link 则参照 ST 改写为另一个配置文件50-jlink.rules即可。具体如下： ● 第一步：创建权限配置文件，其内容如下： # SEGGER J-Link PLUS SUBSYSTEMS==\"usb\", ATTRS{idVendor}==\"1366\", ATTRS{idProduct}==\"0101\", \\ MODE:=\"0666\", \\ SYMLINK+=\"J-Link\" #【注释说明】 # idVendor: 可以在命令窗口输入 lsusb -vv 列出所有 USB 设备信息中找出 J-Link 对应的 ID 值。 # idProduct: 可以在命令窗口输入 lsusb -vv 列出所有 USB 设备信息中找出 J-Link 对应的 ID 值。 # MODE: 应该是操作限权（例如\"0666\"应该是\"可读+可写\"） # SYMLINK: 给 J-Link 这个设备取一个别名。 关于配置文件名称50-jlink.rules，前面序号越大表示优先级越小！ 关于使用lsusb -vv命令的查看方法【如图】。 更多 USB 设备权限知识，可参考网文【linux 串口绑定(别名)】和【linux 系统区分 USB 设备】 ● 第二步：将配置文件加入系统，操作如下： #####[加入配置文件]##### sudo cp 49-stlinkv* /etc/udev/rules.d/ # 将st-link所有的权限配置文件复制到linux系统（目录：stlink/config/udev/rules.d/） sudo cp 50-jlink.rules /etc/udev/rules.d/ # 将刚制作的j-link权限配置文件复制到linux系统 #####[生效配置文件]##### （备注：也可以重启电脑实现） sudo udevadm control --reload-rules # 重新加载所有权限配置文件（加载规则） sudo udevadm trigger # 接收内核发送来的设备事件（使能规则） ","date":"2022-08-08","objectID":"/20220808/:0:2","tags":["Makefile","ARM Cortex-M"],"title":"linux-STM32F开发㈡-调试器的安装与使用","uri":"/20220808/"},{"categories":["MCU","linux"],"content":"三、使用 1、使用 OpenOCD 软件下载固件 1.1、介绍：openocd 命令行 # openocd命令行格式： openocd -f \u003c下载器配置文件\u003e -f \u003c目标芯片配置文件\u003e -c \u003c执行命令\u003e # 下载固件实用指令： openocd -f interface/stlink.cfg -f target/stm32f1x.cfg -c init -c \"reset halt; wait_halt; flash write_image erase out/project.hex\" -c reset -c shutdown # 相关参数补充说明： -f interface/stlink.cfg #下载器配置文件，表示使用stlink烧录器 （配置文件完整路径：/usr/local/share/openocd/scripts/interface/stlink.cfg） -f target/stm32f1x.cfg #目标芯片配置文件，表示烧录stm32f1x单片机（配置文件完整路径：/usr/local/share/openocd/scripts/target/stm32f1x.cfg） -c init #表示烧录前初始处理器（补充说明：-c init -c halt 是很多博文给出的参数，但应用中出现第一次成功第二次失败的现象，估计 -c halt 有时失效，改为下一行加相关参数） -c \"reset halt; wait_halt; flash write_image erase out/project.hex\" #表示烧录前先复位并暂停处理器，再对flash擦除并写入十六进制文件。如果是二进制文件，其后面空格后加入地址，如: 0x08000000 -c reset #表示烧录后复位处理器 -c shutdown #表示烧录后退出openocd 1.2、准备：烧录器配置文件 ####################################################### # 由于我使用的是 jlink 仿真器，并且接口为 SWD，所以要将 # /usr/local/share/openocd/scripts/interface/jlink.cfg # 配置脚本另存为：jlink_swd.cfg，并在其里面增加两项参数： # 1、接口改为：SWD # 2、速度改为：20000KHz ####################################################### # # SEGGER J-Link # # http://www.segger.com/jlink.html # adapter driver jlink # add swd config （1、接口改为：SWD） transport select swd # add speed(KHz) config（2、速度改为：20000KHz） adapter speed 20000 # The serial number can be used to select a specific device in case more than # one is connected to the host. # # Example: Select J-Link with serial number 123456789 # # jlink serial 123456789 1.3、烧录：固件烧录操作 1.3.1、第一步： 1.3.2、第二步： ####################################################### # 由于我使用的是 jlink 仿真器，并且接口为 SWD，单片机为 # STM32F103RC，烧录文件为十六进制文件，文件所在相对路径 # 为 out/project.hex，则直接运行下面命令烧录固件： ####################################################### sudo openocd -f interface/jlink_swd.cfg -f target/stm32f1x.cfg -c init -c \"reset halt; wait_halt; flash write_image erase out/project.hex\" -c reset -c shutdown 1.3.3、最终结果： 2、使用 OpenOCD 软件仿真程序 2.1、第一步：查看 arm-none-eabi-gdb 版本 # 查看版本，用于验证其是否可正常工作 arm-none-eabi-gdb --version # CGDB（v0.8.0）要求 gdb 版本≥7.12 ############################################## # 出现问题：提示信息显示找不到 libncurses.so.5 ############################################## arm-none-eabi-gdb: error while loading shared libraries: libncurses.so.5: cannot open shared object file: No such file or directory ############################################## # 解决方法：安装所需32位依赖库 lib32ncurses5 ！ ############################################## sudo apt-get install lib32ncurses5 备注-1：启动 gdb 对 C/C++ 程序的调试，必须要在编译前就加上 -g 选项！ 备注-2：CGDB（v0.8.0）要调用 arm-none-eabi-gdb，要求 gdb 的版本必须大于等于 7.12 2.2、第二步：在命令窗口启动 OpenOCD 服务 前提条件： 输入命令： sudo openocd -f interface/jlink_swd.cfg -f target/stm32f1x.cfg # 配置文件完整路径：/usr/local/share/openocd/scripts/ 下的 interface/jlink_swd.cfg 和 target/stm32f1x.cfg 结果如下： 备注：在 Windows 系统下，j-link 的原厂应用驱动软件，也提供 GDB 对接服务，直接打开【J-Link GDB Server】可视界面操作即可！ 2.3、第三步：在另一命令窗口运行 GDB 调试 ############################################## # ①、在 shell 命令窗口运行 ############################################## # 1.1、运行 gdb arm-none-eabi-gdb ./build/gcc/rt-thread.elf ############################################## # ②、在 gdb 命令窗口运行 ############################################## # 2.0、修改 gdb 本次连接超时时间（防止openocd与仿真器速度低造成超时） set remotetimeout 60 #修改超时时间 #show remotetimeout #查看超时时间 # 2.1、连接 openocd target remote localhost:3333 # 2.2、复位并暂停处理器（monitor表示向外部服务传送命令） monitor reset halt # 2.3、下载固件（实测无需复位暂停处理器直接load也可以） load 3、使用 OpenOCD 总结 ########连接USB ######## 虚拟机/可移动设备/SEGGER J-Link/连接 ########下载固件######## sudo openocd -f interface/jlink_swd.cfg -f target/stm32f1x.cfg -c init -c \"reset halt; wait_halt; flash write_image erase out/project.hex\" -c reset -c shutdown # 备注：/usr/local/share/openocd/scripts/ 下的 interface/jlink_swd.cfg 和 target/stm32f1x.cfg #(1)####调试程序######## #【在一个命令窗口启动openocd服务】 # 备注：编译要加[-g]选项！ sudo openocd -f interface/jlink_swd.cfg -f target/stm32f1x.cfg #(2) #【在另一命令窗口启动gdb服务】 arm-none-eabi-gdb ./build/gcc/rt-thread.elf #（也可先运行命令 arm-none-eabi-gdb 进入gdb后再运行命令 file ./build/gcc/rt-thread.elf 装载调试文件） set remotetimeout 60 # 在gdb里:","date":"2022-08-08","objectID":"/20220808/:0:3","tags":["Makefile","ARM Cortex-M"],"title":"linux-STM32F开发㈡-调试器的安装与使用","uri":"/20220808/"},{"categories":["MCU","linux"],"content":"三、扩展 1、IDE 集成开发环境的组成 组件 说明 代码编辑工具 IDE 直接使用 QScitinal 这类的编辑器库 代码智能提示 IDE 后台调用 clang 工具 语法错误检测 IDE 后台调用 gcc 或者 clang 对代码语法错误动态检测 工程文件组织 IDE 使用的是 makefile，后台调用 make 工具 编译 IDE 后台调用 gcc 或者 clang 编译器编译 调试器 IDE 后台调用 OpenOCD 连接调试器和板子 下载 IDE 后台调用 OpenOCD 命令下载固件 调试 IDE 后台调用 gdb，给 gdb 发命令，gdb 再给 OpenOCD 发命令，OpenOCD 再指挥调试器控制板子。实现单步执行，查看变量值，寄存器等 2、CGDB/GDB 应用及命令知识 《linux-调试-linux 调试仿真工具》 ","date":"2022-08-08","objectID":"/20220808/:0:4","tags":["Makefile","ARM Cortex-M"],"title":"linux-STM32F开发㈡-调试器的安装与使用","uri":"/20220808/"},{"categories":["MCU","linux"],"content":"linux-STM32F开发㈠-makefile 构建与使用","date":"2022-08-04","objectID":"/20220804/","tags":["Makefile","ARM Cortex-M","STM32CubeMX"],"title":"linux-STM32F开发㈠-makefile 构建与使用","uri":"/20220804/"},{"categories":["MCU","linux"],"content":"一、前言 在 Windows 下有完善的 IDE（集成开发环境）开发工具，开发单片机程序变得简单和傻瓜化，图形界面上所见所得操作，基本不需要我们了解一些专业知识。正是 IDE 太过完善了，导致我们忽略一些技术知识，限制我们技术的提升。如果想进一步提升专业知识，必须要学会在 linux 下开发，本篇文章主要介绍 STM32F 项目工程使用 Makefile 构建、配置、编译。 如果你不熟悉 linux 和 Makefile，建议认真学习下面文章： 《linux-系统-Ubuntu 系统与工具》 《linux-命令-linux 基本命令使用》 《linux-编译-linux 编译构建工具》 ","date":"2022-08-04","objectID":"/20220804/:0:1","tags":["Makefile","ARM Cortex-M","STM32CubeMX"],"title":"linux-STM32F开发㈠-makefile 构建与使用","uri":"/20220804/"},{"categories":["MCU","linux"],"content":"二、构建 1、使用【STM32CubeMX】构建操作 ● 使用【STM32CubeMX】构建一个 demo 工程，在《STM32CubeMX 基本使用》中的第三节【STM32CubeMX 使用】已非常详细介绍了，这里不再赘述！不同的是最后一步设置生成工程时选择【Makefile】选项，如图： 2、使用自己的【Makefile】构建操作 ● 使用自己的 Makefile 构建（本人有自己风格的 Makefile 模板，并且可以对特定模块定制编译参数）。首先参照《STM32CubeMX 基本使用》中的第三节【STM32CubeMX 使用】方法构建一个基本工程，然后使用本人风格 Makefile 模板嵌入工程。至于具体如何编写 Makefile 请参考《linux-编译-linux 编译构建工具》中的【三、make+Makefile 脚本】章节。本节 demo 工程请到仓库中的【4_stm32f1xx】直接下载。将 Makefile 模板几个文件嵌入到软件工程操作方法，如图： 补充：嵌入式处理器需要专用的交叉编译器和编译参数，会多一个启动文件（汇编）和 一个链接器文件（脚本），生成依赖信息的方法也不同，这些主要涉及 [makeenvi.mk] 和 [makecore.mk] 两个文件，具体请查阅仓库里的【4_stm32f1xx】demo 工程。至于具体参数表示何意，以及如何加入源文件、如何修改编译参数，下面章节将会详细介绍。同时建议你使用代码比较工具比较【4_stm32f1xx】与【3_large】这两个工程中的makeenvi.mk makecore.mk及三个Makefile文件的差异，直观了解 PC 纯软件 Makefile 与 嵌入式 Makefile 的差异！ 3、关于【STM32F】嵌入式构建特点 一、相比 PC 纯软件工程构建，嵌入式工程构建会多一个启动文件（汇编）和 一个链接器文件（脚本），并且不同处理器需要使用不同启动文件及链接脚本文件（一般都是厂家提供的）。 文件 说明 startup_stm32f103xb.s 处理器启动文件（汇编） STM32F103XB_FLASH.ld 链接器链接文件（脚本） 备注：这两个文件来源: HAL库\\CMSIS\\Device\\ST\\STM32F1xx\\Source\\Templates\\gcc\\。关于【HAL 库】请到【STM32CubeMX】库文件管理目录里提取，一般路径为：C:\\Users\\Administrator\\STM32Cube\\Repository\\。 二、嵌入式编译器主要生成的文件： 文件 说明 .elf 可执行与可链接格式文件（★业界标准文件★），包含了全部的编译链接信息和程序执行数据 .lst 是使用 objdump 反汇编 elf 文件得到的输出文件，它拥有比 map 文件更详细的信息 .map 源代码被工具链构建之后的详细信息，包括固件大小、函数符号、内存映射等 .hex 基于文本描述的 Intel 标准的十六进制数据，用于烧录固件 .bin 纯二进制数据，用于烧录固件 备注：从存储数据的信息量上看：ELF\u003eAXF\u003eHEX\u003eBIN，所以可以将大信息量的文件格式向小信息量的文件格式转换。如：ELF 可以转换为 AXF、HEX、BIN。其中 HEX 文件可转换为 BIN 文件；如果指定了数据起始地址，也可以将 BIN 转换为 HEX 文件。 三、嵌入式编译器有自己独特的选项参数： 选项 说明 -mcpu=cortex-m3 编译/链接：处理器内核架构 -mthumb 编译/链接：指令集架构 -mfpu=fpv4-sp-d16 编译/链接：浮点运算单元（F4系列才有） -Wa,-a,-ad,-alms=xxx.lst 编译：生成 lst 文件，它拥有比 map 文件更详细的信息（-Wa,表示将编译器参数传给汇编器） -MMD -MP -MF\"xxx.d\" 编译：生成 d 文件，它是源文件包含文件的依赖信息 -Dxxx 编译：加入工程全局宏定义，可多个 -Dxxx 全局宏定义 -g -gdwarf-2 编译：生成 gdb 调试信息 格式为[dward-2] -fdata-sections 编译：对每个数据创建一个 section（section 是 GCC 的最小链接单元） -ffunction-sections 编译：对每个函数创建一个 section（section 是 GCC 的最小链接单元） -Wl,--gc-sections 链接：特别不链接未使用的 section（函数/数据），从而减小执行文件大小（-Wl,表示将编译器参数传给链接器） -Wl,-print-gc-sections 链接：打印链接器优化掉的 section（函数/数据），方便程序员查优化问题（-Wl,表示将编译器参数传给链接器） -Wl,-Map=xxx.map,--cref 链接：打印链接表信息到[xxx.map]文件，--cref 表示输出一个交叉引用表（-Wl,表示将编译器参数传给链接器） -Txxx.ld 链接：使用[xxx.ld]脚本文件作为链接器脚本 -specs=nano.specs 链接：替换精简 C 库以缩小代码大小 -lc -lm -lnosys 链接：标准C库（C lib）、数学库（math）、nosys 库 参数示范如下： # 链接 build/zzz.elf: build/xxx.o build/yyy.o build/bbb.a arm-none-eabi-gcc -mcpu=cortex-m3 -mthumb \\ -T./STM32F103CBTx_FLASH.ld \\ -specs=nano.specs \\ -Wl,--gc-sections \\ -Wl,-Map=build/zzz.map,--cref \\ -o build/zzz.elf \\ build/xxx.o build/yyy.o build/bbb.a -lc -lm -lnosys # 编译-源文件（多了 lst 生成） %.o: %.c arm-none-eabi-gcc -c -mcpu=cortex-m3 -mthumb \\ -g -gdwarf-2 -Wall -Og -fdata-sections -ffunction-sections \\ -DUSE_HAL_DRIVER -DSTM32F103xB -I./inc/ \\ -MMD -MP -MF\"build/xxx.d\" \\ -Wa,-a,-ad,-alms=build/xxx.lst \\ xxxx/xxx.c -o build/xxx.o # 编译-汇编文件（少了 lst 生成） %.o: %.s arm-none-eabi-gcc -x assembler-with-cpp \\ -c -mcpu=cortex-m3 -mthumb \\ -g -gdwarf-2 -Wall -Og -fdata-sections -ffunction-sections \\ -DUSE_HAL_DRIVER -DSTM32F103xB -I./inc/ \\ -MMD -MP -MF\"build/yyy.d\" \\ ./yyy.s -o build/yyy.o 备注：这些参数主要涉及 [makeenvi.mk] 和 [makecore.mk] 两个文件，具体请查看【4_stm32f1xx】demo 工程。 ","date":"2022-08-04","objectID":"/20220804/:0:2","tags":["Makefile","ARM Cortex-M","STM32CubeMX"],"title":"linux-STM32F开发㈠-makefile 构建与使用","uri":"/20220804/"},{"categories":["MCU","linux"],"content":"三、使用 1、基于【STM32CubeMX】构建的使用 一、在实际的工程应用中，必定要加入自己的源代码文件和配置相关参数。下面为通过与 Keil MDK 的比较，让你快速了解 Makefile 的相关配置，如图： 二、使用 Makefile 编译工程： #################################################### # 在[shell]中进入[Makefile]所在的目录，输入命令执行： #################################################### cd x_stm32f1xx # 进入操作目录 make all # 执行编译操作（如果想重新全编译，先执行下面命令） make clean # 执行清除操作（清除所有编译出的文件，包括 hex 等） 2、基于自己的【Makefile】构建的使用 一、在实际的工程应用中，必定要加入自己的源代码文件和配置相关参数。下面为通过与 Keil MDK 的比较，让你快速了解 Makefile 的相关配置，如图： 备注：以上主要涉及一个父 Makefile（配置工程及子 Makefile 文件所在目录），一个子 Makefile（统一设置编译文件、包含路径等），n 个子 Makefile（定制模块编译文件、编译参数等）。 二、使用 Makefile 编译工程： #################################################### # 在[shell]中进入[makecore.mk]所在的目录，输入命令执行： #################################################### cd 4_stm32f1xx # 进入操作目录 make clean # 执行清除操作（同时创建所需文件夹） make all # 执行编译操作（清除操作之后会重新全编译） ","date":"2022-08-04","objectID":"/20220804/:0:3","tags":["Makefile","ARM Cortex-M","STM32CubeMX"],"title":"linux-STM32F开发㈠-makefile 构建与使用","uri":"/20220804/"},{"categories":["MCU","linux"],"content":"四、提升 1、各种编译器的识别宏 1.1、用于在程序里识别不同编译器，通过这些宏可以使用编译器各自特性来编译相关代码： // 1、MDK-ARM 使用编译器的宏名称（ARM RealView） #if defined(__CC_ARM) || defined(__CLANG_ARM) // 2、IAR-ARM 使用编译器的宏名称（IAR EWARM） #elif defined(__ICCARM__) // 3、GNU-gcc 使用编译器的宏名称（GNU Compiler Collection） #elif defined(__GNUC__) #endif 1.2、ARM 主流编译器：armcc、clang、iccarm、gcc 等，具体请参考下面网文： ARM 主流编译器介绍 2、gcc 链接脚本基本知识 2.1、默认链接脚本的导出： gcc 编译器都会有默认的链接脚本，当你需要定制链接脚本时（编译时指定链接脚本的选项参数为-T，用法如：-Txxx.ld。在嵌入式应用领域，厂家一般会提供针对其处理器定制的链接脚本，无需我们自己重新编写！），通过命令可以直接导出默认链接脚本： # 1、PC 的 gcc 默认链接脚本导出方法： ld --verbose \u003e my_pc.ld # 2、ARM 的 gcc 默认链接脚本导出方法： arm-none-eabi-ld --verbose \u003e my_arm.ld # 特别备注： # 1）导出的默认链接脚本中，“=====”及前面的文字只是说明信息，首先要把它们删除！ # 2）如果你想保留这些说明信息，可以使用 /**/ 注释符把它们注释掉。 2.2、链接脚本常见关键字： gcc 编译器的链接脚本常用关键字及语法需要我们有所了解，特别是在嵌入式应用领域，需要配置 ROM（FLASH）、RAM 的大小，上电运行第一段代码（函数）等，这些都是通过链接脚本来实现的。 ############################################ # 1、`ENTRY`定义上电运行的第一段代码（函数） ############################################ ENTRY(Reset_Handler) /* 表示上电运行的第一段代码（函数）: Reset_Handler */ ############################################ # 2、`MEMORY`定义储存空间（起始地址及大小） ############################################ MEMORY { RAM (xrw) : ORIGIN = 0x20000000, LENGTH = 20K /* x:执行，r:可读，w:可写 */ FLASH (rx) : ORIGIN = 0x8000000, LENGTH = 128K /* ORIGIN:起始地址，LENGTH:大小 */ } ############################################ # 3、`SECTIONS`定义一些段的链接分布，例如： # text、data、bss 等段。 ############################################ SECTIONS { .text : { . = ALIGN(4); *(.text) *(.text*) } \u003eFLASH .data : { …… } \u003eRAM AT\u003e FLASH .bss : { _sbss = .; /* bss 段开始地址 */ …… _ebss = .; /* bss 段结束地址 */ } \u003eRAM …… } ############################################ # 4、`.`表示当前地址值 ############################################ . = ALIGN(4); /* 表示将当前开始地址强制 4 字节对齐 */ _sdata = .; /* 表示将当前地址值传给[_sdata]变量 */ ############################################ # 5、`KEEP`防止段(sections)的内容不被优化掉， # 因为 -Wl,--gc-sections 链接参数可能会强制 # 优化掉__attribute__((section(\"xxx\")) 定义 # 的 xxx 数据段！ ############################################ __fsymtab_start = .; KEEP(*(FSymTab)) /* 国产 rt-thread 实时操作系统中为其 shell 定义一段专用只读数据段 */ __fsymtab_end = .; __hard_init_fn_start = .; KEEP(*(SORT(.hard_init_fn.*))) /* 本人做的专用硬件初始化的分段列表，SORT()表示对小分段进行递增排序 */ __hard_init_fn_end = .; ############################################################################## # 6、LMA (load memory address)： 加载地址，也就是所有程序和数据储存空间位置。 # VMA (vortual memory address)：执行地址，如将 Flash 数据加载至 RAM 上运行。 # 对于单片机应用，一般不用设置 VMA，也就是说“载入地址”与“运行地址”是同一地址上！ # 也就是说单片机程序是在 flash 里运行，则运行地址和加载地址是相同的。 ############################################################################## ############################################################################## # 7、输入段、输出段 # 输出段：是指生成的文件，例如 elf 中的每个段。 # 输入段：是指提供链接的所有目标文件(OBJ)中的段。 ############################################################################## 更多知识请参考网文：《gcc ld 链接脚语法简明讲解》和《Linker Script 链接脚本说明》 3、关于 text、data、bss、heap、stack 的分布 3.1、数据段大小含义： 类型 说明 text 代码（Code）和常量（RO-Data）的大小（ROM） data 【已初始化】的全局变量（global）和静态变量（static）的大小（RAM/ROM） bss 【未初始化】的全局变量（global）和静态变量（static）的大小（RAM)。 其初始值一般默认默认为零！从 STM32F103 官方的 .ld 链接文件生成的 .map 文件查到，其包括：heap（堆）和 stack （栈）的大小！ dec text + data + bss 的总和值（十进制表示） hex text + data + bss 的总和值（十六进制表示） 补充 1、程序固件大小（ROM）：text + data 2、程序已用内存（RAM）：data + bss（包括：heap 和 stack 的大小） RAM 堆栈 地址分布 说明 （1）堆区（heap） 在中地址 一般由程序员分配和释放，若程序员不释放，程序结束时可能由操作系统回收。分配方式类似于数据结构中的链表。通过malloc函数申请，通过free函数释放！堆：向高地址扩展！ （2）栈区（stack） 在高地址 由编译器自动分配和释放，存放函数的参数值、局部变量的值等，其操作方式类似于数据结构中的栈。函数调用及函数退出时自动处理！栈：向低地址扩展！ 3.2、各段数据段分布： 3.3、数据段大小获取： // 在 C 语言中，通过如下方式获取某个分段 // 的起始与结束地址，再由计算可得出大小。 // 具体变量名称在链接脚本中找出！！！！！ extern int _sbss; extern int _ebss; #define LINKER_VAR_ZI_START ((void *)\u0026_sbss) #define LINKER_VAR_ZI_LIMIT ((void *)\u0026_ebss) #define LINKER_VAR_ZI_SIZE (((void *)\u0026_ebss) - ((void *)\u0026_sbss)) 3.4、数据段空间不足： # 当数据段空间不足时，编译时一般有如下错误信息： xxxx.elf section '.xxx' will not fit in region 'FLASH' # 表示'FLASH'空间不足，装不下'.xxx'分段数据！ 4、关于 Keil 获取 ROM、RAM 编译大小的方法 《获取 ARM 编译后的 ROM 及 RAM 大小方法及原理》 5、使用自己的【Makefile】构建 rt-thread 工程 5.1、基本构建与使用： 从【4_stm32f1xx】提取 makeenvi.mk、makecore.mk、Makef","date":"2022-08-04","objectID":"/20220804/:0:4","tags":["Makefile","ARM Cortex-M","STM32CubeMX"],"title":"linux-STM32F开发㈠-makefile 构建与使用","uri":"/20220804/"},{"categories":["MCU","linux"],"content":"五、插曲 1、Windows 系统下编译出错 ● 差异表现： 在 linux 编译成功，但在 Windows 编译出错！ ● 运行环境： 在 Windows 系统 +【TDM-GCC】的 make 工具（注：make 命令名为mingw32-make）+【arm-none-eabi-gcc】交叉编译器 +【git】命令窗口（其集成 linux 基本命令工具）运行 Makefile。 ● 出现问题： ■ 问题一： opening dependency file D:D:/Program Files (x86)/Git/Downloads/tmp/4_stm32f1xx/build/delay.d: Invalid argument错误，一个很奇怪的问题，从提示信息中可以看到 git 的路径硬生生插入到依赖文件的路径中！经过查找，发现是由-MMD -MP -MF\"$(@:%.o=%.d)\"参数引起。这组参数是我参考【STM32CubeMX】生成的 Makefile 加入的，它是指在编译过程中同时生成依赖信息文件。我写的 Makefile 操作路径都使用了【绝对路径】，当我把这个参数强行改为【相对路径】-MMD -MP -MF\"../../build/$(notdir $(@:%.o=%.d))\"进行测试，竟然编译成功了。在 Windows 下-MF为什么不支持【绝对路径】，本人还没找出原因！ ◆ 解决方法一： 按老方法使用-MM参数生成依赖信息文件，避开使用-MF引发问题！但因每编译一个文件会多运行一次 gcc 和调用一次 sed 处理文本，效率会低很多！ ◆ 解决方法二： 调整 Makefile 机制，全部改为使用【相对路径】，于 2022-08-10 已更新全部 demo 工程！ ■ 问题二： ../user/key/key.c:12:99: fatal error: app_cfg.h: No such file or directory错误。其实在此子 Makefile 的编译指令已加-I ./指出包含头文件所在目录，但gcc编译还是找不到头文件，不明白原因！ ◆ 解决方法： 在此子 Makefile 所在目录-I ./基础上再增加指出上级目录名称，例如上级目录名为《applications》，则增加-I ../applications ","date":"2022-08-04","objectID":"/20220804/:0:5","tags":["Makefile","ARM Cortex-M","STM32CubeMX"],"title":"linux-STM32F开发㈠-makefile 构建与使用","uri":"/20220804/"},{"categories":["other"],"content":"我的社保缴纳情况","date":"2022-07-07","objectID":"/20220707/","tags":["其它"],"title":"我的社保缴纳情况","uri":"/20220707/"},{"categories":["other"],"content":"内容 前段时间公司收集员工的社保缴纳累计年/月情况，并把研发中心所有员工的社保缴纳情况汇总下发到群里，让员工自行校对。打开 Execl 文档，排序列表，看到交社保累计最多的一位同事有 265 个月。嗯嗯，老同志，应该是专家级的工程师。再往下看了一下，我竟然排到第 5 位（缴纳累计接近 200 个月），是整个研发中心的第五！惊奇，原来我交了这么多年了！惊讶，原来我这么“老”了！失望，工作了这么多年还是碌碌无为！突然想起了抖音经常听到的那首背景音乐“我还是曾经那个少年，没有一丝丝改变，时间只不过是考验，种在心中信念丝毫未减”，虽然这两年来工作上的不顺利，或许能力不及你，但永不言败！借用小学生都爱唱的神曲《孤勇者》歌词来表达我此刻的心情：“战吗？战啊！以最卑微的梦，以最孤高的梦，致那黑夜中的呜咽与怒吼！谁说站在光里的才算英雄！” ","date":"2022-07-07","objectID":"/20220707/:0:1","tags":["其它"],"title":"我的社保缴纳情况","uri":"/20220707/"},{"categories":["software","linux"],"content":"正则表达式语法的基本介绍","date":"2022-05-27","objectID":"/20220527/","tags":["正则表达式"],"title":"正则表达式","uri":"/20220527/"},{"categories":["software","linux"],"content":"一、简介 正则表达式（Regular Expression /'reɡjələr/ɪk'spreʃn/）是一种文本匹配模式，其使用一组由字母和符号组成的特殊文本来描述用户自定义规则的字符串，用于查找或替换满足你想要格式的文本。许多程序设计语言和脚本语言都支持利用正则表达式进行字符串操作（例如：C# 编程语言、python 脚本语言），以及很多专业文本编辑软件都支持利用正则表达式进行文本查找替换操作（例如：Notepad++ 代码编辑软件、Meld 代码比较工具）。注意：因为正则表达式并不仅限于某一种语言/软件，所以在每种语言中都会有细微的差别。 ","date":"2022-05-27","objectID":"/20220527/:0:1","tags":["正则表达式"],"title":"正则表达式","uri":"/20220527/"},{"categories":["software","linux"],"content":"二、语法 1、额外的标记符 标记也称为修饰符，正则表达式的标记用于指定额外的匹配策略，可以理解为微调全局匹配规则。 例如：i表示将匹配更改为不区分大小写。 语法：/相关匹配表达式/额外标记 实例：/[a-z]+/ig 额外标记 描述 i ignore —— 忽略大小写，将匹配更改为不区分大小写。 g global —— 全局匹配，表示查找所有匹配项。 m multi line – 多行匹配，使边界字符 ^ 和 $ 匹配更改为每一行的开头和结尾，而不是整段字符串的开头和结尾。 s 将.的匹配更改为包含换行符（\\n）。 2、语法与特殊符 2.1、在普通的字符中，存在隐性的控制符，例如 Tab 符和回车符等，这些字符需要转义才能表达出来。 控制类-特殊字符 描述 \\cX 表达一个由 X 指明的控制字符。例如：\\cM 表达一个回车符。X 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的 ‘c’ 字符。 \\t 表示一个　制表符。等价于 \\x09 或 \\cI。 \\n 表示一个　换行符。等价于 \\x0a 或 \\cJ。 \\v 表示一个垂直制表符。等价于 \\x0b 或 \\cK。 \\f 表示一个　换页符。等价于 \\x0c 或 \\cL。 \\r 表示一个　回车符。等价于 \\x0d 或 \\cM。 2.2、匹配语法中，使用了十几个特殊符号来表达匹配规则。当需要显示符号本身时需要转义来呈现。 匹配类-特殊字符 描述 \\\\ \\/ \\| \\( \\) \\[ \\] \\{ \\} \\* \\+ \\? \\. \\^ \\$ 字符转义：匹配中一些特殊字符需要用\\转义来显示符号本身，主要包括 15 个特殊字符：\\ | / ( ) [ ] { } * + ? . ^ $ ，其中 ] } 两个符号可以不用\\转义。 \\ 转义字符：将字符转义为特殊字符、或八进制转义符等等。 | 匹配或项：为或运算符，两项表达式中只要有一项匹配即表示符合规则。 ( ) 匹配捕获：在匹配获得的字符串中，捕获 ( ) 内规则内容放到缓存，简称捕获物/集合，可以有多个捕获物，最多 99 个（例如：([0-1][2-3])abc([4-5][6-9])f\\1g 其中 \\1 表示第一个捕获物为([0-1][2-3])整体克隆，如果有 \\2 则表示为第二个捕获物为([4-5][6-9])整体克隆，字符串13abc59f13g就符合前面语法匹配）。注：(?xxx) 语句不是捕获物。 [ ] 匹配字集：与自定义字符集其中一个字符匹配。例如 [0-9] 表示与数字匹配，[^0-9] 表示与非数字匹配。 { } 匹配次数：限制其左边一个字符或一个捕获物的匹配次数为用户指定。例如 [0-9]{3}、[0-9]{3,}、[0-9]{3,5} 分别表示匹配 3 个、n～3 个、5～3 个数字，如果后面加一个?修饰则 [0-9]{3,5}? 表示匹配 3～5 个数字。 * 匹配次数：限制其左边一个字符或一个捕获物的匹配次数为n～0，如果后加多一个?修饰则表示匹配次数为0～n。 + 匹配次数：限制其左边一个字符或一个捕获物的匹配次数为n～1，如果后加多一个?修饰则表示匹配次数为1～n。 ? 匹配次数：限制其左边一个字符或一个捕获物的匹配次数为1～0，如果后加多一个?修饰则表示匹配次数为0～1。备注①：使用?修饰的特殊符号有?、+、*、{,}，表示『次数』变为少～多匹配！备注②：(?xxx) 语句表示匹配位置等。 . 匹配字集：与除换行符 ‘\\n’ 之外的任何单字符匹配。备注：个人认为应该是只包括空格、Tab格、及可见字符的任一单字符！ ^ 匹配位置：匹配输入字符串的开头位置。例如 ^[0-9]+ 表示整体以数字开始。如果在 [ ] 里面使用，则表示在 ^ 右边的字符集除外的其它字符集。 $ 匹配位置：匹配输入字符串的结尾位置。例如 [0-9]+$ 表示整体以数字结束。如果设置了 RegExp 对象的 Multiline 属性，则 $ 同时匹配 ‘\\n’ 或 ‘\\r’，即视一行作为一整体。 (?:X) 匹配集合：由于规则有优先级，特别是匹配或项 “|” 的使用，使用匹配集合有效解决组合问题。例如 Version_(?:Alpha|Beta) 表示匹配 Version_Alpha 或 Version_Beta 两个字段。 (?\u003c=X) 和 (?=X) 匹配位置：匹配符合 X 表达式(真条件)的相对开始位置、相对结尾位置，类同 ^ 和 $。例如 (?\u003c=[0-9]+)[a-z]+、[a-z]+(?=[0-9]+) 分别表示匹配以数字开始、以数字结束的文本位置上。 (?\u003c!X) 和 (?!X) 匹配位置：匹配符合 非X 表达式(假条件)的相对开始位置、相对结尾位置，类同 ^ 和 $。例如 (?\u003c![0-9]+)[a-z]+、[a-z]+(?![0-9]+) 分别匹配表示以非数字开始、以非数字结束的文本位置上。 \\b 匹配位置：匹配一个单词边界位置，即字与空格间的位置。而大写 \\B 表示“非”。 \\d 匹配字集：与数字匹配，即 [0-9]。而大写 \\D 表示“非”，即 [^0-9]。 \\w 匹配字集：与任何的字母、数字、下划线匹配，即 [a-zA-Z0-9_]。而大写 \\W 表示“非”，即 [^a-zA-Z0-9_]。 \\s 匹配字集：与任何的空白字符匹配，即 [ \\t\\n\\v\\f\\r]。而大写 \\S 表示“非”，即 [^ \\t\\n\\v\\f\\r]。注意：包括空格。注意 Unicode 正则表达式会匹配全角空格符。 3、语法的优先级 运算符 描述 \\ 转义符 ()、(?:)、(?=)、(?!)、[] 括号符 *、+、?、{n}、{n,}、{n,m} 限定符 ^、$ 定位符 | 或项符 4、语法案例图解 在【菜鸟教程-正则表达式】网页中嵌入的【测试工具】非常形象展示正则表达式的语法匹配，利用它加快我们理解正则表达式的语法。 匹配符 展示 ( ) ◆①【n~1 位相邻相同数字】匹配： [ ] ◆①【1 位数字 + 1 位字母】匹配： { } ◆①【3 位数字 + 3 位字母】匹配： ◆②【n~3 位数字 + n~3 位字母】匹配： ◆③【3~n 位数字 + 3~n 位字母】匹配： ◆④【4~3 位数字 + 4~3 位字母】匹配： * ◆①【n~0 位数字 + n~0 位字母】匹配： ◆②【0~n 位数字 + 0~n 位字母】匹配： ◆③【0~n 位数字 + n~0 位字母】匹配： ◆④【0~n 位数字 + “abc\"字母】匹配： + ◆①【n~1 位数字 + n~1 位字母】匹配： ◆②【1~n 位数字 + 1~n 位字母】匹配： ? ◆①【1~0 位数字 + 1~0 位字母】匹配： ◆②【0~1 位数字 + 0~1 位字母】匹配： ◆③【1~0 位数字 + “hi\"字母】匹配： . ◆①【1 位字符 + “hi\"字母】匹配： ◆②【n~1 位字符 + “hi\"字母】匹配： ^ ◆①【整段字符前 10 个字符】匹配： ◆②【每行字符前 10 个字符】匹配： ◆③【整行为大写字符】匹配： $ ◆①【整段字符后 10 个字符】匹配： ◆②【每行字符后 10 个字符】匹配： ◆③【整行为日期字符】匹配： (?:X) ◆①【“23\"或\"78\"数字 + n~1 位字母】匹配： (?\u003c=X)　(?=X) ◆①【在\"23\"数字后面的 n~1 位字母】匹配： ◆②【在\"55\"数字前面的 n~1 位字母】匹配： (?\u003c!X)　(?!X) ◆①【在非\"78\"后面的 n~1 位字母】匹配： ◆②【在非\"55\"前面的 n~1 位字母】匹配： \\b ◆①【在单词边界后面的 n~1 位字母】匹配： ◆②【在非单词边界后面的 n~1 位字母】匹配： \\d ◆①【n~1 位数字】匹配： ◆②【n~1 位非数字】匹配： ","date":"2022-05-27","objectID":"/20220527/:0:2","tags":["正则表达式"],"title":"正则表达式","uri":"/20220527/"},{"categories":["software","linux"],"content":"三、应用 1、应用软件 只要有文本查找、替换操作，都有可能使用到正则表达式，它们包括文本编辑软件、脚本、编程语言。下面列出相关应用软件对正则表达式的支持度： 软件/语言 . [ ] ^ $ \\( \\) \\{ \\} ? + | ( ) vi √ √ √ √ √ sed √ √ √ √ √ √ awk √ √ √ √ √ √ √ √ √ perl √ √ √ √ √ √ √ √ √ python √ √ √ √ √ √ √ √ √ √ javascript √ √ √ √ √ √ √ √ √ Visual C++ √ √ √ √ √ C# √ √ √ √ √ √ √ √ delphi √ √ √ √ √ √ √ √ √ java √ √ √ √ √ √ √ √ √ √ php √ √ √ √ √ 备注： 正则表达式的( )和{ }匹配字符，为何上表写成\\( \\)和\\{ \\}呢？那是因为相关软件所在工作环境影响，例如：在 shell 命令窗口执行时，大部分符号为 shell 的普通字符，所以只能反过来使用\\转义表示！同时，不排除其它符号也是如此！正则表达式并不仅限于某一种语言/软件，在每种语言中会都有细微的差别。 2、应用实例 网上早已收集一些常用正则表达式，这就无需我们重复编写了，劳烦你动一下左手的两根手指Ctrl+C和Ctrl+V。^0^ 。 一、校验数字的表达式 数字：^[0-9]*$ n位的数字：^\\d{n}$ 至少n位的数字：^\\d{n,}$ m-n位的数字：^\\d{m,n}$ 零和非零开头的数字：^(0|[1-9][0-9]*)$ 非零开头的最多带两位小数的数字：^([1-9][0-9]*)+(\\.[0-9]{1,2})?$ 带1-2位小数的正数或负数：^(\\-)?\\d+(\\.\\d{1,2})$ 正数、负数、和小数：^(\\-|\\+)?\\d+(\\.\\d+)?$ 有两位小数的正实数：^[0-9]+(\\.[0-9]{2})?$ 有1~3位小数的正实数：^[0-9]+(\\.[0-9]{1,3})?$ 非零的正整数：^[1-9]\\d*$ 或 ^([1-9][0-9]*){1,3}$ 或 ^\\+?[1-9][0-9]*$ 非零的负整数：^\\-[1-9][]0-9”*$ 或 ^-[1-9]\\d*$ 非负整数：^\\d+$ 或 ^[1-9]\\d*|0$ 非正整数：^-[1-9]\\d*|0$ 或 ^((-\\d+)|(0+))$ 非负浮点数：^\\d+(\\.\\d+)?$ 或 ^[1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*|0?\\.0+|0$ 非正浮点数：^((-\\d+(\\.\\d+)?)|(0+(\\.0+)?))$ 或 ^(-([1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*))|0?\\.0+|0$ 正浮点数：^[1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*$ 或 ^(([0-9]+\\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\\.[0-9]+)|([0-9]*[1-9][0-9]*))$ 负浮点数：^-([1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*)$ 或 ^(-(([0-9]+\\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\\.[0-9]+)|([0-9]*[1-9][0-9]*)))$ 浮点数：^(-?\\d+)(\\.\\d+)?$ 或 ^-?([1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*|0?\\.0+|0)$ 二、校验字符的表达式 汉字：^[\\u4e00-\\u9fa5]{0,}$ 英文和数字：^[A-Za-z0-9]+$ 或 ^[A-Za-z0-9]{4,40}$ 长度为3-20的所有字符：^.{3,20}$ 由26个英文字母组成的字符串：^[A-Za-z]+$ 由26个大写英文字母组成的字符串：^[A-Z]+$ 由26个小写英文字母组成的字符串：^[a-z]+$ 由数字和26个英文字母组成的字符串：^[A-Za-z0-9]+$ 由数字、26个英文字母或者下划线组成的字符串：^\\w+$ 或 ^\\w{3,20}$ 中文、英文、数字包括下划线：^[\\u4E00-\\u9FA5A-Za-z0-9_]+$ 中文、英文、数字但不包括下划线等符号：^[\\u4E00-\\u9FA5A-Za-z0-9]+$ 或 ^[\\u4E00-\\u9FA5A-Za-z0-9]{2,20}$ 可以输入含有^%\u0026',;=?$\\“等字符：[^%\u0026',;=?$\\x22]+ 禁止输入含有~的字符：[^~]+ 三、特殊需求表达式 Email地址：^\\w+([-+.]\\w+)*@\\w+([-.]\\w+)*\\.\\w+([-.]\\w+)*$ 域名：[a-zA-Z0-9][-a-zA-Z0-9]{0,62}(\\.[a-zA-Z0-9][-a-zA-Z0-9]{0,62})+\\.? InternetURL：[a-zA-z]+://[^\\s]* 或 ^http://([\\w-]+\\.)+[\\w-]+(/[\\w-./?%\u0026=]*)?$ 手机号码：^(13[0-9]|14[01456879]|15[0-35-9]|16[2567]|17[0-8]|18[0-9]|19[0-35-9])\\d{8}$ 电话号码(“XXX-XXXXXXX”、“XXXX-XXXXXXXX”、“XXX-XXXXXXX”、“XXX-XXXXXXXX”、“XXXXXXX\"和\"XXXXXXXX)：^(\\(\\d{3,4}-)|\\d{3.4}-)?\\d{7,8}$ 国内电话号码(0511-4405222、021-87888822)：\\d{3}-\\d{8}|\\d{4}-\\d{7} 电话号码正则表达式（支持手机号码，3-4位区号，7-8位直播号码，1－4位分机号）: ((\\d{11})|^((\\d{7,8})|(\\d{4}|\\d{3})-(\\d{7,8})|(\\d{4}|\\d{3})-(\\d{7,8})-(\\d{4}|\\d{3}|\\d{2}|\\d{1})|(\\d{7,8})-(\\d{4}|\\d{3}|\\d{2}|\\d{1}))$) 身份证号(15位、18位数字)，最后一位是校验位，可能为数字或字符X：(^\\d{15}$)|(^\\d{18}$)|(^\\d{17}(\\d|X|x)$) 帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9_]{4,15}$ 密码(以字母开头，长度在6~18之间，只能包含字母、数字和下划线)：^[a-zA-Z]\\w{5,17}$ 强密码(必须包含大小写字母和数字的组合，不能使用特殊字符，长度在 8-10 之间)：^(?=.*\\d)(?=.*[a-z])(?=.*[A-Z])[a-zA-Z0-9]{8,10}$ 强密码(必须包含大小写字母和数字的组合，可以使用特殊字符，长度在8-10之间)：^(?=.*\\d)(?=.*[a-z])(?=.*[A-Z]).{8,10}$ 日期格式：^\\d{4}-\\d{1,2}-\\d{1,2} 一年的12个月(01～09和1～12)：^(0?[1-9]|1[0-2])$ 一个月的31天(01～09和1～31)：^((0?[1-9])|((1|2)[0-9])|30|31)$ 钱的输入格式： 有四种钱的表示形式我们可以接受:“10000.00” 和 “10,000.00”, 和没有 “分” 的 “10000” 和 “10,000”：^[1-9][0-9]*$ 这表示任意一个不以0开头的数字,但是,这也意味着一个字符\"0\"不通过,所以我们采用下面的形式：^(0|[1-9][0-9]*)$ 一个0或者一个不以0开头的数字.我们还可以允许开头有一个负号：^(0|-?[1-9][0-9]*)$ 这表示一个0或者一个可能为负的开头不为0的数字.让用户以0开头好了.把负号的也去掉,因为钱总不能是负的吧。下面我们要加的是说明可能的小数部分：^[0-9]+(.[0-9]+)?$ 必须说明的是,小数点后面至少应该有1位数,所以\"10.“是不通过的,但是 “10” 和 “10.2” 是通过的：^[0-9]+(.[0-9]{2})?$ 这样我们规定小数点后面必须有两位,如果你认为太苛刻了,可以这样：^[0-9]+(.[0-9]{1,2})?$ 这样就允许用户只写一位小数.下面我们该考虑数字中的逗号了,我们可以这样：^[0-9]{1,3}(,[0-9]{3})*(.[0-9]{1,2})?$ 1到3个数字,后面跟着任意个 逗号+3个数字,逗号成为可选,而不是必须：^([0-9]+|[0-9]{1,3}(,[0-9]{3})*)(.[0-9]{1,2})?$ 备注：这就是最终结果了,别忘了”+“可以用”*“替代如果你觉得空字符串也可以接受的话(奇怪,为什么?)最后,别忘了在用函数时去掉去掉那个反斜杠,一般的错误都在这里 xml文件：^([a-zA-Z]+-?)+[a-zA-Z0-9]+\\\\.[x|X][m|M][l|L]$ 中文字符的正则表达式：[\\u4e00-\\u9fa5] 双字节字符：[^\\x00-\\xff] (包括汉字在内，可以用来计算字符串的长度(一个双字节字符长度计2，ASCII字符计1)) 空白行的正则表达式：\\n\\s*\\r (可以用来删除空白行) HTML标记的正则表达式：\u003c(\\S*?)[^\u003e]*\u003e.*?|\u003c.*? /\u003e ( 首尾空白字符的正则表达式：^\\s*|\\s*$或(^\\s*)|(\\s*$) (可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)","date":"2022-05-27","objectID":"/20220527/:0:3","tags":["正则表达式"],"title":"正则表达式","uri":"/20220527/"},{"categories":["other"],"content":"无产权公寓值得购买吗","date":"2022-05-26","objectID":"/20220526/","tags":["其它"],"title":"无产权公寓","uri":"/20220526/"},{"categories":["other"],"content":"前言 今天走进了某公寓的售楼部（实质是公寓招商部），话说 38 万就可以购买一套 32 平米 40 年产权的公寓，相比均价 5 万上下一手楼楼价非常吸引人，让人有立刻购买的冲动。冲动是魔鬼，不想清楚就做一件事，很可能后悔一生。好在到了饭点时间，先去吃个饭，聊一聊天，看一看抖音。抖音真是好东西，搜索功能非常不错，可以让我们快速了解一些信息。原来公寓分为有产权和无产权，无产权租期一般 40 年以内，国家规定租赁合同最长 20 年，超过 20 年可能不受法律保护（例如：补充协议约定 20 年后承租人有权继续使用租赁物业）。此刻应该知道这公寓为什么这么便宜了吧！它其实就是长租给你，不是卖给你，没有房产证，签的是租赁合同！市面上还有很多房企“卖”公寓给你，再返租你的公寓，每月打钱给你。这种情况有可能是房企流动资金紧张，通过这种操作可以快速获得巨额资金，而你要等十来二十年才能拿回本钱…… ","date":"2022-05-26","objectID":"/20220526/:0:1","tags":["其它"],"title":"无产权公寓","uri":"/20220526/"},{"categories":["other"],"content":"无产权公寓值得购买吗？ 一、从我现有的条件和角度去分析： 1、产权问题：无产权证，不能买卖，转手麻烦……，无学位，无户口…… 2、合同问题：只有租赁合同，最长 20 年，20 年后不受律保护，风险大，继承复杂等等。 3、地段问题：本区不是商业区，偏向生活区，房子很多，拉下租金，目前评估只能是 1500 元左右，升值空间可能没想像那么好。 4、收益问题：假设 1500 元月租 30 年 7 成入住率，1500 * 12 * 30 = 378000 元，刚好回本，但 30 年后我已经六七十岁了，那时早已领养老金，孩子都已成年，此后的收益不是刚需！ 5、资金问题：由于无产权证，不能买卖，不能抵押，不能变现，无资金流动性。还不如买储蓄型保险，每年交几千元，到十来二十年可取出，期间还附带其它保险。 6、生活问题：由于商业性质，水电费、管理费贵，人员复杂，环境吵杂，没煤气，不利于长期居住。 7、风险问题：房企往往是为解决资金紧张才推出公寓“销售”，涉及一系列问题：是否有预售许可证、是否有销售备案证、是否存在抵押、是否被查封、是否一房多“售”等等。 二、那到底公寓适合什么人购买？ 1、特别有钱的人（专注投资人士） 2、没有房票的人（偏向单身人士） 3、买公寓的用途不是拿来居住的人（例如作为公司办公） ","date":"2022-05-26","objectID":"/20220526/:0:2","tags":["其它"],"title":"无产权公寓","uri":"/20220526/"},{"categories":["hardware"],"content":"小电路的一些小知识介绍","date":"2022-05-18","objectID":"/20220518/","tags":["电路"],"title":"小电路多学问","uri":"/20220518/"},{"categories":["hardware"],"content":"前言 一些小电路对于硬件工程师来说实在太简单了，闭着眼睛都可以把它画出来。正是因为简单而不过脑子，往往忽略了细节设计，造成一些隐患，严重时会烧坏电路！ ","date":"2022-05-18","objectID":"/20220518/:0:1","tags":["电路"],"title":"小电路多学问","uri":"/20220518/"},{"categories":["hardware"],"content":"电路 1、常用电路保护元件 ESD 二极管：静电放电、电压箝位、寄生电容很低、保护响应很快、超低漏电流、偏向信号接口保护，常用室内的板级接口。 TSS 二极管：防雷放电、电压开关、寄生电容稍低、保护响应较快、少许漏电流、偏向信号接口保护，常用户外设备级接口。 TVS 二极管：防雷抑制、电压箝位、寄生电容稍高、保护响应极快、少许漏电流、偏向电源接口保护，常用户外设备级接口。 更多，待续…… 2、IO 口外接信号输入 主要包括：减小信号抖动及高频信号干扰，提供确定的默认电平信号，保护 IO 口。 R1 上拉电阻： 上拉电阻的作用为了使信号有一个确定的默认高电平信号（如果需要低平，则改为下拉电阻）。当外部没有接线或外设重新上电时能确保有一默认的确定信号，防止不确定信号产生误动作。上拉电阻大小一般为 10K 或 20K 不等，根据实际应用场景决定。如果处理器内部有上拉电阻，则外部上拉电阻可以省去。 R2 限流电阻： 保护 IO 口，防止过流烧坏 IO 口（特别热拔热插时对 IO 保护尤其重要，例如在某宝购买的 D 版 jlink 烧录器，经常会烧坏，就是因为 IO 口没加限流电阻【备注：加入限流电阻会对速度有少许影响】），对静电或者一些高压脉冲有吸收作用。限流电阻大小一般为 100Ω 或 200Ω 不等，其取值与上下拉电阻及对地电容有关，否则影响输入信号的大小及速度。 C1 滤波电容： 减小信号抖动及高频信号干扰。滤波电容大小要根据实际应用选择，其取值与上下拉电阻和限流电阻有关，会影响输入信号的响应速度。例如外接一个自锁开关，则可以选择 0.1uF 较大容量的电容。 D1 ESD二极管： 静电保护二极管，防止静电干扰或者过压损坏 IO 口。根据 PCB 的成本及防护级别要求来决定添加与否，如果接口是给第三方设备连接，过压保护是必须的。 3、NPN 有源蜂鸣器驱动电路 主要包括：十足驱动、可靠关断、消除 EMI 辐射、保护驱动三极管。 R1 限流电阻： 保护 IO 口及防止流过基极电流过大损坏三极管，限流降低功耗（因为控制开关三极管，无需大电流控制）。 R2 下拉电阻： 为三极管基极下拉电阻，当 R1 端没输入信号时为三极管提供可靠的关断控制，同时提升 R1 端高电平的门槛电压，防止 R1 端输入信号不足或其受干扰导致三极管进入不期望的放大状态（蜂鸣器轻微发声或乱发声）。 C1 控制滤波电容： C1 可以在有强干扰环境下，有效的滤除干扰信号，避免蜂鸣器变音和意外发声。 C3 电源滤波电容： C3 是电源滤波电容，滤除电源高频杂波，同时减轻对电路板电源影响。 C2 EMC滤波电容： 因为有源蜂鸣器本身是一个振荡电路，会产生 EMC 辐射（频率一般为 1~2KHz，上图右边小图）。由于脉冲信号能量不是很强，增加 C2 滤波电容将脉冲信号滤除（一般使用 0.1uF 电容），同时也可过滤掉关断时的正向尖峰脉冲（≥10V），不过会对开关控制产生轻微的响应延时。 4、NPN 无源蜂鸣器驱动电路 主要包括：十足驱动、可靠关断、消除 EMI 辐射、保护驱动三极管。 无源蜂鸣器本质上是一个感性元件，开关控制时在蜂鸣器两端会有较强反向感应电动势，产生几十伏的尖峰电压，可能损坏驱动三极管，要使用耐压值较大和响应频率较高的二极管释放尖峰电压，常用 IN4148 的开关二极管。其它电路的作用与有源蜂鸣器一样，这里不重复赘述。为了电路的兼容性和可扩展性，建议无论是有源还是无源蜂鸣器，统一使用无源蜂鸣器驱动电路。 5、NPN 继电器驱动电路 待续…… 6、CAN/485 总线电路 EMC 电路： CAN/485 总线异常现象： 主要原因：1）带供电总线负载过重，共地压差超限及波动，影响通讯质量甚至烧录收发器；2）防雷管有寄生电容（推荐 TVS-SMBJ15CA，要求总线不要加入电容），接入总线设备越多寄生电容累加变得越大，影响通讯波形（出现“镰刀”波形）；3）总线通讯波形出现尖峰（出现在差分信号电平跳变边沿处），一般是由于信号反射导致，在末端加入 120Ω 终端电阻即可； EMC 与 通讯速率： 加入 EMC 设计必然会影响数字通讯质量，也就是说 EMC 能提高硬件抗恶劣环境能力，但也会连带对通讯速率和接入节点数量有影响！ 一组推荐的器件参数： 待续…… 7、一键开关机电路 开机：SW1 按下，Q1 导通，MCU 开始工作并控制 Q2 导通。 关机：SW1 按下，GPIO-In 检测到 SW1 按下，MCU 控制 Q2 关闭，则 Q1 关闭，最后电源断电。 待续…… 8、LED 恒流电路 注意：三极管 Q1 的功耗是否过高。三极管的功耗 Pc = Vce * Ic，Vce 为集电极与发射极的压差，Ic 为集电极流过的电流，对于 SOT-23 封装的三极管来说，很多只有 200mW！ 待续…… 9、单向 IO 电平转换 待续…… ","date":"2022-05-18","objectID":"/20220518/:0:2","tags":["电路"],"title":"小电路多学问","uri":"/20220518/"},{"categories":["other"],"content":"竞业限制协议的简单介绍","date":"2022-05-17","objectID":"/20220517/","tags":["其它"],"title":"竞业限制协议","uri":"/20220517/"},{"categories":["other"],"content":"前言 大公司的管理人员、高级技术人员，往往需要签竞业限制协议。什么是竞业限制协议，它与保密协议有什么不同？ ","date":"2022-05-17","objectID":"/20220517/:0:1","tags":["其它"],"title":"竞业限制协议","uri":"/20220517/"},{"categories":["other"],"content":"竞业限制协议 竞业限制协议：是指用人单位与劳动者可以在劳动合同中约定保守用人单位的商业秘密和与知识产权相关的保密事项，并约定在解除或者终止劳动合同后一定期限内，劳动者不得到与本单位生产或者经营同类产品、从事同类业务的有竞争关系的其他用人单位任职，或者自己开业生产或者经营同类产品的书面协议。对负有保密义务的劳动者，用人单位与劳动者在解除或者终止劳动合同后，在竞业限制期限内（不得超过二年）按月给予劳动者经济补偿。同样劳动者违反竞业限制约定的，应当按照约定向用人单位支付违约金。 竞业协议限制的义务主体只能是用人单位的高级管理人员、高级技术人员和其他负有保密义务的人员，用人单位不得与上述人员以外的其他劳动者约定竞业限制，否则该约定就是无效的。 竞业协议限制的范围、地域、期限由用人单位与劳动者约定，竞业限制的约定不得违反法律、法规的规定。它所限制的是劳动者的自由择业权。 保密协议和竞业限制协议有如下区别：（1）保密义务一般是法律的直接规定或劳动合同的随附义务，不管用人单位与劳动者是否签订保密协议，劳动者均有义务保守商业秘密。而竞业限制是基于用人单位与劳动者的约定产生，没有约定的，无须承担竞业限制义务。（2）保密义务要求保密者不得泄露商业秘密，侧重的不能“说”，竞业限制义务要求劳动者不能到竞争单位任职或自营竞争业务，侧重的是不能“做”。（3）保密义务劳动者承担的义务仅限于保密，并不限制劳动者的就业权，而竞业限制义务不仅仅限制劳动者泄密，还限制劳动者的就业，劳动者的负担重很多。（4）保密义务一般期限较长，只要商业秘密存在，劳动者的保密义务就存在，而竞业限制期限较短，最长不超过二年。 ","date":"2022-05-17","objectID":"/20220517/:0:2","tags":["其它"],"title":"竞业限制协议","uri":"/20220517/"},{"categories":["other"],"content":"刷抖音刷出了继承法","date":"2022-05-02","objectID":"/20220502/","tags":["其它"],"title":"人生无常之继承法","uri":"/20220502/"},{"categories":["other"],"content":"前言 前段时间刷抖音刷出了一则新闻：话说北京一名 38 岁的独身男子去世，留下一套总价 115 万没还完贷款的商品房，舅舅想继承房产遭拒，法院判决民政局成为遗产的管理人。初时我还不明白为什么会这样，后来看了评论才知道我不了解继承法。这位男子挺可怜的，父母双亡、未婚、无子女，没有兄弟姐妹、祖父母、外祖父母，而舅舅不在继承法人范围内，他也没有立遗嘱，所以才有这样的结果。我为这位 38 岁的男子去世感到惋惜，也为这位舅舅没能继承亲人遗产感到可惜。这件事告诉我们学习多点知识总是没错的，平常不一定用上，但关键时刻可能帮上你一个大忙！ ","date":"2022-05-02","objectID":"/20220502/:0:1","tags":["其它"],"title":"人生无常之继承法","uri":"/20220502/"},{"categories":["other"],"content":"继承法 法律对于继承人顺序和范围有明确规定：第一顺序是配偶、子女、父母，第二顺序是兄弟姐妹、祖父母、外祖父母。除此之外的其他亲戚是没有继承权的（除非立遗嘱），至于最终谁是担任遗产管理人已不是重点，关键要记住继承人顺序和范围！ ","date":"2022-05-02","objectID":"/20220502/:0:2","tags":["其它"],"title":"人生无常之继承法","uri":"/20220502/"},{"categories":["software"],"content":"介绍 MinGW-w64 编译套件(GNU 工具集) 的安装与使用","date":"2022-04-28","objectID":"/20220428/","tags":["MinGW","GNU","GCC","编译"],"title":"MinGW-w64 编译套件(GNU 工具集)","uri":"/20220428/"},{"categories":["software"],"content":"前言 ● MinGW/MinGW-w64（Minimalist GNU for Windows）是为 windows 系统打造的编译器套件，其主要是把 GNU 的 gcc、make 等编译工具移植到 Windows 平台下，并且包含了 Win32API ，使得原是在 linux 写的 C 源代码可以在 Windows 上编译及运行（exe 执行文件）。MinGW-w64 使用 Windows 的 C 语言运行库，因此编译出的程序不需要第三方 DLL，可以直接在 Windows 下运行。MinGW-w64 与 MinGW 的区别在于 MinGW 只能编译生成 32 位可执行程序，而 MinGW-w64 则可以编译生成 64 位或 32 位可执行程序。因此 MinGW 现已被 MinGW-w64 所取代，并且 MinGW 也早已停止了更新。更多的编译构建工具知识，请移步《linux-编译-linux 编译构建工具》。 ● TDM-GCC 衍生自 MinGW 和 MinGW-w64 的项目（功能是一样的），也是分为 32 位与 64 位两个版本，32 位版本的编译目标仅兼容 32 位应用程序，64 位版本的编译目标兼容 32 和 64 位应用程序。TDM-GCC 对比 MinGW-w64 会集成更新的 gcc 编译器，目前集成的版本为 GCC 10.3.0。 ","date":"2022-04-28","objectID":"/20220428/:0:1","tags":["MinGW","GNU","GCC","编译"],"title":"MinGW-w64 编译套件(GNU 工具集)","uri":"/20220428/"},{"categories":["software"],"content":"安装 1、MinGW-w64 的下载 一、版本说明 对于 MinGW-w64 的安装方式，分为在线安装和离线安装，但无论哪种安装方式，必须事先要理清软件不同类型的版本！关于 MinGW-w64 版本，打开【官方下载网页】，发现有很多类型版本，那是因为 MinGW-w64 是一个编译软件，涉及其本身是 32 位还是 64 位软件，还涉及其编译生成的应用软件是 32 位还是 64 位软件，以及用户目标程序使用哪种的线程模型来编写等等。所以我们需要根据自己实现情况选择对应版本，一般而言选择 x86_64-posix-sjlj 即可，关于 MinGW-w64 版本详细说明如下： 版本 适用范围 ● 软件在线安装 1、MinGW-W64-install.exe 在线安装器（安装过程选择类型版本） ● 操作系统位数 1、x86_64 MinGW-W64 为 64 位 Windwos 软件 2、i686 MinGW-W64 为 32 位 Windwos 软件 ● 使用线程模型 1、posix 用于应用软件跨平台编译，但性能会下降 2、win32 专用于 Windows 系统软件编译 ● 异常处理系统 1、sjlj 有性能损失，适合 32/64 位程序编译 2、seh 无性能损失，只适合纯 64 位程序编译 3、dwarf 无性能损失，只适合纯 32 位程序编译 二、下载说明 MinGW-w64 分为在线安装和离线安装，根据个人喜好选择对应版本下载即可。由于官方将下载托管到 SourceForge 上，所以你可以从【官网】链接到下载页面下载，也可直接打开 SourceForge【下载页面】下载。 2、MinGW-w64 的安装 一、在线安装 其实在线安装与离线安装无本质区别，在线安装程序（mingw-w64-install.exe）其实就是将【离线软件包】下载到【指定的目录下】而已，完成后还是需要手工将软件路径加入系统环境变量中。不建议在线安装，因为本人尝试了 N 次在线安装程序都没能成功下载【离线软件包】！下图为在线安装流程： ● 说明一：Version 指的是 gcc 的版本，如果没有特殊的需求，一般选择最高的版本号即可。 ● 说明二：Architecture 是指电脑系统是 32位 还是 64位，根据你的电脑系统做出对应选择。 ● 说明三：对于电脑只有两种操作系统，符合 posix 线程模型的 linux 等系统和 Windows 系统。开发 Windows 程序，则选择 win32 ；而开发 Linux、Unix、Mac OS 程序，则选择 posix 。 ● 说明四：异常处理在开发中非常重要，你在开发的过程中，大部分的时间会耗在处理各种异常情况上。如果你之前选择了 64 位，则这里有两个异常处理模型供你选择，seh 是新发明的，而 sjlj 则是古老的。seh 性能比较好，但不支持 32 位。 sjlj 稳定性好，而且支持 32位。 ● 说明五：关于将软件路径加入系统环境变量请查看下节离线安装说明。 二、离线安装 1、到【官网】打开页面下载离线包： 2、离线包解压到自定义目录下： 3、gcc 编译器工具所在的路径： 4、将路径添加到系统环境变量： 加入系统环境变量后，打开命令窗口，无论在何路径下，直接输入gcc命令即可使用 gcc 编译程序了。 3、TDM-GCC 的下载 一、下载说明 TDM-GCC 也是分为在线安装和离线安装，但两者无本质区别，其实都是选择两个安装包：tdm64-gcc、tdm-gcc。由于到国外下载不稳定，个人建议选择下载离线安装包！相关网址:【官网】、【下载页面】。 4、TDM-GCC 的安装 一、离线安装 双击安装文件打开安装界面，不需要勾选检测是否最新版本，直接点击Creat安装即可，最后在命令窗口输入gcc -v可查看 gcc 版本。特别说明：查看 make 版本的命令为mingw32-make -v（与 MinGW 一样）。 ","date":"2022-04-28","objectID":"/20220428/:0:2","tags":["MinGW","GNU","GCC","编译"],"title":"MinGW-w64 编译套件(GNU 工具集)","uri":"/20220428/"},{"categories":["software"],"content":"使用 1、在命令窗口输入gcc -v可查看 gcc 版本。 2、查看 make 版本的命令为mingw32-make -v！ 3、Windows下使用MakeFile(Mingw)文件 待续…… ","date":"2022-04-28","objectID":"/20220428/:0:3","tags":["MinGW","GNU","GCC","编译"],"title":"MinGW-w64 编译套件(GNU 工具集)","uri":"/20220428/"},{"categories":["MCU"],"content":"Keil 4 与 Keil 5 的兼容性问题","date":"2022-03-27","objectID":"/20220327/","tags":["Keil MDK"],"title":"Keil 4 与 Keil 5 的兼容性","uri":"/20220327/"},{"categories":["MCU"],"content":"前言 2013 年 10 月，Keil 公司（被 ARM 公司收购）正式发布 Keil uVision5 IDE，相比 Keil 4 最大的区别是其增加了 Software Packs，可以独立于工具链进行添加更新芯片支持库和软件中间库，并且 SWD 下载速度提升到了 50M。由于 Keil 5 内部架构升级还是比较大，与 Keil 4 存在一些兼容问题，需要我们来解决。补充：Keil 软件资源下载请移步到《安富莱电子》（链接2），J-Link 驱动请移步 《segger 官网下载》。 ","date":"2022-03-27","objectID":"/20220327/:0:1","tags":["Keil MDK"],"title":"Keil 4 与 Keil 5 的兼容性","uri":"/20220327/"},{"categories":["MCU"],"content":"方法 1、Keil 4, Keil 5 共存安装 因为使用 Keil 4 开发已经很长一段时间了，很多工程是 Keil 4 工程格式，暂不想将它们改为 Keil 5 工程格式，怕编译器更改影响编译的目标文件，引发原程序新 BUG 的产生，最好的方法是在同一系统环境里同时安装 Keil 4 和 Keil 5。但由于软件认为是版本的升级，不允许两版本软件共存，需要我们作出特别处理。不过本人更推荐安装：官方专用的 keil 5 兼容 keil 4 工程补丁（MDKCM 525.EXE - 安富莱电子提供下载），安装补丁后 keil 5 可直接打开 Keil 4 工程，此后如果想把 Keil 4 工程改为 Keil 5 工程，直接把 xxx.uvproj、xxx.uvopt 另存在为 xxx.uvprojx、xxx.uvoptx，再使用 Keil 5 打开即可。 1.1、要先安装 Keil 4，再安装 Keil 5，还要求安装到不同目录： 1.2、按win+r键运行，输入regedit打开注册表： 1.3、修改 Keil 4 版本的 exe 启动路径： 1.4、修改 Keil 5 版本的 exe 启动路径： 1.5、之后打开 Keil 4 和 Keil 5 工程就互不干扰了。 PS：Keil 5 及 keil 4 兼容补丁 名称 版本 说明 Keil5 MDK-ARM V5.33 ARM Cortex-M 系列 IDE 开发工具 Keil.STM32F1xx_DFP V2.3.0 STM32F1xx 芯片支持包 Keil.STM32F4xx_DFP V2.16.0 STM32F4xx 芯片支持包 MDKCM V5.25 Keil5 打开 Keil4 工程兼容包（Cortex-M） Segger(mdk514-Segger.rar) V5.14 解决 Keil 5 死锁 J-Link 的替换文件(夹) → 备注：建议使用 STM32CubeMX 将 HAL 库更新至最新版本！ 2、Keil 4 打开源文件卡死 之前用高版本的 Keil 5 打开过工程（没更改工程扩展名），现在用低版本的 Keil 4 打开就会出现：打开源文件直接跳至最后一行卡死。解决方法：打开工程关闭所有窗口文件，然后全部保存，关闭 Keil，再次打开就可以了。还有一方法：直接删除 .uvopt、.uvopt.bak、.uvproj.bak 文件（但可能会影响某些工程配置）。 3、Keil 4 打开 Keil 5 工程 某些情况下需要使用 Keil 4 打开 Keil 5 工程（例如：还没安装 Keil 5），而软件一般是高版本向低版本兼容，低版本不能打开高版本。对于没有使用 Software Packs 的 Keil 5 工程只需要修改里面几项内容后，即可使用 Keil 4 打开。 3.1、复制两个工程文件，并更改扩展名： 3.2、修改工程项目文件里面内容： 3.3、最后即可打开上图的project.uvproj工程并使用。 补充：但某些情况下可能出现编译“Error: XXXXXX: type of input file ‘xxxxxx’ unknown”错误时，需要手工对每个包含路径更新一遍： 4、Keil 5 打开 Keil 4 工程 为了 Keil 5 能“原汁原味”地打开 Keil 4 工程，我们可以安装兼容包（Arm7、Arm9、Cortex-R 为 MDK79525.EXE，Cortex-M 为 MDKCM 525.EXE）：MDKCM 525.EXE - 安富莱电子提供下载）。安装兼容包后 keil 5 可直接打开 Keil 4 工程，此后如果想把 Keil 4 工程改为 Keil 5 工程，直接把 xxx.uvproj、xxx.uvopt 另存在为 xxx.uvprojx、xxx.uvoptx，再使用 Keil 5 打开即可（Keil 5 会自动修正文件相关内容）。 PS：Keil 5 及 keil 4 兼容补丁 名称 版本 说明 Keil5 MDK-ARM V5.33 ARM Cortex-M 系列 IDE 开发工具 Keil.STM32F1xx_DFP V2.3.0 STM32F1xx 芯片支持包 Keil.STM32F4xx_DFP V2.16.0 STM32F4xx 芯片支持包 MDKCM V5.25 Keil5 打开 Keil4 工程兼容包（Cortex-M） Segger(mdk514-Segger.rar) V5.14 解决 Keil 5 死锁 J-Link 的替换文件(夹) → 备注：建议使用 STM32CubeMX 将 HAL 库更新至最新版本！ 5、Keil 5 死锁 J-Link 解决 我的 J-Link 比较旧：固件 V7 版，驱动为 V4.98；安装的 Keil 5 为 V5.33 版。在 Keil 5 中使用 J-Link 调试，会强制要求升级 J-Link 固件，不升级不能用，升级又被死锁。于是从网上搜索一些解决方案，得到两条重要信息：1、Keil V5.23 以及之前版本不检测 J-Link D版；2、使用 J-Link 驱动的 JLinkARM.dll 替换 Keil 5 后就不会提示升级固件（也有网文提到包括 JLink.exe）。有了这两条信息，就有了解决方案： 5.1、Keil V5.14 取代 Keil V5.33 的 Segger 文件夹： 5.2、J-Link V4.98 替换 Keil V5.33 的 JLinkARM.dll 文件： 5.3、成功解决强制升级及死锁问题： 6、Keil 5 使用的编译器 从 MDK 5.37 开始，不再默认安装 Arm Compiler 5（ARMCC）编译器（可以下载独立安装），只集成 Arm Compiler 6（ARMCLAN，基于 LLVM 的 Clang）编译器，也就是说 Arm Compiler 5 以后就要退出舞台了！补充：Keil 软件资源下载请移步到《安富莱电子》，J-Link 驱动请移步 《segger 官网下载》。 ","date":"2022-03-27","objectID":"/20220327/:0:2","tags":["Keil MDK"],"title":"Keil 4 与 Keil 5 的兼容性","uri":"/20220327/"},{"categories":["blog","linux"],"content":"网站 PPT 生成工具 Slidev 介绍","date":"2022-03-16","objectID":"/20220316/","tags":["Slidev","linux 工具/应用"],"title":"网站 PPT 生成工具 Slidev","uri":"/20220316/"},{"categories":["blog","linux"],"content":"Slidev 的简介 Slidev /slʌɪdɪv/ 基于 Node.js、Vue.js 开发，利用它我们可以使用 Markdown 及扩展语法编写 PPT，它支持各种好看的主题、代码高亮、公式、流程图、自定义的网页交互组件，还可以方便地导出成 pdf 或者直接部署成一个静态网站（纯静态的 HTML、JavaScript 文件）。前提需要安装 Node.js 的版本 \u003e=14.0.0（注：Node.js 都会默认安装 npm，具体请参考笔记《网站 node 包管理器 npm》） 官网：Slidev、GitHub 另一款 Markdown 制作 PPT 利器：Marp、网文 ","date":"2022-03-16","objectID":"/20220316/:0:1","tags":["Slidev","linux 工具/应用"],"title":"网站 PPT 生成工具 Slidev","uri":"/20220316/"},{"categories":["blog","linux"],"content":"Ubuntu 平台 1、Slidev 的安装与使用 1、项目创建 npm init slidev@latest #创建PPT项目，根据向导进行操作： #1、输入项目名称（文件夹名称，例如输入：myppt） #2、询问是否启动服务（输入：y） #3、选择资源服务器（选择：npm） #4、之后自动拉取资源包，最后自动启动本地演示服务 #5、根据提示在浏览器输入网址浏览PPT网站：http://localhost:3030 #6、如果想退出服务按`Ctrl + C`组合键退出 2、全局安装 npm i -g @slidev/cli #安装 slidev 工具（方便以后操作） slidev -v #查看版本（用于验证是否安装成功） ####命令基本使用#### cd myppt #进入之前创建的项目文件夹 slidev #启动本地演示服务（浏览网址：http://localhost:3030，按`Ctrl + C`组合键退出） slidev build #构建静态网站网页（存到 dist 文件夹，并且手工把 index.html 网页内容的 href=\"/assets/ 改为 href=\"/网站相对路径/assets/ 相对路径） slidev build --base aaa #同上，并指定网站相对路径，无须手工改 index.html（例如主页为 https://o2ospring.github.io 则网站相对路径 https://o2ospring.github.io/aaa） slidev export #构建PPT为PDF文件（测试不成功，以后再补充！！！！） #构建PPT事前需要安装依赖包：npm i -D playwright-chromium 2、PPT 内容编写及语法 PPT 浏览快捷键 ● 这里提前介绍一下我们浏览已构建好 PPT 网页的基本操作快捷键（下表），如果要更多操作可以把鼠标移到网页左下角即可调出导航菜单。 快捷键 动作 ← 前一步显示 → 或 空格 后一步显示 ↑ 前一页显示 ↓ 后一页显示 f 全屏进入/退出 o 总览进入/退出 d 亮/暗模式切换 PPT 整体内容编写 ● 在根目录下的slides.md文件里编写整个 PPT 文档，使用标准的 Markdown 语法编写即可，也可以使用扩展语法来丰富 PPT 内容及样式。首页开头有两个---包含相关配置信息（例如：使用哪个主题等）。页与页之间使用一个---作为分隔，也可以像首页一样使用两个---包含自己专用配置信息（例如：修改此页布局为左右分割） --- # 主题方案选择（默认：'default'，更多：https://cn.sli.dev/themes/gallery.html） theme: 'default' # 配色方案选择（自动：'auto'，明亮：'light'，暗黑：'dark'） colorSchema: 'auto' # 幻灯片长宽比（默认：'16/9'） aspectRatio: '16/9' # 幻灯片的宽度（默认：空白，单位为 px） canvasWidth: 980 # 幻灯片总标题（默认：空白-\u003e首页标题，否则这里指定总标题） title: '' # 总标题的后缀（默认：'%s'，加入后缀如：'%s-我的PPT'） titleTemplate: '%s - Slidev' # 幻灯片的信息（点击左下角导航栏中感叹号查看），可以使用 markdown 语法来书写 info: | ## 关于本 PPT 这是我的第一个 PPT 演示，请关注我博客 [o2ospring's blog](https://o2ospring.github.io)! # 语法高亮设置（目前可选 'prism' 或 'shiki' 方案） highlighter: 'prism' # 显示代码行号（显示行号：true，不显示行号：false） lineNumbers: false # 启用 monaco 编辑器，默认情况下仅在开发者（dev）模式中启用 #monaco: 'dev' # 在单页（SPA）构建中启用 pdf 下载，也可以指定一个自定义 url #download: true # vue-router 模式，可以使用 'history' 或 'hash' 模式 #routerMode: 'history' # 字体将从 Google 字体自动导入 # 了解更多：https://sli.dev/custom/fonts #fonts: # sans: 'Roboto' # serif: 'Roboto Slab' # mono: 'Fira Code' # 为所有幻灯片添加默认的 frontmatter #defaults: # layout: 'default' # random image from a curated Unsplash collection by Anthony # like them? see https://unsplash.com/collections/94734566/slidev background: https://source.unsplash.com/collection/94734566/1920x1080 # apply any windi css classes to the current slide class: 'text-center' # persist drawings in exports and build drawings: persist: false --- # 这是第一页标题 本行内容为首页内容（一般是幻灯片主题）.... \u003c!-- 扩展文字按钮，一般用于在首页点击进入下一页 --\u003e \u003cdiv class=\"pt-12\"\u003e \u003cspan @click=\"$slidev.nav.next\" class=\"px-2 py-1 rounded cursor-pointer\" hover=\"bg-white bg-opacity-10\"\u003e 点击进入下一页 \u003ccarbon:arrow-right class=\"inline\"/\u003e \u003c/span\u003e \u003c/div\u003e \u003c!-- 专门做的 github 链接小图标（在页面右下角） --\u003e \u003cdiv class=\"abs-br m-6 flex gap-2\"\u003e \u003ca href=\"https://github.com/o2ospring\" target=\"_blank\" alt=\"GitHub\" class=\"text-xl icon-btn opacity-50 !border-none !hover:text-white\"\u003e \u003ccarbon-logo-github /\u003e \u003c/a\u003e \u003c/div\u003e \u003c!-- 在页尾注释的文字是备注，不是注释！ --\u003e --- # 这是第二页标题 这是普通文本内容 * 这是无序列表 1. 这是有序列表 修改单页的布局 ● 页面布局一般有两种：一整页、左右分割两部分。 \u003c!-- 左右分割布局格式，如下 --\u003e --- layout: two-cols --- \u003ctemplate v-slot:default\u003e # 左半页标题 这是左半页内容 ![插入图片1](https://o2ospring.github.io/android-chrome-192x192.png) \u003c/template\u003e \u003ctemplate v-slot:right\u003e # 右半页标题 这是右半页内容 ![插入图片2](https://o2ospring.github.io/about/o2ospring_blog.png) \u003c/template\u003e 代码块及扩展 ● 除了能对代码进行配色，还可以支持高亮动画显示。 \u003c!-- 代码块及扩展，其中{all|2|1-3|all}为扩展语法，表示分四步高亮显示：全部、第2行、第1-3行、全部代码，如下 --\u003e `` `json {all|2|1-3|all} {\"menu\": { \"id\": \"file\", \"value\": \"File\", \"popup\": { \"menuitem\": [ {\"value\": \"New\", \"onclick\": \"CreateNewDoc()\"}, {\"value\": \"Open\", \"onclick\": \"OpenDoc()\"}, {\"value\": \"Close\", \"onclick\": \"CloseDoc()\"} ] } }} `` ` 显示动画语法 ● 显示主要包括显示顺序、显示动画。关于几个不同的显示顺序语法，不建议同一页面使用多个不同语法，否则显示顺序可能错乱！ \u003c!-- 针对行内容的显示顺序，如下 --\u003e \u003cdiv v-click=\"3\"\u003e111 此行内容最后显示\u003c/div\u003e \u003cdiv v-click=\"2\"\u003e222 此行内容次之显示\u003c/div\u003e \u003cdiv v-click=\"2\"\u003e222 此行内容次之显示\u003c/div\u003e \u003cdiv v-click=\"1\"\u003e333 此行内容最先显示\u003c/div\u003e \u003c!-- 针对列表项的显示顺序，如下 --\u003e \u003cv-clicks\u003e - 无序列表内容一；//点一步显示下一项列表（注意：列表动画扩展语法需要空行隔开↑） - 无序列表内容二。//点一步显示下一项列表（注意：列表动画扩展语法需要空行隔开↓） \u003c/v-clicks\u003e 插入图标或图片 ● 你可以通过 Icônes 来浏览访问所有可用的图标，每个图标都有自己的标识符。例如：小火箭的标识符为uim-rocke","date":"2022-03-16","objectID":"/20220316/:0:2","tags":["Slidev","linux 工具/应用"],"title":"网站 PPT 生成工具 Slidev","uri":"/20220316/"},{"categories":["MCU"],"content":"ACM32F403RE 国产 MCU 试用笔记","date":"2022-03-15","objectID":"/20220315/","tags":["ARM Cortex-M"],"title":"ACM32F403RE 国产 MCU 试用笔记","uri":"/20220315/"},{"categories":["MCU"],"content":"前言 现在很多公司要求应用芯片国产化，于是找来一家国产单片机厂家（上海爱信诺航芯电子科技有限公司（简称：上海航芯）），有幸拿到厂家的一块 MCU 为 ACM32F403RET8 开发板（资料：开发工具/开发板/ACM32F403RET7_NUCLEO_V1.0），用于前期技术验证。目前只是简单试用了一下，没有深入研究，不过其驱动库比 STM32F 单片机简单很多，很容易上手。本文只是记录初次使用时遇到的一些问题，没详细介绍如何使用，关于具体使用方法可参考官方文档。ACM32F403RE 基于 ARMv8-M 架构，支持 Cortex-M33 和 Cortex-M4F 指令集，最高支持 180MHz 系统工作频率，支持浮点运算和 DSP。如此强劲的内核，当然不会“裸跑”，直接上 rt-thread 实时操作运行测试。 ","date":"2022-03-15","objectID":"/20220315/:0:1","tags":["ARM Cortex-M"],"title":"ACM32F403RE 国产 MCU 试用笔记","uri":"/20220315/"},{"categories":["MCU"],"content":"基于 rt-thread 的 acm32f4xx-nucleo 工程初次调试 1、安装 IDE 芯片支持包及下载工程 时间：2022-03-15 软件：Keil MDK V5.33 版本：rt-thread v4.1.0-beta 工程：rt-thread\\bsp\\acm32f4xx-nucleo 网址：开发工具/IDE支持包/Aisinochip.ACM32F4.Keil.pack、rt-thread（版本 v4.1.0-beta） 下载安装操作完成后，就可以打开软件工程了。还有一点必须注意：工程配置那里必须重新选择 MCU 型号！ 2、安装厂家调试器驱动不成功问题 时间：2022-03-15 系统：Windows 7 旗舰版 驱动：ACM32-在线编程器\\USB转SPI-I2C驱动\\AisinochipUSBDriver.exe 问题： 无法成功安装 AISINOCHIP CMSIS-DAP 调试器驱动： 解决： 1、首先安装 USB 转 SPI-I2C 驱动：ACM32-在线编程器\\USB转SPI-I2C驱动\\AisinochipUSBDriver.exe 2、再安装 AISINOCHIP CMSIS-DAP 调试器驱动： 3、编译工程提示有两个函数未定义 时间：2022-03-15 软件：Keil MDK V5.33 版本：rt-thread v4.1.0-beta 工程：rt-thread\\bsp\\acm32f4xx-nucleo 问题： 编译工程提示出错： .\\build\\keil\\ACM32F4XX.axf: Error: L6218E: Undefined symbol System_EnableIAccelerate (referred from system_acm32f4.o). .\\build\\keil\\ACM32F4XX.axf: Error: L6218E: Undefined symbol HAL_EFlash_Init_Para (referred from hal_eflash.o). 分析： 1、未定义System_EnableIAccelerate()函数，应该是缺少System_Accelerate.c文件； 2、未定义HAL_EFlash_Init_Para()函数，应该是缺少HAL_EFlash_EX.c文件； 3、实际上这两个源文件厂家提供的是没开源的.lib库文件，由于 rt-thread 仓库项目过滤规则.gitignore过滤了.lib文件，厂家应该没留意，造成没有推送这两个源文件到 github 远程仓库。 解决： 1、从官网下载演示源码 开发工具/SDK驱动库/Nucleo_ModulesDemo_Rev1.0.8 2、复制ModulesDemo_Rev1.0.8\\ModulesDemo\\Core_Drivers\\Device\\System_Accelerate.lib到rt-thread\\bsp\\acm32f4xx-nucleo\\libraries\\Device\\ 3、复制ModulesDemo_Rev1.0.8\\ModulesDemo\\Core_Drivers\\HAL_Driver\\Src\\HAL_EFlash_EX.lib到rt-thread\\bsp\\acm32f4xx-nucleo\\libraries\\HAL_Driver\\Src\\ 4、最后把它们加入项目工程： 4、单步运行与源文件代码对应不上 时间：2022-03-16 硬件：ACM32F403RET7_NUCLEO_V1.1 软件：Keil MDK V5.33 版本：rt-thread v4.1.0-beta 工程：rt-thread\\bsp\\acm32f4xx-nucleo 问题： 进入调试后，先全速再单步运行代码，发现执行与源文件代码对应不上，貌似执行的是另一源文件另一段代码。 原因： 因配置重新选择了另一款调试器，造成调试器相关配置重置。 解决： 1、如果使用 CMSIS-DAP 调试器，参考《开发工具/开发板/ACM32F4_FP4_F3系列芯片开发快速上手V0.4.pdf》里面的配置说明； 2、造成上述现象，是因为没勾选：Option for Target → Utilities →Update Target before Debugging选项： 5、操作系统调试串口不能输入命令 时间：2022-03-16 硬件：ACM32F403RET7_NUCLEO_V1.1 软件：Keil MDK V5.33 版本：rt-thread v4.1.0-beta 工程：rt-thread\\bsp\\acm32f4xx-nucleo 问题： rt-thread 系统调试口只能打印数据，不能输入命令。 原因： 由于厂家《ACM32F403RET7_NUCLEO_V1.1》开发板的 UART1（PA9、PA10）引脚连接了 ACL16（CMSIS-DAP）调试器芯片，硬件复用冲突。 解决： 到《rtconfig.h》修改配置，把调试口移到 UART2（PA2、PA3）即可： #define RT_CONSOLE_DEVICE_NAME \"uart2\" #define BSP_USING_UART2 #define BSP_UART2_RX_USING_DMA（如果屏蔽表示不开 DMA） #define BSP_UART2_TX_USING_DMA（如果屏蔽表示不开 DMA） 6、操作系统调试串口逻辑结构说明 //\u003crtconfig.h\u003e配置串行通讯总开关：（由用户配置） #define BSP_USING_UART2 #define BSP_UART2_RX_USING_DMA #define BSP_UART2_TX_USING_DMA ...... //\u003cboard.h\u003e定义串口的端口与引脚：（由用户配置） #if defined(BSP_USING_UART2) #define UART2_TX_PORT GPIOA #define UART2_RX_PORT GPIOA #define UART2_TX_PIN GPIO_PIN_2 #define UART2_RX_PIN GPIO_PIN_3 #if defined(BSP_UART2_RX_USING_DMA) #define UART2_RX_DMA_INSTANCE DMA_Channel0 #define UART2_RX_DMA_RCC BIT12 #define UART2_RX_DMA_IRQ DMA_IRQn ...... //\u003cuart_config.h\u003e串行对象初始值： #if defined(BSP_UART2_TX_USING_DMA) #if defined(BSP_UART2_RX_USING_DMA) #ifndef UART2_DMA_RX_CONFIG #define UART2_DMA_RX_CONFIG \\ { \\ .Instance = UART2_RX_DMA_INSTANCE, \\ .dma_rcc = UART2_RX_DMA_RCC, \\ .dma_irq = UART2_RX_DMA_IRQ, \\ .channel = UART2_RX_DMA_CHANNEL, \\ .request = UART2_RX_DMA_REQUEST, \\ } #endif /* UART2_DMA_RX_CONFIG */ #endif /* BSP_UART2_RX_USING_DMA */ ...... #ifndef UART2_CONFIG #define UART2_CONFIG \\ { \\ .name = \"uart2\", \\ .Instance = UART2, \\ .irq_type = UART2_IRQn, \\ .enable_id = EN_UART2, \\ .tx_port = UART2_TX_PORT, \\ .rx_port = UART2_RX_PORT, \\ .tx_pin = UART2_TX_PIN, \\ .rx_pin = UART2_RX_PIN, \\ } #endif /* UART2_CONFIG */ #endif /* BSP_USING_UART2 */ ...... //\u003cdrv_uart.c\u003e串行对象初始化： static struct acm32_uart_config uart_config[] = { #ifdef BSP_USING_UART1 UART1_CONFIG, #endif #ifdef BSP_USING_UART2 UART2_CONFIG, #endif ...... rt_err_t rt_hw_uart_init(void) { ...... for (int i = 0; i \u003c obj_num; i++) { uart_obj[i].config = \u0026uart_config[i]; ...... } ...... } ...... acm32_uart_ops = { _uart_configure, ... } uart_obj[i].serial.ops = \u0026acm32_uart_ops; rt_err_t rt_serial_init() { ... serial-\u003eops-\u003econfigure(serial, \u0026serial-\u003econfig) ...} _uart_configure( HAL_UART_Init( ...... 1、rt-thread","date":"2022-03-15","objectID":"/20220315/:0:2","tags":["ARM Cortex-M"],"title":"ACM32F403RE 国产 MCU 试用笔记","uri":"/20220315/"},{"categories":["software"],"content":"常用开发辅助工具","date":"2022-03-08","objectID":"/20220308/","tags":["工具"],"title":"常用开发辅助工具","uri":"/20220308/"},{"categories":["software"],"content":"前言 古语有云“工欲善其事，必先利其器”。对于做开发的我们，辅助工具是提高开发效率、提高开发质量的必备工具！有个它，我们就如虎添翼！兄弟们，冲鸭！快乐开发吧！备注：如果你在网上没找到它或者有特殊要求时，可以到我的【工具袋】找找看^0^。 ","date":"2022-03-08","objectID":"/20220308/:0:1","tags":["工具"],"title":"常用开发辅助工具","uri":"/20220308/"},{"categories":["software"],"content":"工具 1、搜索启动工具 平台 软件 网址 授权 Windows Everything 官网 免费软件 Windows AnyTXT 官网 免费软件 Windows UPDesktop 下载 免费软件 2、代码编辑工具 平台 软件 网址 授权 Windows Notepad++ 官网 免费软件 Windows/Linux/MacOS Notepad– 官网、开源 免费软件 Windows/Linux/MacOS VScode 官网 免费软件 Windows Source Insight 官网 收费软件 3、代码比较工具 平台 软件 网址 授权 Windows/Linux Meld 官网、开源 免费软件 Windows/Linux/MacOS BeyondCompare 官网 收费软件 Windows Fairdell HexCmp2 官网 收费软件 Windows/Linux/MacOS CCompare 官网、下载 免费软件 4、代码版本工具 平台 软件 网址 授权 Windows/Linux/MacOS git 官网 免费软件 Windows TortoiseGit 官网 免费软件 Windows/Linux/MacOS SmartGit 官网 非完全免费软件 Windows SVN 官网 免费软件 5、代理加速工具 平台 软件 网址 授权 Windows/Linux dev-sidecar 官网 免费软件 6、远程终端工具 平台 软件 网址 授权 Windows SecureCRT 官网 收费软件 Windows Xshell 官网 收费软件 Windows MobaXterm 官网、介绍 免费/收费软件 7、脑图设计工具 平台 软件 网址 授权 Windows/Linux/MacOS XMind 官网 收费软件 Windows/Linux/MacOS FreeMind 官网 收费软件 Windows/Linux/MacOS Draw.io 官网、在线版、离线版 开源免费 网文介绍 嵌入式开发必备的绘图工具 画时序图的四个好用的工具 8、Markdown 编辑器 平台 软件 网址 授权 Windows/Linux/MacOS Typora 官网 目前免费 9、通讯数据调试助手 平台 软件 网址 授权 Windows UartAssist 官网 免费软件 Windows sscom 官网 免费软件 Windows ECOM 下载 免费软件 Windows CEIWEI CommMonitor 官网 收费软件 Windows AccessPort 官网、下载 免费软件 Windows NetAssist 官网 免费软件 Windows IpTool 官网 免费软件 Windows/MacOS Wireshark 官网 免费软件 Windows MiniSniffer 下载 免费软件 Windows ipscan 下载 免费软件 Windows Modbus Poll 下载 收费软件 10、虚拟数字示波器 平台 软件 网址 授权 Windows/Linux/MacOS Vofa+ 官网 免费软件 Windows 匿名助手 官网 免费软件 Windows Visual Scope：Serial Digital Scope 下载 收费软件 Windows Micro-Lab 官网、介绍 收费软件 Windows Sailor 官网、开源 免费软件 Windows Serial-Studio 官网、开源 免费软件 11、字图格式化工具 平台 软件 网址 授权 Windows Img2Lcd 下载 收费软件 Windows PCtoLCD2002 下载 免费软件 Windows LoveString 2.0 下载 免费软件 Windows 格式工厂 官网 免费软件 Windows/MacOS iLovePDF 官网 在线免费 Windows JSONedit 官网 免费软件 Windows EncodingChecker 官网 免费软件 12、图片音视频工具 平台 软件 网址 授权 Windows FastStone Capture 官网 收费软件 Windows ACDSee 官网 收费软件 Windows/Linux/MacOS sfxr 官网、下载 免费软件 Windows/Linux rFXGen 官网、下载、开源 免费软件 Windows/Linux/MacOS HandBrake 官网、开源 免费软件 13、下载与传输工具 平台 软件 网址 授权 Windows/Linux/MacOS chfs 官网、下载、用法、同类 免费软件 Windows/Linux/MacOS Motrix 官网、中文官网、下载、开源 免费软件 14、服务类搭建工具 平台 软件 网址 授权 Windows/Linux Hugo 官网、下载、开源 免费软件 15、AI 工具 平台 软件 网址 授权 网站 豆包（字节跳动） 豆包 135…….., 短信验证码 网站 月之暗面（Kimi） Kimi.ai 135…….., 短信验证码 网站 深度求索（DeepSeek） DeepSeek 135…….., 短信验证码 网站 讯飞星火 SparkDesk 135…….., w……. 网站 百度 AI 百度 AI o2o……, w……. 网站 通义千问 通义千问 135…….., 短信验证码 网站 Cherry Studio（AI 助手） Cherry Studio 16、在线集合工具 平台 软件 网址 授权 网站 帮小忙（腾讯工具箱网站） 帮小忙、网文 免费软件 17、浏览器工具 平台 软件 网址 授权 Firefox/Chrome Dark Reader（网页深色主题渲染） Dark Reader 免费软件 Firefox/Chrome Markdown Reader（浏览器 md 文件渲染） Markdown Reader 免费软件 Firefox/Chrome 沉浸式翻译 沉浸式翻译 免费软件 PS：Firefox 附加组件官网 18、安全与防火墙工具 平台 软件 网址 授权 Windows Firewall App Blocker（FAB 防火墙配置工具） 官网、下载 免费软件 ","date":"2022-03-08","objectID":"/20220308/:0:2","tags":["工具"],"title":"常用开发辅助工具","uri":"/20220308/"},{"categories":["software","linux"],"content":"简单介绍 UnxUtils 的安装及使用","date":"2022-02-28","objectID":"/20220228/","tags":["UnxUtils","linux 工具/应用"],"title":"UnxUtils 之 unix 模拟工具","uri":"/20220228/"},{"categories":["software","linux"],"content":"前言 UnxUtils ② /ʌŋks ˈjuːtɪlz/ 是一个针对 Windows 系统的工具集，其核心功能是将一系列常用的 Unix/Linux 命令行工具移植到 Windows 环境中，让 Windows 用户能够在命令提示符（CMD）或 PowerShell 中使用这些熟悉的 Unix 工具，从而简化跨平台的脚本编写和系统管理工作。 ","date":"2022-02-28","objectID":"/20220228/:0:1","tags":["UnxUtils","linux 工具/应用"],"title":"UnxUtils 之 unix 模拟工具","uri":"/20220228/"},{"categories":["software","linux"],"content":"UnxUtils 简介 1、核心功能： ● GNU工具移植‌：包含ls、grep、sed等200+常用命令的Windows编译版本。 ● 轻量化运行‌：无需安装虚拟机或子系统，直接通过环境变量调用命令行工具。‌ ● 兼容性支持‌：适用于Windows XP至Windows 10系统，部分命令支持UTF-8编码处理。 2、主要特点： ● 工具覆盖广泛：包含了大量经典的 Unix 命令，如 grep(文本搜索)、sed(流编辑器)、awk(文本处理)、ls(列出目录内容)、cp(复制文件)、rm(删除文件)、tar(归档)、gzip(压缩)等，基本覆盖了日常文本处理、文件操作、系统查询等场景。 ● 适配 Windows 环境：这些工具经过修改，能够兼容 Windows 的文件系统（如支持盘符、反斜杠路径）和命令行交互方式，同时保留了 Unix 工具的核心语法和功能，降低了跨平台使用的学习成本。 ● 轻量易用：以可执行文件（.exe）形式提供，无需复杂安装，解压后将目录添加到系统环境变量 PATH 中，即可在命令行直接调用。 ● 开源免费：基于开源许可发布，用户可以自由使用、修改和分发。 3、适用场景： ● 习惯 Unix/Linux 命令的开发者在 Windows 上进行脚本编写或日常操作。 ● 需要移植 Unix 脚本到 Windows 系统运行，减少因命令差异导致的修改成本。 ● 进行跨平台开发时，保持命令行工具使用习惯的一致性。 4、注意事项： ● 随着 Windows 系统的发展，微软推出的 Windows Subsystem for Linux (WSL) 提供了更完整的 Linux 环境，功能上可能比 UnxUtils 更全面，因此 UnxUtils 逐渐被 WSL 替代，但对于轻量需求或旧系统，仍有其使用价值。 ● 部分工具在 Windows 下的行为可能与原生 Unix 环境存在细微差异（如换行符处理），使用时需注意兼容性。 如果需要在 Windows 上快速使用基础 Unix 命令，UnxUtils 是一个简单实用的选择。 5、安装使用： 下载解压 UnxUtils ② 并将其 usr/local/wbin 文件夹的绝对路径加到 windows 环境变量即可使用。 5.1、添加 windows 系统环境变量： # 将执行文件路径到 windows 环境变量，例如： # D:\\cygwin64\\usr\\local\\bin # 注意使用 ; 符分隔各个变量，具体例子如下： ;D:\\cygwin64\\usr\\local\\bin 1.2、验证 cmd 命令窗调用 linux 命令： ","date":"2022-02-28","objectID":"/20220228/:0:2","tags":["UnxUtils","linux 工具/应用"],"title":"UnxUtils 之 unix 模拟工具","uri":"/20220228/"},{"categories":["software","linux"],"content":"简单介绍 cygwin 的安装及使用","date":"2022-02-27","objectID":"/20220227/","tags":["Cygwin","linux 工具/应用"],"title":"cygwin 之 unix 模拟环境","uri":"/20220227/"},{"categories":["software","linux"],"content":"前言 有时候想利用 linux 的资源开发 windows 软件，或者是利用 linux 的资源（工具被封装成 Windows.exe执行文件）帮忙我们在 windows 系统上完成某项工作（尤其是使用 gnu 工具集在 windows 上进行嵌入式系统开发是非常有用的!）。使用 Cygwin /ˈsɪɡwɪn/ 是非常好的选择，它由 cygnus solutions 公司开发的自由软件，其集成绝大部分的 linux 软件包，只需使用 Cygwin 安装程序（实则是资源管理器）安装（添加）对应软件包即可。 ","date":"2022-02-27","objectID":"/20220227/:0:1","tags":["Cygwin","linux 工具/应用"],"title":"cygwin 之 unix 模拟环境","uri":"/20220227/"},{"categories":["software","linux"],"content":"安装 1、到 Cygwin 官网下载： ● 软件简介： Cygwin 是一个在 windows 平台上运行的类 unix 模拟环境，是一个 windows 软件；在其编译及运行的软件也是.exe的 windows 软件，而非 linux 软件（例如：gcc是gcc.exe的 windows 软件!）；甚至对系统的操作也是对 windows 操作（例如：reboot命令，是重启 windwons 系统!）。简单说：包括 cygwin 以及在其里面运行的软件都是 windows 软件，它只是模拟在 linux 中运行。 ● 特别说明 ： 1、注意：Cygwin 环境中编译构建的软件在运行时必须依赖cygwin1.dll，如果制作独立软件建议用 MinGW-w64/TDM-GCC 工具链来编译构建软件； 2、关于：Cygwin 和 MinGW 都是为用户提供在 windows 操作系统使用 GNU 工具的方法，使得原是 linux 写的 c 源代码可以在 windows 上编译及运行（exe 执行文件）。Cygwin 大而全面，提供完整的类 Unix 环境；而 MinGW 小而高效，其主要是编译器，一般只支持编译使用 C/C++ 标准库的程序。 3、补充：UnxUtils ② /ʌŋks ˈjuːtɪlz/ 也是 Windows 下的 Unix Linux 工具集，其集成了 Unix 系统的很多命令，下载解压并把它 usr/local/wbin 文件夹的绝对路径加到 windows 环境变量即可使用。 3、补充：Windows Subsystem for Linux (WSL) 是微软开发的 Windows 系统组件，能让用户在 Windows 上直接运行完整的 Linux 发行版，无需虚拟机或双系统。 ● 下载网址 ： Cygwin 官网下载：http://www.cygwin.com 2、点安装程序直接安装： 关于 Cygwin 安装程序（setup-x86_64.exe），更准确说是 Cygwin 软件资源管理器，其主要工作是安装/删除/升级相关软件包。例如：发现wget不存在，按照初次在线安装一样的流程安装，当到软件包安装界面时，选择full全列表并在搜索框输入wget选择对应软件包进行安装。 安装工作分两部分： 1、安装 Cygwin 程序（设置安装路径）； 2、下载+安装软件包（设置下载缓存路径）。 安装方式则分三种： 1、在线安装（实质就是 2 和 3）。 2、下载离线软件包， 3、安装离线软件包。 3、常用工具所需软件包： 下面列出一些常用的工具软件包，可以在软件包安装界面进行勾选安装。当需要安装很多软件包时，手工勾选显得繁琐且低效，这时我们可以使用apt-cyg命令工具来安装（后面章节会介绍这个命令安装及使用）。 软件/工具 所需软件包 常用 wget, curl, gawk, openssh, nc, bzip2, xz, tar, unzip, lua, dos2unix gcc gcc-core, gcc-g++, binutils, gdb, make, cmake, libgccpp1 待续… 待续…… ","date":"2022-02-27","objectID":"/20220227/:0:2","tags":["Cygwin","linux 工具/应用"],"title":"cygwin 之 unix 模拟环境","uri":"/20220227/"},{"categories":["software","linux"],"content":"使用 1、Cygwin 里查看系统信息： # 查看系统信息、软件包 cygcheck -h #帮助 cygcheck -s #查看系统信息(包括已装软件包等) cygcheck -l #列出[已装软件包]所有文件路径 cygcheck -c #列出[已装软件包]版本信息 cygcheck -c cygwin #查看[cygwin]版本信息 cygcheck -p vim #从[cygwin.com]网上查询[vim]软件包 cygcheck /bin/gcc #检查[gcc]可执行文件依赖于哪些库（相当于Linux下的ldd命令） 2、Cygwin 里安装 hugo 案例： Hugo 是一个博客生成工具，本节以安装 Hugo 作为示例，介绍 Cygwin 的基础操作（可同时打开《博客生成工具 Hugo》的『Hugo 的安装』章节对比一下两者的区别）。Hugo 官方为我们编译好各种平台二进制文件，安装时不需要安装任何依赖软件，直接下载使用即可。特别说明：我们要下载的 hugo 是 windows 版本，非 linux 版本，文件为hugo_0.92.2_Windows-64bit.zip。在 windows 的桌面双击Cygwin64 Terminal运行 Cygwin 的 unix 模拟环境的终端机，之后与 linux 环境下一样使用命令进行相关操作： wget https://github.com/gohugoio/hugo/releases/download/v0.92.2/hugo_0.92.2_Windows-64bit.zip #在命令窗口直接下载hugo(下载建议的extended版本) unzip -q hugo_0.92.2_Windows-64bit.zip #解压到当前文件夹 mv hugo.exe /usr/local/bin/ #将hugo移到本地应用程序目录 vi /etc/profile #编辑系统环境变量,在文件最后加入内容：export PATH=$PATH:/usr/local/bin (备注:实际是系统默认路径,可以不加) hugo version #查看版本,验证安装是否成功（建议重新打开 Cygwin 再运行命令查看） ","date":"2022-02-27","objectID":"/20220227/:0:3","tags":["Cygwin","linux 工具/应用"],"title":"cygwin 之 unix 模拟环境","uri":"/20220227/"},{"categories":["software","linux"],"content":"扩展 1、apt-cyg 工具安装以及使用： 用惯 Ubuntu 就知道，使用apt-get install/remove命令非常方便安装/卸载软件（常用于批量操作），那么 Cygwin 是否有类似命令？当然有的，那就是apt-cyg第三方工具，需要手工安装，以及事前须要安装依赖包：bash wget tar gawk bzip2 xz。其中 bash、tar、gawk 属于 Base 类，在安装最小系统时已包含；而 wget、bzip2、xz 属于 Archive 类，需要通过 Cygwin 安装程序先装上，确保后续运行 apt-cyg 不出错。 1.1、安装依赖包wget tar gawk bzip2： 这些依赖包的安装方法按照前面的【安装】章节操作即可，或者说在前面【安装】章节已把这些依赖软件包安装了。 1.2、下载 apt-cyg 并且添加到 Cygwin： 1.3、验证apt-cyg安装是否成功有效： apt-cyg install vim #在 Cygwin 中使用`apt-cyg`命令安装 vim，用于验证`apt-cyg`是否安装成功 #【补充一】可能用到的命令： apt-cyg --help #查看帮忙 apt-cyg mirror #查看镜像源地址 apt-cyg mirror http://mirrors.163.com/cygwin #设置(修改)镜像源地址 #【补充二】使用 apt-cyg 安装常用工具： apt-cyg install python python-crypto #安装python环境 apt-cyg install util-linux #安装util-linux包（包含more/col/whereis等命令）: apt-cyg install inetutils #安装telnet/ftp工具 apt-cyg install man cygwin-doc apt-cyg install vim screen wget subversion \\ openssh pwgen gzip bzip2 curl rsync \\ bash-completion lftp nc tree p7zip \\ connect-proxy util-linux bind-utils inetutils 2、windows 调用 Cygwin 工具： 其实 windows 的 cmd 命令窗口可以直接使用 Cygwin 相关软件包工具，方法很简单：只需把软件包所在路径加入系统环境变量里即可。这里不得不说一下 Windows 下的 Unix Linux 工具集 UnxUtils ②，其集成了 Unix 系统的很多命令，下载解压并把它 usr/local/wbin 文件夹的绝对路径加到 windows 环境变量即可使用。 2.1、UnxUtils 核心功能与特性： ● GNU工具移植‌：包含ls、grep、sed等200+常用命令的Windows编译版本。 ● 轻量化运行‌：无需安装虚拟机或子系统，直接通过环境变量调用命令行工具。‌ ● 兼容性支持‌：适用于Windows XP至Windows 10系统，部分命令支持UTF-8编码处理。 2.2、添加 windows 系统环境变量： # 共加三个路径到 windows 环境变量， # D:\\cygwin64\\bin # D:\\cygwin64\\sbin # D:\\cygwin64\\usr\\local\\bin # 注意使用 ; 符分隔各个变量，具体例子如下： ;D:\\cygwin64\\bin;D:\\cygwin64\\sbin;D:\\cygwin64\\usr\\local\\bin 2.3、验证 cmd 命令窗调用 linux 命令： ","date":"2022-02-27","objectID":"/20220227/:0:4","tags":["Cygwin","linux 工具/应用"],"title":"cygwin 之 unix 模拟环境","uri":"/20220227/"},{"categories":["blog","linux"],"content":"Hugo 应用笔记，记录使用 Hugo 搭建个人博客的过程","date":"2022-01-26","objectID":"/20220126/","tags":["hugo","LoveIt","linux 工具/应用"],"title":"博客生成工具 Hugo","uri":"/20220126/"},{"categories":["blog","linux"],"content":" /* 一键按钮悬浮左下角样式 */ #toggleAll { font-size: 10px; position: fixed; left: 15px; bottom: 15px; z-index: 9999; box-shadow: 0 2px 8px rgba(0,0,0,0.2); transition: background 0.3s ease; } #toggleAll:hover { background: #eee; } 一键展开全部 ","date":"2022-01-26","objectID":"/20220126/:0:0","tags":["hugo","LoveIt","linux 工具/应用"],"title":"博客生成工具 Hugo","uri":"/20220126/"},{"categories":["blog","linux"],"content":"Hugo 的简介 Hugo /'hjuːgəʊ/ 是一种用 Go 语言编写的静态网站生成器，旨在让网站创建再次变得简单有趣。其主要用于个人 Blog、项目文档、初创公司站点构建。Hugo 的特点：简单、易用、高效、易扩展、快速部署，其中最大的优点就是超级快！ 中文官网 英文官网 ","date":"2022-01-26","objectID":"/20220126/:0:1","tags":["hugo","LoveIt","linux 工具/应用"],"title":"博客生成工具 Hugo","uri":"/20220126/"},{"categories":["blog","linux"],"content":"Ubuntu 平台 1、Hugo 的安装 Hugo 官方为我们编译好各种平台二进制文件，安装时不需要安装任何依赖软件，直接下载使用即可。建议安装最新版本的 Hugo，因为你可以直接在官网下载最新主题，快速熟悉 Hugo 的基本使用（搭建本地的博客先能跑起来），之后再找一个中文主题，有中文说明，方便我们更深入了解 Hugo 使用与配置。 在您的电脑上安装Hugo执行文件，更详尽可参考 Hugo 官方的部署文档； 在您的电脑上安装Git执行文件，更详尽可参考 Git 官方的部署文档； Hugo全部版本下载 Hugo中文官方文档 Hugo英文官方文档 go全部版本下载 wget https://github.com/gohugoio/hugo/releases/download/v0.92.0/hugo_extended_0.92.0_Linux-64bit.tar.gz #在命令窗口直接下载hugo(下载建议的extended版本) tar -xzvf hugo_extended_0.92.0_Linux-64bit.tar.gz #解压到当前文件夹 sudo mv hugo /usr/local/bin/ #将hugo移到本地应用程序目录 sudo gedit /etc/profile #编辑系统环境变量,在文件最后加入内容：export PATH=$PATH:/usr/local/bin (备注:实际是系统默认路径,可以不加) source /etc/profile #使能系统环境变量。 hugo version #查看版本,验证安装是否成功 #不需要安装go,忽略下面两行内容 #sudo apt install golang-go #安装go #go version #查看版本,验证安装是否成功 PS：在 Android 运行 Hugo（点击展开） 通过 Termux 模拟 Linux 环境运行，在安卓上安装 Termux（中文官网）； 打开 Termux 后，先更新包管理器（需要较长时间）： pkg update \u0026\u0026 pkg upgrade -y 安装必要的依赖（如 wget 用于下载文件）： pkg install wget -y 从 Hugo 官网的 Release 页面 下载适用于 Linux ARM 架构 的二进制包（注意安卓设备的 CPU 架构，多数是 arm64，对应文件名含 arm64 或 aarch64）。例如： wget https://github.com/gohugoio/hugo/releases/download/v0.92.0/hugo_0.92.0_Linux-ARM64.tar.gz 解压文件并将 hugo 二进制文件移动到 Termux 的环境变量目录： mkdir tmp tar -zxvf hugo_0.92.0_Linux-ARM64.tar.gz -C tmp/ mv tmp/hugo /data/data/com.termux/files/usr/bin/ 验证是否可用： hugo version 2、Hugo 的使用 操作hugo命令时，必须在网站根目录里操作。在官网挑选一个最新主题（例如：casper 主题），确保与最新 Hugo 相匹配，避免因版本出现各种兼容问题。当使用官方最新主题搭建本地的博客能顺利跑起来后，再使用 中文主题-Maupassant 编译制作，因为其有中文说明而且超简洁，方便我们快速了解 Hugo 配置。 官方主题下载 中文官方文档 英文官方文档 中文主题-Maupassant → 基本使用（最简单最容易入门的一款主题） 中文主题-Bootstrap → 快速入门（可进一步了解使用 Hugo 建站） 中文主题-LoveIt → 基本概念（我选用的主题，外观-功能-性能综合不错） 中文主题-NexT → 优化 Hugo Next主题（另一款不错的主题） ########建网站######## hugo new site mysite #新建名为“mysite”的网站 cd mysite #进入网站“mysite”根目录 #下载官方(Casper)主题到./themes/，并且重命名为:casper git clone https://github.com/vjeantet/hugo-theme-casper.git themes/casper ########加博文######## hugo new post/first.md #新建一篇文章（实际目录在:./content/post/） #使用Markdown语法随便添加几行内容（用于展示） hugo server -t casper -D #指定主题“casper”编译并启动服务器（-t 因为配置文件没绑定主题,所以这里需要指定）（-D 表示草稿也编译） #根据提示用浏览器打开网址预览网站：http://localhost:1313/ #######日常使用####### # hugo #编译网站　（前提：编译配置文件绑定的主题） # hugo server #编译及启动本地网站服务器（前提：编译配置文件绑定的主题） 3、LoveIt 主题 第一步：先把(LoveIt)主题示范网站运行起来 #########建站######### hugo new site mywebsite #新建网站:“mywebsite” cd mywebsite #进入网站根目录 git init #初始化网站根仓库。把主题(LoveIt)(v0.2.10)添加到子仓库： git submodule add https://github.com/dillonzq/LoveIt.git themes/LoveIt #########配置########## #(1) #复制作者提供的示例：将 mywebsite/themes/LoveIt/exampleSite/ 里面的文件(夹)全复制到 mywebsite/ 根目录下 #(2) #删除编译异常文件夹：删 mywebsite/content/posts/theme-documentation-built-in-shortcodes 文件夹； #(3) #再执行下面相关指令： gedit ./config.toml #打开文件编辑，将里面的 themesDir = \"../..\" 修改为 themesDir = \"themes/\" #　以及 enableGitInfo = true 改为 enableGitInfo = false hugo server #编译并启动服务器（如果要在本地使能评论系统则修改代码和改用下行命令───────┐ #hugo serve -e production #编译并启动服务器←(先参考:https://lewky.cn/posts/hugo-4.html/)────┘） #########补充########## #取消多国语言只保留中文： #(1) #修改配置： gedit ./config.toml #打开文件编辑，将里面的 defaultContentLanguage = \"en\" 修改为 defaultContentLanguage = \"zh-cn\" #　以及屏蔽 [languages.en] 和 [languages.fr] 各约200行的非中文语言菜单配置 #(2) #屏蔽文件： #将 mywebsite/content 目录下所有文件名为 index.en.md 改为 #index.en.md （注：实际是要删除文件(夹)的，只因为目前还需要作为参考之用） #将 mywebsite/content 目录下所有文件名为 index.fr.md 改为 #index.fr.md （注：实际是要删除文件(夹)的，只因为目前还需要作为参考之用） #(3) #重新编译： hugo server #重新编译并启动服务器 #此时即可根据提示用浏览器打开网址预览网站：http://localhost:1313/ 第二步：在(LoveIt)主题示范网站加网页文章 添加博文： ########加博文######## mkdir content/posts/test #创建博文专题文件夹（必须含有主页《例如中文为:index.zh-cn.md》，否则不支持文章封面） hugo new content/posts/test/index.zh-cn.md #在网站根目录运行命令添加博文主页（主页文件名称须固定,不能其它，否则不支持文章封面） #也可不用建文件夹直接在 content/posts/ 目录下创建博文(如：xxxx.zh-cn.md 文件)，但不支持多语言及文章封面 #实际上直接创建md文件并编写即可，无须`hugo new`命令创建，文件头信息则要按标准写。 编写博文： 文章头部是博文相关参数及信息（具体参考 2 前置参数）； 后面是使用 Markdown 编写的博文。 示范博文如下： --- weight: 1 hiddenFromHomePage: false title: \"第一篇文章主题\" date: 2020-03-06T21:40:32+08:00 lastmod: 2020-03-06T21:40:32+08:00 draft: false author: \"文章作者\" authorLink: \"https://o2ospring.github.io\" description: \"文章封面描述\" resources: - name: \"文章封面名称\" s","date":"2022-01-26","objectID":"/20220126/:0:2","tags":["hugo","LoveIt","linux 工具/应用"],"title":"博客生成工具 Hugo","uri":"/20220126/"},{"categories":["blog","linux"],"content":"Hexo 应用笔记，记录使用 Hexo 搭建个人博客的过程","date":"2022-01-25","objectID":"/20220125/","tags":["Hexo","linux 工具/应用"],"title":"博客生成工具 Hexo","uri":"/20220125/"},{"categories":["blog","linux"],"content":"Hexo 的简介 Hexo /'heksoʊ/ 是一个基于 Node.js 的命令行工具。Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。前提需要安装 npm（注：Node.js 都会默认安装 npm，具体请参考笔记《网站 node 包管理器 npm》）注意：node.js(npm) 版本过低，Hexo 不支持（运行命令时提示各种错误），建议安装最新版本（例如：node-v17.5.0-linux-x64.tar.gz）！ 官网：Hexo ","date":"2022-01-25","objectID":"/20220125/:0:1","tags":["Hexo","linux 工具/应用"],"title":"博客生成工具 Hexo","uri":"/20220125/"},{"categories":["blog","linux"],"content":"Ubuntu 平台 1、Hexo 的安装 Hexo 的安装很简单，只需要通过 NPM 工具安装即可。（NPM 请阅读《网站 node 包管理器 npm》） 官方使用说明：文档 npm install -g hexo-cli #全局安装：使用 npm 安装 Hexo hexo version #查看 hexo 版本,可判断其是否安装成功 hexo help #查看 hexo 帮助,可查看命令选项功能列表 2、Hexo 的使用 官方使用说明：命令 网文：使用Hexo博客生成工具 hexo init myhexo/ #创建及初始博客目录(myhexo)(实际从github上clone博客网站资源) cd myhexo/ #进入目录(myhexo) npm install #安装所需资源包 hexo new abc #创建名称为\"abc\"的文件-文章(默认路径)：source/_posts/abc.md，此时可在文件加入一些内容 hexo new page -p about/me \"About me\" #创建目录及文件-文章(指定路径)：source/about/me.md 并加入内容\"About me\"(注:-p 实为 --path) hexo g #生成静态网页(默认路径：public/)(注:g 实为 generate) hexo s #启动本地Web服务(注:s 实为 server) #根据提示用浏览器打开网址预览网站：http://localhost:4000/ 3、Hexo 的主题 待续…… 4、Hexo 的发布 将静态网页托管到 GitHub Pages 直接将public/里面的所有文件（静态网页）托管到 GitHub Pages 上，具体操作请参考：《博客生成工具 Hugo》之【4、Hugo 的发布】。（备注：如果已在 GitHub 上创建了个人主页，则可以在主页下再创建一个子网页，访问地址为https://username.github.io/代码仓库名，参考【图示】）） 关于 Github Pages，是 GitHub 的一个功能，其允许用户在 GitHub 仓库托管你的个人、组织或项目的静态页面（自动识别 html、css、javascript）。与创建代码仓库操作步骤一样，不同是要指定仓库名称格式为username.github.io，username 改为你的 GitHub 账户名。 ","date":"2022-01-25","objectID":"/20220125/:0:2","tags":["Hexo","linux 工具/应用"],"title":"博客生成工具 Hexo","uri":"/20220125/"},{"categories":["blog","linux"],"content":"我们经常需要编写一些技术说明书，GitBook 可以帮助你编写简洁电子文档","date":"2022-01-24","objectID":"/20220124/","tags":["GitBook","linux 工具/应用"],"title":"电子书制作工具 GitBook","uri":"/20220124/"},{"categories":["blog","linux"],"content":"GitBook 的简介 GitBook /ɡɪt/bʊk/ 是一个基于 Node.js 的命令行工具，可使用 Github/Git 和 Markdown 来制作精美的电子书（例如：IT 行业技术说明书）。前提需要安装 npm（注：Node.js 都会默认安装 npm，具体请参考笔记《网站 node 包管理器 npm》）注意：node.js(npm) 版本过高，GitBook 不支持（运行命令时提示各种错误），目前建议安装 node-v10.24.1-linux-x64.tar.xz。 官网：gitbook ","date":"2022-01-24","objectID":"/20220124/:0:1","tags":["GitBook","linux 工具/应用"],"title":"电子书制作工具 GitBook","uri":"/20220124/"},{"categories":["blog","linux"],"content":"Ubuntu 平台 1、gitbook 的安装 GitBook 的安装很简单，只需要通过 NPM 工具安装即可。（NPM 请阅读《网站 node 包管理器 npm》） 网文：gitbook 的安装与使用 npm install -g gitbook-cli #安装GitBook电子书构建工具 gitbook -V #查看及检查是否最新版本,否则安装最新版本 #运行上行命令提示出错：TypeError: cb.apply is not a function #问题原因：node.js(npm) 版本过高，GitBook 不支持！ #解决方法：卸载高版本，安装低版本（如：v10.x，全部版本在：https://nodejs.org/dist/） 2、gitbook 的使用 电子书其实主要包括三部分内容：目录、文章介绍、具体章节。编写这三部分的 markdown 文档，再使用 gitbook 构建静态网页。 网文：gitbook 的安装与使用 gitbook init #在当前目录初始电子书（生成两文件: # README.md 书籍的介绍在这个文件里， # SUMMARY.md 书籍的目录结构在这里配置） # 目录语法为Markdown的无序列表+本地文件链接，例如： # * [简介](README.md) # * [第一章](./part1/README.md) # * [第一节](./part1/1.md) # * [第二章](part2/README.md) gitbook build #构建生成静态网页（创建 _book 目录） #gitbook build --format=website #指定输出格式: `website`（默认,静态网页） #gitbook build --format=json #指定输出格式: `json` #gitbook build --format=ebook #指定输出格式: `ebook` gitbook serve #启动本地Web服务 （在浏览器打开 http://localhost:4000/ 预览书籍） 3、gitbook 的发布 方式一：将静态网页托管到托管到 Gitbook 在 Gitbook.com 为此本书创建一个 git 仓库（配置相关参数）； 拷贝 git 地址，然后git clone到本地； 在本地按照 Gitbook 规范编辑电子书，然后git push到 Gitbook 的远程仓库。其默认访问地址是：https://用户名.gitbooks.io/项目名/content/ 具体请参考电子书：gitbook.com 官网操作 方式二：将静态网页托管到 GitHub Pages 直接将_book/里面的所有文件（静态网页）托管到 GitHub Pages 上，具体操作请参考：《博客生成工具 Hugo》之【4、Hugo 的发布】。（备注：如果已在 GitHub 上创建了个人主页，则可以在主页下再创建一个子网页，访问地址为https://username.github.io/代码仓库名，参考【图示】） 关于 Github Pages，是 GitHub 的一个功能，其允许用户在 GitHub 仓库托管你的个人、组织或项目的静态页面（自动识别 html、css、javascript）。与创建代码仓库操作步骤一样，不同是要指定仓库名称格式为username.github.io，username 改为你的 GitHub 账户名。 ","date":"2022-01-24","objectID":"/20220124/:0:2","tags":["GitBook","linux 工具/应用"],"title":"电子书制作工具 GitBook","uri":"/20220124/"},{"categories":["blog","linux"],"content":"做一个网站依赖的代码越来越多，npm 就是 node 的包管理器，是前后端工程师必备工具","date":"2022-01-23","objectID":"/20220123/","tags":["npm","linux 工具/应用"],"title":"网站 node 包管理器 npm","uri":"/20220123/"},{"categories":["blog","linux"],"content":"NPM 的简介 npm（Node Package Manager）是 node 的包管理器，随同 NodeJS 一起安装的包管理和分发工具，它很方便让 JavaScript 开发者下载、安装、上传以及管理已经安装的包，无论是前端还是后端开发都会使用到 npm 包管理器。（前端框架开发 react、Vue…，后台 node 开发）。历史原由：做一个网站依赖的代码越来越多，需要去很多网站下载相关分享代码，每次都要手工下载是不现实的，而且如果有个网站关闭了怎么办？于是出现了一个解决方案：用一个工具集中及管理这些代码（资源镜像站），这就是npm之 node 包管理器。 npm 的实现思路可以这么理解： 1、买个服务器做仓库（资源镜像）； 2、让 jQuery、Bootstrap、Underscore…等将代码提交到服务器上； 3、如果有人想用这些库，只需运行命令（如：npm install jQuery）下载到本地，库的代码就会被下载到当前 ./node_modules 目录中。 ","date":"2022-01-23","objectID":"/20220123/:0:1","tags":["npm","linux 工具/应用"],"title":"网站 node 包管理器 npm","uri":"/20220123/"},{"categories":["blog","linux"],"content":"Ubuntu 平台 1、npm 的安装 ● npm 的 linux 版本无需要安装，直接下载解压就可以使用，进入【下载页面】选择 Linux Binaries (x64) 版本下载。更多下载网址： 全部版本下载页面 英文最新下载页面 中文最新下载页面 网文：Linux 系统下 Nodejs 安装与卸载 ####安装方法#### wget https://nodejs.org/dist/latest-v10.x/node-v10.24.1-linux-x64.tar.xz #在命令窗口直接下载 tar -xf node-v10.24.1-linux-x64.tar.xz #解压到当前目录 sudo mv node-v10.24.1-linux-x64 /usr/local/node #移动文件夹并重命名为[node]（如果要安装多个版本，文件夹名称改为另一个名，例如:[node-v17.9.0-linux-x64]） # sudo gedit /etc/profile #（因下面`ln`命令会在系统目录下创建软链接，所以此步可不用设置）编辑系统环境变量，在文件最后加入两行内容：export PATH=$PATH:/usr/local/node/bin # source /etc/profile #（因下面`ln`命令会在系统目录下创建软链接，所以此步可不用设置）使能系统环境变量。　export PATH=$PATH:/usr/local/node/lib/node_modules/npm/bin cd /usr/bin #切换到软链接目录下 sudo ln -s /usr/local/node/bin/node node #添加执行软链接（如果要安装多个版本，则要改名，例如：sudo ln -s /usr/local/node-v17.9.0-linux-x64/bin/node node-17.9.0） sudo ln -s /usr/local/node/bin/npm npm #添加执行软链接（如果要安装多个版本，则要改名，例如：sudo ln -s /usr/local/node-v17.9.0-linux-x64/bin/npm npm-17.9.0） node -v #查看版本,验证安装是否成功（v10.24.1） npm -v #查看版本,验证安装是否成功（6.14.12） ####卸载方法#### sudo rm -rf /usr/local/node #直接删除整个目录即可（注意小心操作） ● 由于不同的软件需要使用不同的 npm 版本，过新或过旧都有可能不支持（例如：使用gitbook制作电子书就是因为不支持新版本，运行命令时提示各种错误），所以建议根据实际安装多个版本的 node（npm）来解决！多个版本共存的处理方法如下： ####安装方法#### #(1) #安装另一版本同上面介绍一样，只是[node]和[npm]名称不一样， #例如：1)文件夹名称为[node-v17.9.0-linux-x64]，2)软链接名称为[node-17.9.0]和[npm-17.9.0]【具体请看(2)】 #(2) #需要修改前面安装的[node-v10.24.1-linux-x64] 软链接名称： cd /usr/bin #切换软链接目录下 sudo ln -s /usr/local/node/bin/node node-10.24.1 #添加执行软链接（★因默认快捷方式改了名，必须按下面的【共存处理】进行操作） sudo ln -s /usr/local/node/bin/npm npm-10.24.1 #添加执行软链接（★因默认快捷方式改了名，必须按下面的【共存处理】进行操作） ####共存处理### sudo update-alternatives --install /usr/bin/node node /usr/bin/node-17.9.0 1709 --slave /usr/bin/npm npm /usr/bin/npm-17.9.0 sudo update-alternatives --install /usr/bin/node node /usr/bin/node-10.24.1 1024 --slave /usr/bin/npm npm /usr/bin/npm-10.24.1 #备注：上面的 --slave 的 npm 表示的默认版本由 node 配置决定。 #移除：从优先级列表中移除例子 #sudo update-alternatives --remove node /usr/bin/node-17.9.0 ####选择版本### sudo update-alternatives --config node #配置默认版本，根据界面提示输入对应数字+回车选择 2、npm 的命令 我们常用的npm命令主要是做四种操作：初始化、安装、删除、配置。 网文：npm 常用命令汇总 npm -v #查看npm的版本 npm init #初始化一个NPM项目,生成package.json文件，里面有各种依赖包的信息 npm install #一键安装:安装package.json里的所有依赖文件到当前./node_modules/ 目录下 npm install XXXX #本地安装:安装包到当前./node_modules/ 目录下,需要通过require()调用（注:XXXX为具体包名） npm install XXXX -g #全局安装:安装包到系统 /usr/local/ 目录下(或npm默认安装目录)可以通过命令行在任何地方调用它 npm install XXXX@3.9.1 #安装指定版本的包 npm install XXXX@latest #安装最新版本的包 npm uninstall XXXX #卸载安装的包(或 npm remove) npm info XXXX #查看包的详细信息 npm search XXXX #查找npm仓库 npm config get registry #查看下载仓库镜像网址 npm list #查看当前项目安装的所有模块 npm list -g #查看全局的所有模块 #####[命令/选项]简写##### # install -\u003e i # -global -\u003e -g # -save -\u003e -S（大写） # -save-dev -\u003e -D（大写） 几个选项补充说明 npm install XXXX命令 1. 安装模块到项目 node_modules 目录下。 2. 不会将模块依赖写入 devDependencies 或 dependencies 节点。 3. 运行 npm install 初始化项目时不会下载模块。 npm install -g XXXX命令 1. 安装模块到全局，不会在项目 node_modules 目录中保存模块包。 2. 不会将模块依赖写入 devDependencies 或 dependencies 节点。 3. 运行 npm install 初始化项目时不会下载模块。 npm install -save XXXX命令 1. 安装模块到项目 node_modules 目录下。 2. 会将模块依赖写入 dependencies 节点。 3. 运行 npm install 初始化项目时，会将模块下载到项目目录下。 4. 运行 npm install –production 或者注明 NODE_ENV 变量值为 production 时，【会】自动下载模块到 node_modules 目录中。 5. 主要用于生产环境下，因为生产环境无须安装一些调试或工具模块。 npm install -save-dev XXXX命令 1. 安装模块到项目 node_modules 目录下。 2. 会将模块依赖写入devDependencies 节点。 3. 运行 npm install 初始化项目时，会将模块下载到项目目录下。 4. 运行 npm install –production 或者注明 NODE_ENV 变量值为 production 时，【不会】自动下载模块到 node_modules 目录中。 5. 主要用于开发环境下，因为开发环境往往安装一些调试或工具模块。 3、cnpm 之替代 因为 npm 安装插件是从国外服务器下载，受网络影响大，可能出现异常，所以我们乐于分享的淘宝团队做了一个完整 npmjs.org 镜像（中国 NPM 镜像），你可以用它来代替官方版本（只读），其同步频率目前为每 10 分钟一次以保证尽量与官方服务同步。cnpm跟npm用法是一致，只是在执行命令时将npm改为cnpm即可，但必须要清楚一点：cnpm与npm命令执行有差异。例如：先执行了cnpm install lodash，然后再执行npm uninstall lodash，此时会报错。补充说明：尽管使用 npm 改成淘宝仓库，但当模块比较多的时候，发现安装速度还是远远比 cnpm 慢。个人建议：从通用角度来看，还是建议使用 npm，并把下载仓库路径改为淘宝镜像以提高下载速度。 网文：npm更换成淘宝镜像源以及cnpm ###特别说明#### ##原淘宝【npm】域名即将于【2022.06.30】停止解析，请切换至新域名 # https://npm.taobao.org --切换为--\u003e https://npmmirror.com # https://registry.npm.taobao.or","date":"2022-01-23","objectID":"/20220123/:0:2","tags":["npm","linux 工具/应用"],"title":"网站 node 包管理器 npm","uri":"/20220123/"},{"categories":["software","linux"],"content":"lua 的学习笔记，主要介绍 lua 的基本语法","date":"2021-12-21","objectID":"/20211221/","tags":["lua","linux 工具/应用"],"title":"lua 脚本基本语法","uri":"/20211221/"},{"categories":["software","linux"],"content":"前言 Lua /'luːə/ 是一个小巧且速度极快的脚本语言，由标准 C 编写而成，几乎在所有操作系统和平台上都可以编译运行，是作为嵌入式脚本的最佳选择。本人常用它来对文本内容进行批处理。 ","date":"2021-12-21","objectID":"/20211221/:0:1","tags":["lua","linux 工具/应用"],"title":"lua 脚本基本语法","uri":"/20211221/"},{"categories":["software","linux"],"content":"Lua 简介 1、lua 概述、官网、资料 Lua 是一个小巧的脚本语言，标准 C 编写而成，它可以被 C/C++ 代码调用，也可以反过来调用 C/C++ 的函数，几乎在所有操作系统和平台上都可以编译、运行。Lua 并没有提供强大的库，一个完整的 Lua 解释器不过 200KB，但它在所有脚本引擎中速度是最快的，是作为嵌入式脚本的最佳选择。Lua 是巴西里约热内卢天主教大学（Pontifical Catholic University of Rio de Janeiro）里的一个由 Roberto Ierusalimschy、Waldemar Celes 和 Luiz Henrique de Figueiredo 三人所组成的研究小组于 1993 年开发的。 安装 lua 后，其包括三部分： lua（解释器）： 用于运行 lua 脚本文件。例如：lua test.lua命令是运行 test.lua 脚本文件。 luac（编译器）： 用于加密 lua 脚本文件（但可逆向解密，参考网文）。例如：lua -o t.lua test.lua命令对 test.lua 脚本文件加密并生成 t.lua 加密文件，使用同样方式运行脚本加密文件即可：lua t.lua。 liblua.a（静态库）： 用于集成到其它程序中，例如编译一个 C 程序，调用 lua 操作 API 运行 lua 脚本。如果需要动态库，则需要修改 Makefile 文件并重新编译，具体请参考网文。 资料：官网、网文教程、菜鸟教程、Lua 5.3 API 参考手册、Lua 5.3 参考手册 、Lua API、中国顶级程序员-网游大咖-云风(吴云洋)-博客 + 他的git仓库 + Lua 编程技巧 ","date":"2021-12-21","objectID":"/20211221/:0:2","tags":["lua","linux 工具/应用"],"title":"lua 脚本基本语法","uri":"/20211221/"},{"categories":["software","linux"],"content":"Lua 安装 1、lua 解释器下载与安装 wget http://www.lua.org/ftp/lua-5.4.3.tar.gz #下载 tar zxf lua-5.4.3.tar.gz #解压 cd lua-5.4.3 #进入文件夹 make all test #编译 sudo make install #安装（安装到 /usr/local/bin/：lua(解释器)、luac(编译器)，及 /usr/local/lib/：liblua.a(静态库)） lua -v #查看版本（用于验证是否安装成功） 2、lua 脚本的编写与运行 ● 方法一：（1）编写脚本文件（但不指出 lua 脚本解析器），（2）在命令窗口运行脚本。 --（1）-- print(\"Hello World!\") --创建 HelloWorld.lua 脚本文件，在其增加此行脚本内容 ##（2）## chmod 777 HelloWorld.lua #修改 HelloWorld.lua 文件权限，使其权限为可执行文件 lua ./HelloWorld.lua #在命令窗口运行脚本文件，结果为打印出：Hello World! ● 方法二：（1）编写脚本文件（首行指出 lua 脚本解析器），（2）在命令窗口运行脚本。 #!/usr/local/bin/lua ---(1)--- --上行表示指定 lua 脚本解析器执行。★★注意：上行必须使用 \\n 来换行，不能是 \\r\\n 之类的来换行! 否则会提示 ^M 错误★★ print(\"Hello World!\") --创建 HelloWorld.lua 脚本文件，在其增加这里三行脚本内容 ###(2)### chmod 777 HelloWorld.lua #修改 HelloWorld.lua 文件权限，使其权限为可执行文件 ./HelloWorld.lua #在命令窗口运行脚本文件，结果为打印出：Hello World! ● 说明三：lua 脚本解析器支持交互式编程 lua #在命令窗口运行lua脚本解析器进入交互式编程， \u003e #进入了交互式编程，这里可以即时编写一行脚本并按回车执行： \u003e print(\"Hello World！\") #编写一行脚本内容，按回车后， Hello World！ #执行脚本（本例为打印信息）。 \u003e 3、lua 在 Windows 上安装 ● 方法一：安装现成集成环境（不过 lua 的版本则比较旧） 安装 SciTE 的 IDE 集成环境：网址 安装 LuaDist 的集成库（已不维护）：网址 安装 LuaRocks 的集成库：网址 例如：安装 SciTE 的 IDE 集成环境后，直接在命令窗口运行 lua 脚本文件即可： lua.exe .\\HelloWorld.lua #直接在命令窗口运行lua脚本文件 ● 方法二：自己编译自己安装（可以使用 lua 的最新版本） 下载 TDM-GCC 编译工具，不需要勾选检测是否最新版本，直接点击Creat安装即可（图示），最后在命令窗口输入gcc -v可查看 gcc 版本。 下载 lua 源代码，解压文件并编译。【网上也有已编译好的 lua】 gcc -v #查看gcc版本（用于验证TDM-GCC是否安装成功） cd lua-5.4.4 #进入lua文件夹（刚才文件解压的根文件夹） mingw32-make mingw #编译lua源代码（在src\\里生成：lua.exe(解释器)、luac.exe(编译器)，liblua.a(静态库)） cd src #进入src\\目录 lua.exe -v #查看lua版本（用于验证lua是否编译成功） 将 lua 加入环境变量（图示），但建议直接把lua.exe、luac.exe、liblua.a、lua54.dll剪切到C:\\Windows目录下。 备注： 关于 TDM-GCC：是为 windows 系统打造的编译器套件，其衍生自 MinGW 和 MinGW-w64 的项目，分为 32 位与 64 位两个版本，32 位版本的编译目标仅兼容 32 位应用程序，64 位版本的编译目标兼容 32 位应用程序与 64 位应用程序，最新的官方二进制版本为 GCC 10.3.0。更多的编译构建工具知识，请移步《linux-编译-linux 编译构建工具》。 参考：TDM-GCC 安装 lua、MinGW 编译 lua、MinGW 安装文件区别 ","date":"2021-12-21","objectID":"/20211221/:0:3","tags":["lua","linux 工具/应用"],"title":"lua 脚本基本语法","uri":"/20211221/"},{"categories":["software","linux"],"content":"Lua 语法 1、lua 概述 lua 由标准 C 编写而成，可以被 C/C++ 代码调用，也可以反过来调用 C/C++ 的函数，基于此我们可以很容易想像出它的语法一定会与 C 语言很相似。其中独立语句可以使用;分号分隔，也可以不用。还有特别说明一下，Lua 的所有变量其实都是字符，例如直接打印一个函数返回值return 100，虽然它是number数据类型，但打印结果还是字符串：100。 2、lua 关键字 一、lua 的关键字： 说明一、lua 关键字主要包括：声明、函数、跳转、返回、结束、判断、循环、真假、与或非等语句关键字。下面列出 22 个关键字： 关键字 关键字 关键字 关键字 local if then true function elseif false goto else nil break for in or return while do and end repeat until not 二、Lua 的数据类型： 说明二、Lua 数据类型主要包括：空值、布尔值、数值、字符串、数据、线程、表这些数据类型，它们通过type()函数返回值获得（返回为字符串，由字符串单词指出数据类型）。下面列出 8 个数据类型： 关键字 含义 “nil” 空值（在条件表达式中相当于 false） “boolean” 布尔值，包含两个值：true 和 false “number” 表示双精度类型的实浮点数 “string” 字符串由一对双引号或单引号来表示 “function” 由 C 或 Lua 编写的函数 “userdata” 表示任意存储在变量中的 C 数据结构 “thread” 表示执行的独立线路，用于执行协同程序 “table” Lua 中的表其实是一个\"关联数组\"（associative arrays），数组的索引可以是数字、字符串或表类型。在 Lua 里，table 的创建是通过“构造表达式”来完成，最简单构造表达式是{}，用来创建一个空表 补充说明 type()返回都是字符串！ --类型打印实例-- tb = {} aaa = nil print(type(tb)) --\u003e table print(type(\"Hello world\")) --\u003e string print(type(10.4*3)) --\u003e number print(type(print)) --\u003e function print(type(type)) --\u003e function print(type(true)) --\u003e boolean print(type(nil)) --\u003e nil print(type(type(print))) --\u003e string !!! if type(123) == \"number\" then --判断方法 end if type(aaa) == \"nil\" then --判断方法 end 三、Lua 的运算符： 说明三、Lua 运算符主要包括：算术、关系、逻辑、其它这几类运算符。它们有不同的优先级（强烈建议使用()指定），下面列出 8 级优先级： 优先级 运算符 备注 最高 ^ 连续几个^则是优先从右到左组合 x^y^z == x^(y^z) ↑ not　- - 为负号 │ *　/　% │ +　- │ .. │ \u003c　\u003e　\u003c=　\u003e=　~=　== │ and 最低 or --算术运算符-- + --加法 - --减法 * --乘法 / --除法 % --取余 ^ --乘幂（10^2为100） - --负号（-10） --关系运算符-- == --等于 ~= --不等于 \u003e --大于 \u003c --小于 \u003e= --大于等于 \u003c= --小于等于 --逻辑运算符-- （用于条件判断中：if() elseif() while() until()） and --逻辑与操作符（如：(A and B)） or --逻辑或操作符（如：(A or B)） not --逻辑非操作符（如：not(A and B)） --其它运算符-- # --返回字符串或数组的长度（如：#\"Hello\" 返回字符个数 5）（如果存在`nil`的组员，则计算组员个数可能出错！！！） : --表示表员/组员为函数且以隐式方式把表作为入口参数（如：file:read() 表示[表file]的表员是read()函数,并以隐式方式把[表file]作为入口参数,在函数内访问表员i写作 self.i ） . --表示表员/组员 （如：tb.i 表示 表tb的表员i） .. --连接两个字符串（如：a=\"Hello \" b=\"World\" print(a..b)，结果为：Hello World） ... --可变符：select(\"#\",...)则返回可变参数的个数 -- select( 3,...)则返回从第3开始的所有参数 -- (...)表示函数入口的变长参数 -- {...}表示由当前函数变长参数构成的数组 四、Lua 的注释： 说明四、Lua 注释主要包括：行、块两类注释。下面列出 2 种注释演示： --这是一行注释 --[[ 多行注释 多行注释 --]] 3、lua 变量 一、Lua 的变量： 说明一、Lua 变量有三种类型：全局变量、局部变量（local声明）、表中的域，它们的默认值（没有初始化时）均为nil。下面是展示变量的声明和初始化： tb = {} --这是一个没赋值的全局数组/表 tb.i --这是一个表的表员（《指定键名》为\"i\"的表员） tb[\"i\"] --这是一个表的表员（《指定键名》为\"i\"的表员） tb[i] --这是一个数组组员（【没有键名】的第i个组员） v = 1 --这是一个初始值为1的全局变量 a,b = a,v --这是多个变量给多个变量赋值，右边的变量值是本行命令之前的缓冲值(固定不会变)，不会受本行命令影响！ a,b = b,a --同上，结果就是 a 与 b 数值交换 a,b = 1 --等同 a,b = 1,nil a = --等同 a = nil b = nil --赋空值，相当于删除全局变量（释放内存） a,b = f() --函数多个返回值依次赋值a,b，如果只有一个返回值则 b=nil local c = 1 --这是一个局部变量，局部变量的访问速度比全局变量更快 二、Lua 的表/数组： 说明二、Lua 表/数组主要分为：一维数组、多维数组。表/数组的元素组成：键(名)=值。关于数组与表区别：数组其实就是一个有序的表。关于我对【表员】和〖组员〗的定义：有或无《键名》的元素都称为【表员】，没有《键名》的元素称为〖组员〗。不建议〖组员〗的数值设置为nil，否则会影响相关函数操作！ -----【一维数组】----- array = {a=\"a\",\"1\",b=\"b\",c} --数组 array, 共用一个组员（组员编号默认从1计起，默认为一维数组） print(array.c) --打印《指定键名》为 \"c\"的表员：nil（未赋值） print(array.a) --打印《指定键名》为 \"a\"的表员：a print(array[\"b\"]) --打印《指定键名》为 \"b\"的表员：b print(array[1]) --打印【有序组员】的第一个组员：1 print(array[2]) --打印不存在组员：nil（组员编号默认从1计起） print(array[0]) --打印不存在组员：nil（组员编号默认从1计起） print(array[\"abc\"]) --打印不存在表员：nil array = {} --数组 array（空数组，需要初始组员编号及数值） for i = -2,2,1 do array[i] = i*2 --初始组员编号及数值（本例组员设置为从-2计起） end --！！！但不建议设置编号为负数！！！ for i = -2,2,1 do print(array[i]) --打印所有的组员：-4 -2 0 2 4（共5行组员数值） end -----【多维数组】----- array = {} --数组 array（空数组，需要初始组员编号及数值） for i=1,3,1 do array[i] = {} --数组 array 首先初始一维数组，（必须初始第一维后，再初始此一维中的第二维，否则视为非法语句！） for j=1,3,1 do array[i][j] = i*j --数组 array 接着初始二维数组。（必须初始第一维后，再初始此一维中的第二维，否则视为非法语句！） end end for i=1,3,1 do for j=1,3,1 do print(array[i][j]) --打印所有的组员：1 2 3 2 4 6 3 6 9（共9行组员数值） end end 三、lua 的字符串： 说明三、字符串语法包括\"\" '' [[]]，其中[[]]中书写的特殊字符不需要转义。 -----【字符串】------- s = [[a\\\\\\\"\\'[[b]c]] --多行字符串：其语法不支持转义符，不支持连续多个“]”字符，但支持单个或隔开的“]”字符。 string1 = \"Lua\" --单行字符串：\"\" （注：\"\" 与 '' 没本质区别） string2 = '\\\"runoob.com\\\"' --单行字符串：'' （注：\"\" 与 '' 没本质区别） string3 = --多行字符串：[[]]（注：[[ 后可直接换行，不算入多行字符串的回车或换行！） [[ \"Lua Script\" ]] print(s) --打印的信息为：a","date":"2021-12-21","objectID":"/20211221/:0:4","tags":["lua","linux 工具/应用"],"title":"lua 脚本基本语法","uri":"/20211221/"},{"categories":["software","linux"],"content":"Lua 数据库 待续…… ","date":"2021-12-21","objectID":"/20211221/:0:5","tags":["lua","linux 工具/应用"],"title":"lua 脚本基本语法","uri":"/20211221/"},{"categories":["software","linux"],"content":"Lua 应用 1、Lua 4 个不同场景的例子 待续…… ","date":"2021-12-21","objectID":"/20211221/:0:6","tags":["lua","linux 工具/应用"],"title":"lua 脚本基本语法","uri":"/20211221/"},{"categories":["software"],"content":"介绍 attribute-at 编译属性的使用","date":"2021-06-27","objectID":"/20210627/","tags":["attribute"],"title":"attribute-at 编译属性-指定地址","uri":"/20210627/"},{"categories":["software"],"content":"简介 某些情况下的某个数据必须存储到指定地址的空间内，这样我们的程序或硬件才能正确访问（例如：设备的 ID）。对于这类需求，GCC 的编译属性__attribute__((at(绝对地址)))为我们提供了解决方案。 更多的 attribute 编译属性： 《attribute-section 编译属性-数据拼接》 《attribute-aligned 编译属性-地址对齐》 《attribute-packed 编译属性-字节对齐》 《attribute-weak 编译属性-弱符号》 《attribute-un/used 编译属性-未用警告》 《attribute-at 编译属性-地址指定》 ","date":"2021-06-27","objectID":"/20210627/:0:1","tags":["attribute"],"title":"attribute-at 编译属性-指定地址","uri":"/20210627/"},{"categories":["software"],"content":"使用 1、作用对象 __attribute__((at(绝对地址)))作用对象： 全局变量。 2、功能说明 __attribute__((at(绝对地址)))将全局变量强制定位到 RAM/Flash 的绝对地址上。 3、编程语法 //【全局变量】定位绝对地址上 const uint8_t id_1[12] __attribute__((at(0x0800F000))) = {1,2,3,4,5,6,7,8,9,10,11,12}; const uint8_t __attribute__((at(0x0800F100))) id_2[12] = {1,2,3,4,5,6,7,8,9,10,11,12}; __attribute__((at(0x0800F200))) const uint8_t id_3[12] = {1,2,3,4,5,6,7,8,9,10,11,12}; 4、语法总结 一、关于__attribute__(())的参数名称，为了防止与其它对象出现同名影响，强烈建议在参数的前后都加上__两个下划线。 __attribute__((section(x))) 改为 __attribute__((__section__(x))) __attribute__((at(a))) 改为 __attribute__((__at__(a))) __attribute__((packed)) 改为 __attribute__((__packed__)) __attribute__((aligned(n))) 改为 __attribute__((__aligned__(n))) __attribute__((unused)) 改为 __attribute__((__unused__)) __attribute__((used)) 改为 __attribute__((__used__)) __attribute__((weak)) 改为 __attribute__((__weak__)) 二、关于__attribute__(())语句书写位置总体原则：书写到修饰对象名称的后面（★修饰其左边的单元体(非每个元素)，放到最前面即是修饰整体★），但考虑要跨编译平台使用，强烈建议使用宏定义并且按下面规则使用。 //【总体原则】+++++++++++++++++++ #define O2O_SECTION(x) __attribute__((__section__(x))) //数据拼接　（对象名称后明声明） #define O2O_AT(a) __attribute__((__at__(a))) //地址指定　（对象名称后明声明） #define O2O_PACKED __attribute__((__packed__)) //字节对齐　（对象名称后明声明，强烈建议改用 #pragma pack(push, 1) ... #pragma pack(pop) 的兼容性更好） #define O2O_ALIGN(n) __attribute__((__aligned__(n))) //地址对齐　（对象整体最前声明） #define O2O_UNUSED __attribute__((__unused__)) //未用不警告（对象整体最前声明） #define O2O_USED __attribute__((__used__)) //未用不优化（对象整体最前声明） #define O2O_WEAK __attribute__((__weak__)) //弱化对象　（对象整体最前声明） #define O2O_INLINE static __inline //内联函数　（对象整体最前声明，c/h文件中直接编写函数(体)，不能外部声明） 三、关于__attribute__(())的__aligned__(n)参数对【结构体类型】修饰的特殊表现（只是唯一的特殊个案）： typedef struct obj_1_ { uint16_t a; uint8_t b; }obj_1_t __attribute__((__aligned__(64))); //1.用于[单体]结构体类型的【起始地址】 typedef struct obj_n_ { uint16_t a; uint8_t b; }__attribute__((__aligned__(64))) obj_n_t; //2.用于结构体[组员]类型的【起始地址】和【大小】，也可用于单体结构体！备注：是组员非成员！ // -┬- obj_1_t aaaaaa; //1.影响[单体结构体]的起始地址对齐，不能用于数组 ├→ ●只是唯一的特殊个案● obj_n_t bbb[6]; //2.影响结构体[每个组员]的起始地址对齐和大小限制----------------------┘ //3.影响[数组整体]起始地址，但不影响[其它组员]起始地址和大小！ __attribute__((__aligned__(64))) struct obj_1_ ccc[8]; //←┤ __attribute__((__aligned__(64))) struct obj_n_ ddd[8]; //←┘ 四、关于__attribute__(())的__section__(x)参数被【编译器】与【链接器】优化的问题： 【section】修饰的数据段会被【编译器】和【链接器】这两道关卡优化掉，需要增加特别语句加以防止！【used、unused】只针对【编译器】而言，但对于【链接器】无效，也就是说链接器的【-Wl,–gc-sections】参数还是会优化掉没使用的段，除非在【链接脚本】中使用【KEEP】语句特别指出的段才不会被优化掉！ //1.变量声明 __attribute__((__used__)) const uint8_t aaa __attribute__((__section__(\".init.001\"))); //增加__used__防止被[编译器]优化 __attribute__((__used__)) const uint8_t bbb __attribute__((__section__(\".init.002\"))); //增加__used__防止被[编译器]优化 //2.编译链接 gcc -Wl,--gc-sections -o hello hello.c /* -Wl,--gc-sections 会强制优化掉没使用的__section__（函数段/数据段）*/ //3.链接脚本 .text : { ............. . = ALIGN(4); KEEP(*(SORT(.init.*))) /* 使用 KEEP(*(SORT())) 防止被[链接器]优化 */ . = ALIGN(4); _etext = .; } \u003eFLASH ","date":"2021-06-27","objectID":"/20210627/:0:2","tags":["attribute"],"title":"attribute-at 编译属性-指定地址","uri":"/20210627/"},{"categories":["software"],"content":"介绍 attribute-un/used 编译属性的使用","date":"2021-06-26","objectID":"/20210626/","tags":["attribute"],"title":"attribute-un/used 编译属性-未用警告","uri":"/20210626/"},{"categories":["software"],"content":"简介 某些情况下的某些变量或函数通过间接方式调用（例如：使用section修饰的数据、操作系统与应用程序分离设计），这些变量或函数必须要保留，不被编译器优化掉或编译产生警告。对于这类需求，GCC 的编译属性__attribute__((used))为我们提供了解决方案。 更多的 attribute 编译属性： 《attribute-section 编译属性-数据拼接》 《attribute-aligned 编译属性-地址对齐》 《attribute-packed 编译属性-字节对齐》 《attribute-weak 编译属性-弱符号》 《attribute-un/used 编译属性-未用警告》 《attribute-at 编译属性-地址指定》 ","date":"2021-06-26","objectID":"/20210626/:0:1","tags":["attribute"],"title":"attribute-un/used 编译属性-未用警告","uri":"/20210626/"},{"categories":["software"],"content":"使用 1、作用对象 __attribute__((used))作用对象： 变量和函数。 2、功能说明 __attribute__((used))向编译器说明该函数或变量即使没使用也不能优化掉，不能产生警告。 __attribute__((unused))则是表示该函数或变量可能不使用，编译器不要产生警告信息。 多数情况下，这项属性与其它属性组合使用，单独使用的情况反而较少。关于属性的组合书写格式：在(( ))内写入多项属性，并使用,分隔。例如：__attribute__((used, section(\"data_name\"))) 特别说明：used、unused 只针对编译器而言，但对于链接器无效，也就是说链接器的--gc-sections还是会优化掉没使用的段，除非在链接脚本中使用KEEP语句特别指的段才不会被优化掉！ 3、编程语法 //【变量】写法： __attribute__((used)) uint8_t data1[5]; __attribute__((unused)) uint8_t data2[5]; uint8_t __attribute__((unused)) data3[5]; __attribute__((used, section(\"data_name\"))) const uint32_t data4[10]; //【函数】写法一： //__attribute__((used)) static int keep_this_fn(int k); static int keep_this_fn(int k) __attribute__((used)); static int keep_this_fn(int k) { k++; } //【函数】写法二：（建议使用） static int keep_this_fn(int k); __attribute__((used)) static int keep_this_fn(int k) { k++; } 4、语法总结 一、关于__attribute__(())的参数名称，为了防止与其它对象出现同名影响，强烈建议在参数的前后都加上__两个下划线。 __attribute__((section(x))) 改为 __attribute__((__section__(x))) __attribute__((at(a))) 改为 __attribute__((__at__(a))) __attribute__((packed)) 改为 __attribute__((__packed__)) __attribute__((aligned(n))) 改为 __attribute__((__aligned__(n))) __attribute__((unused)) 改为 __attribute__((__unused__)) __attribute__((used)) 改为 __attribute__((__used__)) __attribute__((weak)) 改为 __attribute__((__weak__)) 二、关于__attribute__(())语句书写位置总体原则：书写到修饰对象名称的后面（★修饰其左边的单元体(非每个元素)，放到最前面即是修饰整体★），但考虑要跨编译平台使用，强烈建议使用宏定义并且按下面规则使用。 //【总体原则】+++++++++++++++++++ #define O2O_SECTION(x) __attribute__((__section__(x))) //数据拼接　（对象名称后明声明） #define O2O_AT(a) __attribute__((__at__(a))) //地址指定　（对象名称后明声明） #define O2O_PACKED __attribute__((__packed__)) //字节对齐　（对象名称后明声明，强烈建议改用 #pragma pack(push, 1) ... #pragma pack(pop) 的兼容性更好） #define O2O_ALIGN(n) __attribute__((__aligned__(n))) //地址对齐　（对象整体最前声明） #define O2O_UNUSED __attribute__((__unused__)) //未用不警告（对象整体最前声明） #define O2O_USED __attribute__((__used__)) //未用不优化（对象整体最前声明） #define O2O_WEAK __attribute__((__weak__)) //弱化对象　（对象整体最前声明） #define O2O_INLINE static __inline //内联函数　（对象整体最前声明，c/h文件中直接编写函数(体)，不能外部声明） 三、关于__attribute__(())的__aligned__(n)参数对【结构体类型】修饰的特殊表现（只是唯一的特殊个案）： typedef struct obj_1_ { uint16_t a; uint8_t b; }obj_1_t __attribute__((__aligned__(64))); //1.用于[单体]结构体类型的【起始地址】 typedef struct obj_n_ { uint16_t a; uint8_t b; }__attribute__((__aligned__(64))) obj_n_t; //2.用于结构体[组员]类型的【起始地址】和【大小】，也可用于单体结构体！备注：是组员非成员！ // -┬- obj_1_t aaaaaa; //1.影响[单体结构体]的起始地址对齐，不能用于数组 ├→ ●只是唯一的特殊个案● obj_n_t bbb[6]; //2.影响结构体[每个组员]的起始地址对齐和大小限制----------------------┘ //3.影响[数组整体]起始地址，但不影响[其它组员]起始地址和大小！ __attribute__((__aligned__(64))) struct obj_1_ ccc[8]; //←┤ __attribute__((__aligned__(64))) struct obj_n_ ddd[8]; //←┘ 四、关于__attribute__(())的__section__(x)参数被【编译器】与【链接器】优化的问题： 【section】修饰的数据段会被【编译器】和【链接器】这两道关卡优化掉，需要增加特别语句加以防止！【used、unused】只针对【编译器】而言，但对于【链接器】无效，也就是说链接器的【-Wl,–gc-sections】参数还是会优化掉没使用的段，除非在【链接脚本】中使用【KEEP】语句特别指出的段才不会被优化掉！ //1.变量声明 __attribute__((__used__)) const uint8_t aaa __attribute__((__section__(\".init.001\"))); //增加__used__防止被[编译器]优化 __attribute__((__used__)) const uint8_t bbb __attribute__((__section__(\".init.002\"))); //增加__used__防止被[编译器]优化 //2.编译链接 gcc -Wl,--gc-sections -o hello hello.c /* -Wl,--gc-sections 会强制优化掉没使用的__section__（函数段/数据段）*/ //3.链接脚本 .text : { ............. . = ALIGN(4); KEEP(*(SORT(.init.*))) /* 使用 KEEP(*(SORT())) 防止被[链接器]优化 */ . = ALIGN(4); _etext = .; } \u003eFLASH ","date":"2021-06-26","objectID":"/20210626/:0:2","tags":["attribute"],"title":"attribute-un/used 编译属性-未用警告","uri":"/20210626/"},{"categories":["software"],"content":"介绍 attribute-weak 编译属性的使用","date":"2021-06-25","objectID":"/20210625/","tags":["attribute"],"title":"attribute-weak 编译属性-弱符号","uri":"/20210625/"},{"categories":["software"],"content":"简介 有为公司搭建通用软件工程（开发平台）的同学们都知道，公共代码部分往往需要编写一些默认的处理函数，当用户想使用自己编写的处理函数，只需编写同名函数就可以让编译器编译时自动实现将默认函数取代为用户函数。对于这类需求，GCC 的编译属性__attribute__((weak))为我们提供了解决方案。 更多的 attribute 编译属性： 《attribute-section 编译属性-数据拼接》 《attribute-aligned 编译属性-地址对齐》 《attribute-packed 编译属性-字节对齐》 《attribute-weak 编译属性-弱符号》 《attribute-un/used 编译属性-未用警告》 《attribute-at 编译属性-地址指定》 ","date":"2021-06-25","objectID":"/20210625/:0:1","tags":["attribute"],"title":"attribute-weak 编译属性-弱符号","uri":"/20210625/"},{"categories":["software"],"content":"使用 1、作用对象 __attribute__((weak))作用对象： 常用于函数。在函数实体前面加入此特定语法声明，则表明此函数为弱函数。 2、应用情景 例如搭建一个单片机通用应用工程时，我们一定要事先编写所有的默认中断处理函数，防止某些情形产生中断而无处理函数造成程序跑飞。当有编写同名的专用中断处理函数时，编译器就使用对应专用函数；当没有编写专用中函数时，编译器则使用默认函数。这样做的好处是公共代码独立统一，在同一平台下所有项目工程共用。例如：STM32 单片机 HAL 驱动库就是一个典型例子，它为我们编写好的所有中断处理函数，但当我们想编写自己中断处理函数时，只需要编写同名函数就可以取代 HAL 库的中断函数，非常方便。 3、编程语法 test_main.c含有默认的中断函数： #include \u003cstdio.h\u003e#include \u003cstdint.h\u003evoid test_irq(void); int main(int arg1, char *arg2[]) { test_irq(); //验证结果 } //这是默认的中断函数------- __attribute__((weak)) void test_irq(void) { printf(\"run: default irq func 1111111\"); } user_irq.c用户编写的中断函数： #include \u003cstdio.h\u003e#include \u003cstdint.h\u003e //用户编写的中断函数------- void test_irq(void) { printf(\"run: user's irq func 2222222\"); } 弱函数在应用中的两种表现： #【没加】用户编写的中断函数时的编译运行： gcc test_main.c -o test_main #编译 ./test_main.exe #运行 run: default irq func 1111111 #打印结果（弱函数被编译运行） #【加入】用户编写的中断函数时的编译运行： gcc test_main.c user_irq.c -o test_main #编译 ./test_main.exe #运行 run: user's irq func 2222222 #打印结果（弱函数被取代） 4、语法总结 一、关于__attribute__(())的参数名称，为了防止与其它对象出现同名影响，强烈建议在参数的前后都加上__两个下划线。 __attribute__((section(x))) 改为 __attribute__((__section__(x))) __attribute__((at(a))) 改为 __attribute__((__at__(a))) __attribute__((packed)) 改为 __attribute__((__packed__)) __attribute__((aligned(n))) 改为 __attribute__((__aligned__(n))) __attribute__((unused)) 改为 __attribute__((__unused__)) __attribute__((used)) 改为 __attribute__((__used__)) __attribute__((weak)) 改为 __attribute__((__weak__)) 二、关于__attribute__(())语句书写位置总体原则：书写到修饰对象名称的后面（★修饰其左边的单元体(非每个元素)，放到最前面即是修饰整体★），但考虑要跨编译平台使用，强烈建议使用宏定义并且按下面规则使用。 //【总体原则】+++++++++++++++++++ #define O2O_SECTION(x) __attribute__((__section__(x))) //数据拼接　（对象名称后明声明） #define O2O_AT(a) __attribute__((__at__(a))) //地址指定　（对象名称后明声明） #define O2O_PACKED __attribute__((__packed__)) //字节对齐　（对象名称后明声明，强烈建议改用 #pragma pack(push, 1) ... #pragma pack(pop) 的兼容性更好） #define O2O_ALIGN(n) __attribute__((__aligned__(n))) //地址对齐　（对象整体最前声明） #define O2O_UNUSED __attribute__((__unused__)) //未用不警告（对象整体最前声明） #define O2O_USED __attribute__((__used__)) //未用不优化（对象整体最前声明） #define O2O_WEAK __attribute__((__weak__)) //弱化对象　（对象整体最前声明） #define O2O_INLINE static __inline //内联函数　（对象整体最前声明，c/h文件中直接编写函数(体)，不能外部声明） 三、关于__attribute__(())的__aligned__(n)参数对【结构体类型】修饰的特殊表现（只是唯一的特殊个案）： typedef struct obj_1_ { uint16_t a; uint8_t b; }obj_1_t __attribute__((__aligned__(64))); //1.用于[单体]结构体类型的【起始地址】 typedef struct obj_n_ { uint16_t a; uint8_t b; }__attribute__((__aligned__(64))) obj_n_t; //2.用于结构体[组员]类型的【起始地址】和【大小】，也可用于单体结构体！备注：是组员非成员！ // -┬- obj_1_t aaaaaa; //1.影响[单体结构体]的起始地址对齐，不能用于数组 ├→ ●只是唯一的特殊个案● obj_n_t bbb[6]; //2.影响结构体[每个组员]的起始地址对齐和大小限制----------------------┘ //3.影响[数组整体]起始地址，但不影响[其它组员]起始地址和大小！ __attribute__((__aligned__(64))) struct obj_1_ ccc[8]; //←┤ __attribute__((__aligned__(64))) struct obj_n_ ddd[8]; //←┘ 四、关于__attribute__(())的__section__(x)参数被【编译器】与【链接器】优化的问题： 【section】修饰的数据段会被【编译器】和【链接器】这两道关卡优化掉，需要增加特别语句加以防止！【used、unused】只针对【编译器】而言，但对于【链接器】无效，也就是说链接器的【-Wl,–gc-sections】参数还是会优化掉没使用的段，除非在【链接脚本】中使用【KEEP】语句特别指出的段才不会被优化掉！ //1.变量声明 __attribute__((__used__)) const uint8_t aaa __attribute__((__section__(\".init.001\"))); //增加__used__防止被[编译器]优化 __attribute__((__used__)) const uint8_t bbb __attribute__((__section__(\".init.002\"))); //增加__used__防止被[编译器]优化 //2.编译链接 gcc -Wl,--gc-sections -o hello hello.c /* -Wl,--gc-sections 会强制优化掉没使用的__section__（函数段/数据段）*/ //3.链接脚本 .text : { ............. . = ALIGN(4); KEEP(*(SORT(.init.*))) /* 使用 KEEP(*(SORT())) 防止被[链接器]优化 */ . = ALIGN(4); _etext = .; } \u003eFLASH ","date":"2021-06-25","objectID":"/20210625/:0:2","tags":["attribute"],"title":"attribute-weak 编译属性-弱符号","uri":"/20210625/"},{"categories":["software"],"content":"介绍 attribute-packed 编译属性的使用","date":"2021-06-24","objectID":"/20210624/","tags":["attribute"],"title":"attribute-packed 编译属性-字节对齐","uri":"/20210624/"},{"categories":["software"],"content":"简介 对于嵌入式底层二进制通讯数据，往往需要取消处理器默认长度的数据对齐方式（例如：4 字节对齐），而是取用 1 字节对齐方式。对于这类需求，GCC 的编译属性__attribute__((packed))为我们提供了解决方案。另外：#pragma pack(push,1) #pragma pack(pop)则是一样效果的另一套方案。 更多的 attribute 编译属性： 《attribute-section 编译属性-数据拼接》 《attribute-aligned 编译属性-地址对齐》 《attribute-packed 编译属性-字节对齐》 《attribute-weak 编译属性-弱符号》 《attribute-un/used 编译属性-未用警告》 《attribute-at 编译属性-地址指定》 ","date":"2021-06-24","objectID":"/20210624/:0:1","tags":["attribute"],"title":"attribute-packed 编译属性-字节对齐","uri":"/20210624/"},{"categories":["software"],"content":"使用 1、作用对象 __attribute__((packed))作用对象： 作用于结构体中每个成员，其所有变量数据都是按照单字节方式对齐。 2、应用情景 在我们单片机的通讯中，一般都是这样定义通讯协议：第一字节为帧头，第二字节为数据长度，第三字节是命令……。对于很多刚入行的工程师基本上都是这样读写数据：使用单字节数组方式读写数据（例如：d[1] = 5）。这样的写法缺点很多，一是这种偏移量难理解其意义不利用阅读且容易出错，二是如果中间要插入参数则其后面所有偏移量都要修改，三是对于整型等这类数据访问很不方便（例如：u16 = (d[11]\u003c\u003c8) | d[10]）。其实我们可以将这组数据进行格式化，只需通过结构体定义这组数据，并且使用特定扩展语法强制结构体数据以单字节方式对齐，之后就可以非常方便地使用结构体方式对数据进行读写（例如：d.cmd = 1）。 3、编程语法 #include \u003cstdio.h\u003e#include \u003cstdint.h\u003eint main(int arg1, char *arg2[]) { //---------------------------------------------------------------------------------------------------- //方式1、__attribute__((packed)) //---------------------------------------------------------------------------------------------------- typedef struct data1_ { uint8_t head; //帧头 uint8_t len; //数据长度 uint8_t cmd; //命令 uint32_t d1; //数据1 uint16_t d2; //数据2 uint8_t checksum; //校验和 }__attribute__((packed)) data1_t; data1_t dd1; //////////////////// dd1.head = 1; //1字节 dd1.len = 7; //1字节 dd1.cmd = 123; //1字节 dd1.d1 = 987654321; //4字节 dd1.d2 = 65535; //2字节 dd1.checksum = 0; //1字节 printf(\"dd1.d1=%u\\n\", dd1.d1); //dd1.d1=987654321 printf(\"dd1.d2=%u\\n\", dd1.d2); //dd1.d2=65535 printf(\"sizeof(dd1)=%u\\n\", sizeof(dd1)); //sizeof(dd1)=10 printf(\"----------------\\n\"); //---------------- //---------------------------------------------------------------------------------------------------- //方式2、#pragma pack(push,1) #pragma pack(pop) //---------------------------------------------------------------------------------------------------- #pragma pack(push,1) //(push)与(pop)要配对, 可以嵌套; 1-\u003e1字节对齐, 其可 1,2,4,8,16 typedef struct data2_ //#pragma pack(push,1) 相当于两条语句：#pragma pack(push) #pragma pack(1) { uint8_t head; //帧头 uint8_t len; //数据长度 uint8_t cmd; //命令 uint32_t d1; //数据1 uint16_t d2; //数据2 uint8_t checksum; //校验和 }data2_t; #pragma pack(pop) data2_t dd2; //////////////////// dd2.head = 1; //1字节 dd2.len = 7; //1字节 dd2.cmd = 123; //1字节 dd2.d1 = 987654321; //4字节 dd2.d2 = 65535; //2字节 dd2.checksum = 0; //1字节 printf(\"dd2.d1=%u\\n\", dd2.d1); //dd2.d1=987654321 printf(\"dd2.d2=%u\\n\", dd2.d2); //dd2.d2=65535 printf(\"sizeof(dd2)=%u\\n\", sizeof(dd2)); //sizeof(dd2)=10 printf(\"----------------\\n\"); //---------------- } 4、语法总结 一、关于__attribute__(())的参数名称，为了防止与其它对象出现同名影响，强烈建议在参数的前后都加上__两个下划线。 __attribute__((section(x))) 改为 __attribute__((__section__(x))) __attribute__((at(a))) 改为 __attribute__((__at__(a))) __attribute__((packed)) 改为 __attribute__((__packed__)) __attribute__((aligned(n))) 改为 __attribute__((__aligned__(n))) __attribute__((unused)) 改为 __attribute__((__unused__)) __attribute__((used)) 改为 __attribute__((__used__)) __attribute__((weak)) 改为 __attribute__((__weak__)) 二、关于__attribute__(())语句书写位置总体原则：书写到修饰对象名称的后面（★修饰其左边的单元体(非每个元素)，放到最前面即是修饰整体★），但考虑要跨编译平台使用，强烈建议使用宏定义并且按下面规则使用。 //【总体原则】+++++++++++++++++++ #define O2O_SECTION(x) __attribute__((__section__(x))) //数据拼接　（对象名称后明声明） #define O2O_AT(a) __attribute__((__at__(a))) //地址指定　（对象名称后明声明） #define O2O_PACKED __attribute__((__packed__)) //字节对齐　（对象名称后明声明，强烈建议改用 #pragma pack(push, 1) ... #pragma pack(pop) 的兼容性更好） #define O2O_ALIGN(n) __attribute__((__aligned__(n))) //地址对齐　（对象整体最前声明） #define O2O_UNUSED __attribute__((__unused__)) //未用不警告（对象整体最前声明） #define O2O_USED __attribute__((__used__)) //未用不优化（对象整体最前声明） #define O2O_WEAK __attribute__((__weak__)) //弱化对象　（对象整体最前声明） #define O2O_INLINE static __inline //内联函数　（对象整体最前声明，c/h文件中直接编写函数(体)，不能外部声明） 三、关于__attribute__(())的__aligned__(n)参数对【结构体类型】修饰的特殊表现（只是唯一的特殊个案）： typedef struct obj_1_ { uint16_t a; uint8_t b; }obj_1_t __attribute__((__aligned__(64))); //1.用于[单体]结构体类型的【起始地址】 typedef struct obj_n_ { uint16_t a; uint8_t b; }__attribute__((__aligned__(64))) obj_n_t; //2.用于结构体[组员]类型的【起始地址】和【大小】，也可用于单体结构体！备注：是组员非成员！ // -┬- obj_1_t aaaaaa; //1.影响[单体结构体]的起始地址对齐，不能用于数组 ├→ ●只是唯一的特殊个案● obj_n_t bbb[6]; //2.影响结构体[每个组员]的起始地址对齐和大小限制----------------------┘ //3.影响[数组整体]起始地址，但不影响[其它组员]起始地址和大小！ __attribute__((__aligned__(64))) struct obj_1_ ccc[8]; //←┤ __attribute__((__aligned__(64))) struct obj_n_ ddd[8]; //←┘ 四、关于__attribute__(())的__sec","date":"2021-06-24","objectID":"/20210624/:0:2","tags":["attribute"],"title":"attribute-packed 编译属性-字节对齐","uri":"/20210624/"},{"categories":["software"],"content":"介绍 attribute-aligned 编译属性的使用","date":"2021-06-23","objectID":"/20210623/","tags":["attribute"],"title":"attribute-aligned 编译属性-地址对齐","uri":"/20210623/"},{"categories":["software"],"content":"简介 对于一些硬件控制器或者是操作系统堆栈，要求数据的起始地址必须是处理器位长的倍数关系，如果不是倍数关系则会影响运行速率甚至硬件会运行出错。对于这类需求，GCC 的编译属性__attribute__((aligned(n)))为我们提供了解决方案。 更多的 attribute 编译属性： 《attribute-section 编译属性-数据拼接》 《attribute-aligned 编译属性-地址对齐》 《attribute-packed 编译属性-字节对齐》 《attribute-weak 编译属性-弱符号》 《attribute-un/used 编译属性-未用警告》 《attribute-at 编译属性-地址指定》 ","date":"2021-06-23","objectID":"/20210623/:0:1","tags":["attribute"],"title":"attribute-aligned 编译属性-地址对齐","uri":"/20210623/"},{"categories":["software"],"content":"使用 1、作用对象 __attribute__((aligned(n)))作用对象： 1、单个标准数据类型变量的起始地址。 2、整个标准数据类型数组的起始地址。 3、结构体的起始地址，还可以通过特定语法影响其大小（此特性可以影响结构体数组的组员起始地址，注意是组员非成员！）。 总结：主要作用是影响变量的起始地址，对于结构体还可以通过特定语法影响其大小。 2、编程语法 #include \u003cstdio.h\u003e#include \u003cstdint.h\u003eint main(int arg1, char *arg2[]) { //---------------------------------------------------------------------------------------------------- //1、[单个]标准数据类型[变量]的【起始地址】对齐： //---------------------------------------------------------------------------------------------------- typedef uint8_t my_uint16addr64_t __attribute__((aligned(64))); //自定义标准数据类型的【起始地址】对齐 typedef uint8_t __attribute__((aligned(64))) my_uint16addr64_t; //同上 my_uint16addr64_t a; // my_uint16addr64_t a5[5]; 非法语句!!!!!!!!!! // uint8_t a5[5] __attribute__((aligned(64))); printf(\"\u0026a=%u\\n\", \u0026a); //\u0026a=4294953984 --\u003e 起始地址整除[64] printf(\"sizeof(a)=%u\\n\", sizeof(a)); //sizeof(a)=1 --\u003e 还是原标准数据类型的大小!! printf(\"----------------\\n\"); //---------------- //---------------------------------------------------------------------------------------------------- //2、[整个]标准数据类型[数组]的【起始地址】对齐： //---------------------------------------------------------------------------------------------------- uint8_t a5[5] __attribute__((aligned(64))); //作用对象：整个数组 uint8_t __attribute__((aligned(64))) a5[5]; //作用对象：整个数组（同上） __attribute__((aligned(64))) uint8_t a5[5]; //作用对象：整个数组（同上） //__attribute__((aligned(64))) (uint8_t a5[5]); //作用对象：非法!!!! //(__attribute__((aligned(64))) uint8_t) a5[5]; //作用对象：非法!!!! //uint8_t (__attribute__((aligned(64))) a5[5]); //作用对象：非法!!!! //在数组声明中，只要括号括住两个语段，__attribute__((aligned(n)))的作用对象都为非法!!! printf(\"\u0026a5=%u\\n\", \u0026a5); //\u0026a5=4294953856 --\u003e 起始地址整除[64] printf(\"sizeof(a5)=%u\\n\", sizeof(a5)); //sizeof(a5)=5 --\u003e 还是原标准数据类型的大小!! printf(\"----------------\\n\"); //---------------- //---------------------------------------------------------------------------------------------------- //3、[结构体]的【起始地址】对齐（通过特定语法可影响结构体【大小】） //---------------------------------------------------------------------------------------------------- typedef struct objx_ { uint16_t a; uint8_t b; }__attribute__((aligned(64))) objx_t; //此写法可影响结构体类型的【起始地址】和【大小】，或者是结构体数组的组员(结构体) typedef struct objy_ { uint16_t a; uint8_t b; }objy_t __attribute__((aligned(64))); //此写法只影响结构体类型的【起始地址】，但不影响其大小，不能用于结构体数组-\u003e解决方法请看[z5] objx_t x5[5]; objx_t x; objy_t y; // objx_t y5[5]; 非法语句!!!!!!!!!! __attribute__((aligned(64))) struct objy_ z5[5]; //实际就是第【2】的只影响数组的【起始地址】对齐 printf(\"\u0026x5=%u\\n\", \u0026x5); //\u0026x5=4294953408 --\u003e 起始地址整除[64] printf(\"\u0026x=%u\\n\", \u0026x); //\u0026x=4294953728 --\u003e 起始地址整除[64] printf(\"\u0026y=%u\\n\", \u0026y); //\u0026y=4294953920 --\u003e 起始地址整除[64] printf(\"\u0026z5=%u\\n\", \u0026z5); //\u0026z5=4294953792 --\u003e 起始地址整除[64] printf(\"sizeof(z5[0])=%u\\n\", sizeof(z5[0])); //sizeof(z5[0])=4 --\u003e 单个结构体大小为[4]字节 printf(\"sizeof(x5[0])=%u\\n\", sizeof(x5[0])); //sizeof(x5[0])=64 --\u003e 单个结构体大小为[64]字节 printf(\"sizeof(x5)=%u\\n\", sizeof(x5)); //sizeof(x5)=320 --\u003e 结构体数组总大小[320]字节 printf(\"sizeof(x)=%u\\n\", sizeof(x)); //sizeof(x)=64 --\u003e 此个结构体大小为[64]字节 printf(\"sizeof(y)=%u\\n\", sizeof(y)); //sizeof(y)=4 --\u003e 此个结构体大小为[4]字节 printf(\"----------------\\n\"); //---------------- } 3、语法总结 一、关于__attribute__(())的参数名称，为了防止与其它对象出现同名影响，强烈建议在参数的前后都加上__两个下划线。 __attribute__((section(x))) 改为 __attribute__((__section__(x))) __attribute__((at(a))) 改为 __attribute__((__at__(a))) __attribute__((packed)) 改为 __attribute__((__packed__)) __attribute__((aligned(n))) 改为 __attribute__((__aligned__(n))) __attribute__((unused)) 改为 __attribute__((__unused__)) __attribute__((used)) 改为 __attribute__((__used__)) __attribute__((weak)) 改为 __attribute__((__weak__)) 二、关于__attribute__(())语句书写位置总体原则：书写到修饰对象名称的后面（★修饰其左边的单元体(非每个元素)，放到最前面即是修饰整体★），但考虑要跨编译平台使用，强烈建议使用宏定义并且按下面规则使用。 //【总体原则】+++++++++++++++++++ #define O2O_SECTION(x) __attribute__((__section__(x))) //数据拼接　（对象名称后明声明） #define O2O_AT(a) __attribute__((__at__(a))) //地址指定　（对象名称后明声明） #define O2O_PACKED __attribute__((__packed__)) //字节对齐　（对象名称后明声明，强烈建议改用 #pragma pack(push, 1) ... #pragma pack(pop) 的兼容性更好） #define O2O_ALIGN(n) __attribute__((__aligned__(n))) //地址对齐　（对象整体最前声明） #defi","date":"2021-06-23","objectID":"/20210623/:0:2","tags":["attribute"],"title":"attribute-aligned 编译属性-地址对齐","uri":"/20210623/"},{"categories":["software"],"content":"介绍 attribute-section 编译属性的使用","date":"2021-06-22","objectID":"/20210622/","tags":["attribute"],"title":"attribute-section 编译属性-数据拼接","uri":"/20210622/"},{"categories":["software"],"content":"简介 数据拼接就是把分散的数据（全局/只读），通过编译器的编译链接把它们拼接起来放到一段连续的空间内，本人简称为“串表”或叫“分段列表”。如果这些分散的数据都是同一类型，则这段数据就是数组，程序可实现快速访问。对于这类需求，GCC 的编译属性__attribute__((section(\"name\"))为我们提供了解决方案。 更多的 attribute 编译属性： 《attribute-section 编译属性-数据拼接》 《attribute-aligned 编译属性-地址对齐》 《attribute-packed 编译属性-字节对齐》 《attribute-weak 编译属性-弱符号》 《attribute-un/used 编译属性-未用警告》 《attribute-at 编译属性-地址指定》 ","date":"2021-06-22","objectID":"/20210622/:0:1","tags":["attribute"],"title":"attribute-section 编译属性-数据拼接","uri":"/20210622/"},{"categories":["software"],"content":"用途 数据拼接常用于设备启动时初始化各个模块（自动初始化机制），其中 linux 的 initcall 机制就是基于此原理实现的。下面对比介绍上电初始化的几种方式：调用方式、列表方式、串表方式。 1、调用方式 在main()函数最前在分别调用这些初始化函数，当新增一模块就必须在main()增加代码 ，这种方式与main()过于耦合。试想一下 linux 系统，少则几百多则上千上万个初始化函数放在一起，那是多么恐怖的事，而且 linux 核心源文件是不给程序员随便改动的，否则会影响系统稳定性。也就是说对于中大型工程这种方式不可取。 int main(void) { //每当增加模块初始化，都需在这里增加初始化函数 init_a(); init_b(); init_c(); while(1) { ... } } 2、列表方式 做一个数组列表，在列表加入这些初始化函数，main()的上电初始化时用for循环统一初始化，当新增一模块无须动代码，只需要在数组列表增加内容即可，这种方式比调用方式简洁方便很多。而且这个表格可以独立放到一个文件里，不但集中管理调用初始化函数，还有效阻隔核心代码不被程序员改动。由于集中管理，会存在一定可能性的误操作（如：误删别的模块初始化操作），与独立模块还是存在一定的耦合性。 typedef void (*func_t)(void); const func_t func_tab[] = { init_a, init_b, init_c }; //平时只需维护此列表 int main(void) { int i; for (i=0; i\u003csizeof(func_tab)/sizeof(func_tab[0]); i++) { (*(func_tab[i]))(); } while(1) { ... } } 3、串表方式 在main()的上电初始化时使用for循环调用事先已预设好的串表，串表内容（组员）分散在各种模块中，依靠编译器的编译链接把它们存到这个串表里（无需人工添加）。 关键字-属性__attribute__ /ə’trɪbjuːt/ 关键字-分段section /’sekʃn/ 语法：__attribute__((used, section(\".name.\" \"tail\"))) .name. 为分段名称，同名分段数据存放到同一段连接的空间内。 tail 为分段名称后缀，先由它决定数据先后顺序，再由代码编译先后顺序决定。 used 向编译器说明这段代码即使没使用也不能优化掉，不能产生警告； 而 unused 则是表示该函数或变量可能不使用，编译器不要产生警告信息。 特别说明：section修饰的数据段会被编译器和链接器这两道关卡优化掉，需要增加特别语句加以防止！used、unused 只针对编译器而言，但对于链接器无效，也就是说链接器的--gc-sections还是会优化掉没使用的段，除非在链接脚本中使用KEEP语句特别指的段才不会被优化掉！关于链接脚本的更多知识，请移步《linux-STM32F开发㈠-makefile 构建与使用》 主程序：main.h //---定义串表--- typedef void (*p_init_fun_t)(void); struct init_fun_tab { p_init_func_t pfun; //初始函数(指针) const uint8_t *name; //函数名称(指针) }; // 属性关键字 分段关键字 分段名称 分段名称后缀 // +-----+-----+ +----+----+ +---+---+ +-+-+ #define INITSECTION(level) __attribute__((used, __section__(\".init_fn.\" level))) #define INIT_FRONT_EXPORT(func,name) INITSECTION(\"0.front\") const struct init_fun_tab init_fn_##func = {func, name} //串表头 #define INIT_TABLE_EXPORT(func,name) INITSECTION(\"1\" ) const struct init_fun_tab init_fn_##func = {func, name} #define INIT_LIMIT_EXPORT(func,name) INITSECTION(\"1.limit\") const struct init_fun_tab init_fn_##func = {func, name} //串表尾 // +---------+-------+ +----------------------------+------------------------+ // 串表宏 一个表员(结构体)数据 主程序：main.c //---调用串表--- void tab_front(void) {} INIT_FRONT_EXPORT(tab_front, \"tab_front()\"); //串表头 void tab_limit(void) {} INIT_LIMIT_EXPORT(tab_limit, \"tab_limit()\"); //串表尾 int main(void) { const struct init_fun_tab *p_init; //执行串表（由编译器维护列表内容） for (p_init=\u0026init_fn_tab_front+1; p_init\u003c\u0026init_fn_tab_limit; p_init++) { printf(\"run:%s\\r\\n\", p_init-\u003ename); (*(p_init-\u003epfun))(); } while(1) { ... } } 模块a： //---加入串表--- include \"main.h\" void init_a(void) { printf(\"init_a code\\r\\n\"); }//加入串表 INIT_TABLE_EXPORT(init_a, \"init_a()\"); //告知编译器将函数地址加入到串表 模块b： //---加入串表--- include \"main.h\" void init_b(void) { printf(\"init_b code\\r\\n\"); }//加入串表 INIT_TABLE_EXPORT(init_b, \"init_b()\"); //告知编译器将函数地址加入到串表 main.c写好后，就不会改动，如果模块想在main.c完成初始化工作，只需在其初始化函数后面加入INIT_TABLE_EXPORT()宏，编译器编译时就可以通过此宏知道将函数指针加入到main.c的初始化列表上。从代码上看，模块与模块之间没有任何的函数调用关系，高质量实现高内聚性低耦合度。 4、作用对象 __attribute__((section(x)))作用对象： 主要针对只读变量。 5、语法总结 一、关于__attribute__(())的参数名称，为了防止与其它对象出现同名影响，强烈建议在参数的前后都加上__两个下划线。 __attribute__((section(x))) 改为 __attribute__((__section__(x))) __attribute__((at(a))) 改为 __attribute__((__at__(a))) __attribute__((packed)) 改为 __attribute__((__packed__)) __attribute__((aligned(n))) 改为 __attribute__((__aligned__(n))) __attribute__((unused)) 改为 __attribute__((__unused__)) __attribute__((used)) 改为 __attribute__((__used__)) __attribute__((weak)) 改为 __attribute__((__weak__)) 二、关于__attribute__(())语句书写位置总体原则：书写到修饰对象名称的后面（★修饰其左边的单元体(非每个元素)，放到最前面即是修饰整体★），但考虑要跨编译平台使用，强烈建议使用宏定义并且按下面规则使用。 //【总体原则】+++++++++++++++++++ #define O2O_SECTION(x) __attribute__((__section__(x))) //数据拼接　（对象名称后明声明） #define O2O_AT(a) __attribute__((__at__(a))) //地址指定　（对象名称后明声明） #define O2O_PACKED __attribute__((__packed__)) //字节对齐　（对象名称后明声明，强烈建议改用 #pragma pack(push, 1) ... #pragma pack(pop) 的兼容性更好） #define O2O_ALIGN(n) __attribute__((__aligned__(n))) //地址对齐　（对象整体最前声明） #define O2O_UNUSED __attribute__((__unused__)) //未用不警告（对象整体最前声明） #define O2O_USED __attribute__((__used__)) //未用不优化（对象整体最前声明） #","date":"2021-06-22","objectID":"/20210622/:0:2","tags":["attribute"],"title":"attribute-section 编译属性-数据拼接","uri":"/20210622/"},{"categories":["software"],"content":"扩展 数据拼接除了可以用在初始化上，还可以应用于很多场合，只要和列表有关的都有应用的可能性。 1、回调串表 本人编写独立模块时，喜欢通过回调函数的方式来通知其它模块，而且回调函数做成列表，即使用列表触发通知多个第三方模块。拿按键模块作为示例，当检测到有按键动作时，调用回调列表触发【界面模块】和【恢复出厂初始化模块】执行相应动作。 按键模块：key.h typedef void (*p_key_fun_t)(uint8_t key, uint8_t action, uint32_t time); struct key_fun_tab { p_key_func_t pfun; //回调函数(指针) }; // 属性关键字 分段关键字 分段名称 分段名称后缀 // +-----+-----+ +----+----+ +--+--+ +-+-+ #define KEYSECTION(level) __attribute__((used, __section__(\".key_fn.\" level))) #define KEY_FRONT_EXPORT(func) KEYSECTION(\"0.front\") const struct key_fun_tab key_fn_##func = {func} //串表头 #define KEY_TABLE_EXPORT(func) KEYSECTION(\"1\" ) const struct key_fun_tab key_fn_##func = {func} #define KEY_LIMIT_EXPORT(func) KEYSECTION(\"1.limit\") const struct key_fun_tab key_fn_##func = {func} //串表尾 // +---------+-------+ +---------------------+---------------------+ // 串表宏 一个表员(结构体)数据 按键模块：key.c void ktab_front(uint8_t key, uint8_t action, uint32_t time) {} void ktab_limit(uint8_t key, uint8_t action, uint32_t time) {} KEY_FRONT_EXPORT(ktab_front); //串表头 KEY_LIMIT_EXPORT(ktab_limit); //串表尾 void key_scan(void) { ... const struct key_fun_tab *p_key; //按键有动作时回调列表通知其它模块（由编译器维护列表内容） for (p_key=\u0026key_fn_ktab_front+1; p_key\u003c\u0026key_fn_ktab_limit; p_key++) { (*(p_key-\u003epfun))(key, action, time); } ... } 界面模块： //---加入串表--- include \"key.h\" void lcd_key_callback(uint8_t key, uint8_t action, uint32_t time) { if ((key \u003e= KEYNO_K1) \u0026\u0026 (key \u003c= KEYNO_K4)) { key -= KEYNO_K1; if ((action == KEYAT_1CLICK/*单击*/) || (action == KEYAT_2CLICK/*双击*/)) { if (time == 0) /*短按,非长按*/ { ....//收到按键单/双击动作 } } } }//加入串表 KEY_TABLE_EXPORT(lcd_key_callback); //告知编译器将函数地址加入到串表 恢复出厂初始化模块： //---加入串表--- include \"key.h\" void frst_key_callback(uint8_t key, uint8_t action, uint32_t time) { if (key == KEYNO_FRST) { if (action == KEYAT_1CLICK/*单击*/) { if (time == 5000) /*长按5秒*/ { ....//收到按键长按5秒动作 } } } }//加入串表 KEY_TABLE_EXPORT(frst_key_callback); //告知编译器将函数地址加入到串表 ","date":"2021-06-22","objectID":"/20210622/:0:3","tags":["attribute"],"title":"attribute-section 编译属性-数据拼接","uri":"/20210622/"},{"categories":["linux"],"content":"linux 中文输入工具的安装与使用","date":"2021-06-17","objectID":"/20210617/","tags":["输入法","linux 工具/应用"],"title":"linux 中文输入工具","uri":"/20210617/"},{"categories":["linux"],"content":"输入法简介 在 linux 系统下，我们必然要进行文本编辑，必然要输入中文，必然使用到输入法，中国常用的输入法有五笔和拼音。linux 系统文字输入包含两部分：输入法框架（系统）、输入法引擎（五笔）。因为输入法需要把文字显示出来，所以需要我们第一件事就是安装语言包。下面将介绍中文输入法的安装方法： ","date":"2021-06-17","objectID":"/20210617/:0:1","tags":["输入法","linux 工具/应用"],"title":"linux 中文输入工具","uri":"/20210617/"},{"categories":["linux"],"content":"Ubuntu 平台 1、语言包的安装 输入法得出来的只是文字编码，要把文字显示出来，则要调用系统的语言包（例如：简体中文语音包、日文语音包等），所以首先需要我们在系统安装语言包。 安装语言包：System Settings → Language Support → Language → Install/Remove Languages → 勾选 Chine(simplified) → Apply 备注：不想基于界面安装，可用如下命令安装： sudo apt install language-pack-zh-hans 备注：Ubuntu20 配置界面则为 2、输入法的安装 要想输入非英文，则需要安装另一个输入架构：IBus (“Intelligent Input Bus”) 是一个输入法框架，一个输入非英语字符的系统。 有了框架，还需要具体的输入法引擎，例如：中文引擎之ibus-pinyin(拼音) ibus-table-wubi(五笔)，日文引擎之ibus-anthy等。 除了 IBus，还有 Fcitx（Free Chinese Input Toy for X）、Fcitx5输入法框架、基于 Fcitx 框架的搜狗输入法的安装，具体请上网了解。 IBus介绍 sudo apt-get install ibus ibus-clutter ibus-gtk ibus-gtk3 ibus-qt4 #安装IBus框架 im-config -s ibus #启用IBus框架 sudo apt-get install ibus-table-wubi #安装五笔引擎 sudo apt-get install ibus-pinyin #安装拼音引擎 （根据实际决定是否安装） sudo apt-get install ibus-googlepinyin #安装谷歌拼音引擎（根据实际决定是否安装） sudo apt-get install ibus-sunpinyin #安装sun拼音引擎 （根据实际决定是否安装） killall ibus-daemon #关闭IBus守护进程 ibus-daemon -drx #打开IBus守护进程 以及重启系统或者注销当前账户 3、输入法的配置 配置系统使用 IBus 输入法系统和具体输入法，然后设置系统显示输入法图标、设置转入法切换快速键等。 选择输入法系统：System Settings → Language Support → Keyboard input method system → 勾选IBus 添加具体输入法：System Settings → Text Entry → + → Chinese(....) → Add添加输入法，勾选 Show current input source in the menu bar，则会在系统界面右上角显示输入法切换图标。 备注：Ubuntu20 配置界面则为 sudo ibus-setup #设置ibus框架（此步貌似不用，input method → 貌似同上面重复操作） ","date":"2021-06-17","objectID":"/20210617/:0:2","tags":["输入法","linux 工具/应用"],"title":"linux 中文输入工具","uri":"/20210617/"},{"categories":["linux"],"content":"linux 网络文件系统 nfs 的安装与使用","date":"2021-06-17","objectID":"/20210620/","tags":["NFS","linux 工具/应用"],"title":"linux 网络文件系统 nfs","uri":"/20210620/"},{"categories":["linux"],"content":"NFS 的简介 NFS 就是 Network File System 的缩写，即网络文件系统，它最大的功能就是可以通过网络，让不同的机器、不同的操作系统可以共享彼此的文件。nfs 服务端相当于远程存储器，客户端像挂载 U 盘一样使用它。 网文： Ubuntu16.04安装nfs的两种方式 ","date":"2021-06-17","objectID":"/20210620/:0:1","tags":["NFS","linux 工具/应用"],"title":"linux 网络文件系统 nfs","uri":"/20210620/"},{"categories":["linux"],"content":"Ubuntu 平台 1、nfs 的安装 nfs 需要 RPC 服务，事先要安装 RPC 服务程序。RPC 服务器的 portmap 进程维护着一张 RPC 程序号到 Internet 端口号之间的映射表，它的字段包括程序号、版本号、所用协议、端口号和服务名，portmap 进程通过这张映射表来提供程序号-端口号之间的转化功能。 sudo apt-get install portmap #依赖的RPC服务安装 sudo apt-get install nfs-kernel-server #nfs服务端安装 sudo apt-get install nfs-common #nfs客户端安装 2、nfs 的配置 我们要共享服务端哪个文件夹，需要通过配置文件进行配置，例如配置是否可读写、是否指定客户端访问等。 sudo gedit /etc/exports #打开exports配置文件（具体配置内容请看下面介绍） sudo chmod 777 /home/xiaomi/nfs #修改文件(夹)权限,确保其权限正确性（事先创建的文件夹） #在exports配置文件加入内容： /home/xiaomi/nfs *(rw,sync,no_root_squash) #/home/xiaomi/nfs共享出去,所有客户端都可访问和读写 #[rw ] 读/写权限（如果ro:只读）； #[sync ] 数据同步写入内存和硬盘； #[no_root_squash ] NFS服务器共享目录用户的属性； #[no_subtree_check] 不检查父目录的权限。 #也可共享给指定网段的客户端: #/home/xiaomi/nfs 192.168.2.*(rw,sync,no_root_squash) 3、nfs 的开启 nfs 服务端安装后，需要我们手动启动运行，否则客户端无法连接服务端。 如果开启了系统防火墙（Firewall）将可能影响 nfs 服务，请关闭它（需要重启设备）： ● sudo ufw disable #关闭防火墙 ● sudo ufw status #查看防火墙状态 sudo /etc/init.d/portmap restart #重启RPC服务 sudo /etc/init.d/nfs-kernel-server restart #重启nfs服务 showmount -e #查看共享目录 #其它常用命令： sudo /etc/init.d/nfs-kernel-server start #启动nfs服务 sudo /etc/init.d/nfs-kernel-server stop #停止nfs服务 sudo /etc/init.d/nfs-kernel-server restart #重启nfs服务 sudo /etc/init.d/nfs-kernel-server status #查看nfs服务当前状态 #如果运行中: nfsd running 4、nfs 的挂载 与挂载 U 盘一样挂载即可，成功后所有操作与本地操作完全一样。当不需要操作时，取消挂载。 sudo mount -t nfs -o nolock 192.168.2.28:/home/xiaomi/nfs /mnt #将另一台机的/home/xiaomi/nfs目录挂载到本机/mnt目录下 #[-t nfs ] UNIX(LINUX) 文件网络共享 #[-o nolock] 不使用NFS文件锁(原因:很多嵌入式设备的根文件系统中不带portmap) umount /mnt #取消挂载（注：要在其它路径操作，否则系统提示忙不能取消挂载） ","date":"2021-06-17","objectID":"/20210620/:0:2","tags":["NFS","linux 工具/应用"],"title":"linux 网络文件系统 nfs","uri":"/20210620/"},{"categories":["linux"],"content":"linux 网络终端工具 ssh 的安装与使用","date":"2021-06-17","objectID":"/20210619/","tags":["SSH","linux 工具/应用"],"title":"linux 网络终端工具 ssh","uri":"/20210619/"},{"categories":["linux"],"content":"SSH 的简介 SSH 为 Secure Shell 的缩写，由 IETF 的网络工作小组（Network Working Group）所制定。SSH 为建立在应用层和传输层基础上的安全协议，而传统的网络服务程序（如：FTP、POP 和 Telnet） 则是不安全的。因为它们在网络上用明文传送数据、用户帐号和用户口令，很容易受到中间人（man-in-the-middle）攻击方式的攻击。我们调试 ARM 开发板时，常用串口作为调试终端；当使用 SSH 连接时，就是网络调试终端机（开发板为服务端，电脑为客户端），如果开发板有广域网 IP，则可以实现远程网络调试（远程网络终端）。 网文：SSH的安装及使用 ","date":"2021-06-17","objectID":"/20210619/:0:1","tags":["SSH","linux 工具/应用"],"title":"linux 网络终端工具 ssh","uri":"/20210619/"},{"categories":["linux"],"content":"Ubuntu 平台 1、ssh 的安装 SSH 包含服务端和客户端，原版 SSH 服务端是要收费的，因为受版权和加密算法的限制，现在很多人都转而使用 OpenSSH。OpenSSH 是 SSH 的替代软件，而且是免费的。Ubuntu 缺省已经安装了客户端（如果没安装则参考下面方法安装），但服务端需要我们手动安装。 #SSH客户端安装 sudo apt-get install ssh #安装SSH客户端（其服务端非免费） sudo apt-get install openssh-client #安装SSH客户端（OpenSSH是SSH的替代软件，而且是免费的，推荐使用） #SSH服务端安装 sudo apt-get install openssh-server #安装SSH服务端 2、ssh 的配置 一般情况下，不需要修改相关配置，如果需要开放或关闭一些权限，则就需要我们修改 SSH 服务端相关配置内容。 sudo gedit /etc/ssh/sshd_config #配置SSH服务端（常规配置内容请看下面介绍） #常规配置内容 Port 22 #连接端口 （默认：22） Protocol 2,1　#如果删除“,1”，只允许 SSH2 方式的连接 ServerKeyBits 1024 #定义服务端密匙的位数（默认：1024） PermitRootLogin prohibit-password #登记方式 （yes:允许root用户登录） PermitEmptyPasswords no　#禁止空密码进行登录 （默认：no ） PasswordAuthentication yes #允许密码方式的登录 （默认：yes） PubkeyAuthentication yes #允许ssh的公钥登录验证（默认：yes） RSAAuthentication yes #允许RSA登录验证 （默认：yes） 3、ssh 的开启 SSH 服务端安装后，需要我们手动启动运行，否则客户端无法连接服务端。 如果开启了系统防火墙（Firewall）将可能影响 SSH 服务，请关闭它（需要重启设备）： ● sudo ufw disable #关闭防火墙 ● sudo ufw status #查看防火墙状态 sudo /etc/init.d/ssh start #启动SSH服务端 ps -e | grep sshd #查看SSH服务端进程（如果有[sshd]表明启动成功） #其它常用命令： sudo /etc/init.d/ssh start #启动SSH服务端 sudo /etc/init.d/ssh restart #重启SSH服务端（例如修改配置后需要重启一下） sudo /etc/init.d/ssh stop #关闭SSH服务端 #或者 sudo service ssh start #启动SSH服务端 sudo service ssh restart #重启SSH服务端（例如修改配置后需要重启一下） sudo service ssh stop #关闭SSH服务端 #开机自动启动ssh服务的方法： sudo gedit /etc/rc.local #打开启动文件，在文件中加入: /etc/init.d/ssh start 更多开机启动知识： 1、Linux系统中设置开机自动运行的两种方法 2、linux设置开机启动项两种方式 4、ssh 的登录 SSH 登录主要有两方式（注：由服务端配置决定），一是使用账号及密码登陆，二是使用秘钥文件登陆。 关于 SSH 秘钥有两个文件：id_rsa（私钥 private key）和 id_rsa.pub（公钥 public key）。公钥相当于锁，私钥相当于钥匙，要想做到 SSH 免密登录，我们要先将锁装到服务器，然后客户端就可以利用这个钥匙开锁了。即是服务器装锁（公钥），客户端拿钥匙（私钥）。 在创建秘钥中，先提示存储路径再要求设置私钥密码，此密钥锁码表示在使用私钥时必须输入，这样就可以保护私钥不被盗用。当然，也可以留空，实现无密码登录（注：个人使用一般是无密码登录）。 在 win 系统下的 SecureCRT 终端机软件如何使用私钥登录 SSH，配置：选项 → 会话选项 → 连接/SSH2 → 右窗口选择公钥 → 属性，在打开窗口的使用身份或证书文件加入之前制作的私钥文件（如：D:\\Downloads\\id_rsa）。（如图）。 #账号密码登陆 ssh root@192.168.1.20 #SSH客户端使用root超级用户登录（注：需要服务端开启权限） ssh xiaomi@192.168.1.20 #SSH客户端使用账号为xiaomi登录（之后按提示输入密码即可） ssh -p 1234 xiaomi@192.168.1.20 #SSH客户端使用指定端口1234及账号xiaomi登录 exit #SSH客户端登出 #秘钥文件登陆 -\u003e 制作密钥对（本例在服务器上制作） ssh-keygen #创建SSH默认RSA秘钥（弹出的提示全都回车确认即可，秘钥存储路径在弹出信息有指出） ssh-keygen -t rsa #创建SSH指定RSA秘钥（在用户的.ssh目录下发现id_rsa,id_rsa.pub就是创建的秘钥） #秘钥文件登陆 -\u003e 在服务器上安装公钥 cd ~/.ssh #进入秘钥存储路径 cat id_rsa.pub \u003e\u003e authorized_keys #在服务器上安装公钥（authorized /ˈɔːθəraɪzd/ 经授权的） chmod 600 authorized_keys #修改文件(夹)权限,确保其权限正确性 chmod 700 ~/.ssh #修改文件(夹)权限,确保其权限正确性 #秘钥文件登陆 -\u003e（本例在服务器上使用另一个终端机作为客户端登录） ssh -i ~/.ssh/id_rsa xiaomi@192.168.1.20 #SSH客户端使用秘钥文件登陆（-i 指定秘钥文件） 参考网文： SecureCRT通过密钥进行SSH登录 5、ssh 的sftp功能 sftp 为 SSH 的一部分，我们可以使用它来实现服务端与客户端之间传输文件。与 SSH 一样，使用 sftp 客户端登录服务端（不要在 SSH 客户端里直接使用命令 sftp 登录服务端，否则就是本地与远程设备都是服务端了）。在 win 系统下如何在 SecureCRT 终端机软件打开 sftp 服务？首先使用 SSH 建立连接后，配置：选项 → 会话选项 → 连接/SSH2/SFTP标签页 → 右窗口配置本地目录与远程目录，然后右键点击 SSH 终端窗口标签 → 连接SFTP标签页，即可打开 SFTP 终端机。（如图） sftp -oPort=22 xiaomi@192.168.1.20 #sftp客户端登录服务端（端口:22, 账号:xiaomi, IP:192.168.1.20） put /etc/md5.c /tmp #sftp客户端上传文件： 客户端 /etc/md5.c -\u003e 服务端 /tmp（路径） get /etc/md5.c /home/omd #sftp客户端下载文件： 服务端 /etc/md5.c -\u003e 客户端 /home/omd（路径） put -r /etc/hosts /tmp #sftp客户端上传文件夹：客户端 /etc/hosts -\u003e 服务端 /tmp get -r /etc/hosts /home/omd #sftp客户端下载文件夹：服务端 /etc/hosts -\u003e 客户端 /home/omd ls #sftp客户端查看远程目录文件 lls #sftp客户端查看本地目录文件 cd abc #sftp客户端进入远程目录路径abc lcd abc #sftp客户端改变本地目录路径abc pwd #sftp客户端查看远程所在路径 lpwd #sftp客户端查看本地所在路径 mkdir abc #sftp客户端创建远程文件夹 lmkdir abc #sftp客户端创建本地文件夹 quit #sftp客户端登出 发现问题： 实际使用中发现get -r下载文件夹出现有些文件多了些回车符，不明是什么原因。 无法下载隐藏文件(夹)，例如：git 仓库文件夹.git 解决方法： 目前想到的解决办法，就是使用tar压缩文件夹，再下载压缩文件。 ","date":"2021-06-17","objectID":"/20210619/:0:2","tags":["SSH","linux 工具/应用"],"title":"linux 网络终端工具 ssh","uri":"/20210619/"},{"categories":["linux"],"content":"linux 纯文本编辑器 vi 的基本使用","date":"2021-06-16","objectID":"/20210616/","tags":["vi/vim","linux 工具/应用"],"title":"linux 纯文本编辑器 vi","uri":"/20210616/"},{"categories":["linux"],"content":"前言 vi 编辑器是所有 Unix 及 Linux 系统下标准的文本编辑器，相当于 windows 系统中的记事本一样，它是我们使用 Linux 系统不能缺少的工具。而 vim 视为 vi 的升级版本，基础功能完全一样，只是一些功能的增强以及可用不同的颜色对文本关键字进行加亮，所以其更适合编写程序使用。 ","date":"2021-06-16","objectID":"/20210616/:0:1","tags":["vi/vim","linux 工具/应用"],"title":"linux 纯文本编辑器 vi","uri":"/20210616/"},{"categories":["linux"],"content":"简介 vi 工作模式 vi 编辑器是所有 Unix 及 Linux 系统下标准的纯文本编辑器。对 Unix 及 Linux 系统的任何版本，vi 编辑器是完全相同的。 官方网站：https://www.vim.org/ vi 分为三种工作状态： 1、命令模式（command mode）； 2、插入模式（insert mode）； 3、底行模式（last line mode）。 工作模式 应用情景 命令模式 控制屏幕光标的移动，对字符/字段/行的删除/复制/粘贴操作 插入模式 纯文本输入 底行模式 文件保存/退出 vi，设置编辑环境，查找/替换字符串操作 工作模式 切换方法 命令模式 按 i 进入【插入模式】； 按 : 进入【底行模式】。 插入模式 按ESC进入【命令模式】 底行模式 按ESC进入【命令模式】 ","date":"2021-06-16","objectID":"/20210616/:0:2","tags":["vi/vim","linux 工具/应用"],"title":"linux 纯文本编辑器 vi","uri":"/20210616/"},{"categories":["linux"],"content":"使用 vi 编辑文本 在终端机上输入vi命令即可进入 vi 编辑器编辑对应的文件，具体操作如下： sudo vi /home/root/read.txt # 使用 vi 编辑 read.txt 文档 #【命令模式】-------------------------------------- #『光标』+++++++ # [h ] 光标左移 # [j ] 光标下移 # [k ] 光标上移 # [l ] 光标右移 # [^ ] 光标移到行首 # [$ ] 光标移到行尾 # [5- ] 光标向上移动5行 # [5+ ] 光标向下移动5行 # [5G ] 光标移动到第5行 #『插入』+++++++ # [i ] 在光标前面插入【进入插入模式】 # [I ] 所在行最前插入【进入插入模式】 # [a ] 在光标后面插入【进入插入模式】 # [A ] 所在行最后插入【进入插入模式】 #『删除』+++++++ # [x ] 删除光标后[一个字符] # [X ] 删除光标前[一个字符] # [6x ] 删除光标后[六个字符] # [8X ] 删除光标前[八个字符] # [dd ] 删除光标所在的[一行] # [9dd] 删除光标所在行开始的[九行] #『复制』+++++++ # [yw ] 复制光标后[一段字段] (以空格或符号分隔开的字段!!) # [yy ] 复制光标所在的[一行] # [5yw] 复制光标后[五段字段] (以空格或符号分隔开的字段!!) # [9yy] 复制光标所在行开始的[九行] #『粘贴』+++++++ # [p ] 粘贴 #『撤消』+++++++ # [u ] 最后一次修改[撤消\u0026重做] # [Ctrl + r] 可多次[撤消] # #【底行模式】-------------------------------------- #『光标』+++++++ # [:5 ] 光标移动到第5行(要按回车执行,下面操作都一样) # [:set nu ] 显示行号 # [:set nonu] 不显示行号 #『查找』+++++++ # [/ab] 向下查找\"ab\"字符串，[n]继续查找下一个 # [?ab] 向上查找\"ab\"字符串，[n]继续查找上一个 #『替换』+++++++ # [: s/str1/str2/g] 所在行中所有 str1 字符串替换为 str2 # [:% s/str1/str2/g] 从[首行]到[最尾]行中所有\"str1\"字符串替换为\"str2\" # [:1,$ s/str1/str2/g] 第[01]行到[最尾]行中所有\"str1\"字符串替换为\"str2\" # [:6,20 s/str1/str2/g] 第[06]行到第[20]行中所有\"str1\"字符串替换为\"str2\" # [:.,20 s/str1/str2/g] [光标]行到第[20]行中所有\"str1\"字符串替换为\"str2\" # [:.,$-5 s/str1/str2/g] [光标]行到尾[05]行中所有\"str1\"字符串替换为\"str2\" #『退出』+++++++ └→g表示替换所有匹配项 # [:q!] 不保存退出 # [:wq] 保存退出 # [:w ] 保存文档(但不退出) # [:w filename] 另存为叫filename的文件(但不退出) 补充说明： vi 的查找与替换操作支持正则表达式，但是不支持限定操作（主要包括：{}、?、+、|），没能很好体现正则表达式优势。关于正则表达式相关语法知识，请移步《正则表达式语法》！ ","date":"2021-06-16","objectID":"/20210616/:0:3","tags":["vi/vim","linux 工具/应用"],"title":"linux 纯文本编辑器 vi","uri":"/20210616/"},{"categories":["software","MCU"],"content":"FreeRTOS 实时操作系统应用笔记","date":"2021-06-15","objectID":"/20210615/","tags":["FreeRTOS","RTOS"],"title":"FreeRTOS 实时操作系统应用笔记","uri":"/20210615/"},{"categories":["software","MCU"],"content":"前言 操作系统一般分为两种：实时操作系统 RTOS（Real Time Operating System）和 分时操作系统 TSOS（Time Sharing Operating System）。对于工控方面的编程，不是“裸跑”就是使用 RTOS 编程。本文是 FreeRTOS 操作系统 API 快速应用手册，也就是我们程序员Ctrl+C及Ctrl+V的编程过程。本文主要介绍动态 API 接口函数，静态 API 接口函数以后再补上。 ","date":"2021-06-15","objectID":"/20210615/:0:1","tags":["FreeRTOS","RTOS"],"title":"FreeRTOS 实时操作系统应用笔记","uri":"/20210615/"},{"categories":["software","MCU"],"content":"FreeRTOS 简介 点击展开内容 FreeRTOS 是 RTOS 系统的一种，由 Richard Barry 于 2003 年推出，其十分的小巧，可以在资源有限的微控制器中运行（当然，FreeRTOS 不仅局限于在微控制器中使用）。从文件数量上来看 FreeRTOS 要比 uC/OSII 和 uC/OSIII 小的多。FreeRTOS 操作系统是完全免费（MIT 开源许可证）的操作系统，具有源码公开、可移植、可裁减、调度策略灵活的特点，可以方便地移植到各种单片机上运行。FreeRTOS 的作者 Richard 于 2017 年加入了亚马逊（Amazon），并将 FreeRTOS 从 V9 版本升级至 V10 版本。同时，也推出了Amazon FreeRTOS，它基于 FreeRTOS 内核，并且增加了重要的 AWS 支持和 IoT 使用案例支持。例如，可轻松安全地将设备连接到云以及本地网络的软件库，这些库已经开源。所以，现在 FreeRTOS 将由亚马逊管理。 FreeRTOS 特点： FreeRTOS 的内核支持抢占式，合作式和时间片调度。 提供了一个用于低功耗的 Tickless 模式。 系统的组件在创建时可以选择动态或者静态的 RAM，比如任务、消息队列、信号量、软件定时器等等。 FreeRTOS-MPU 支持 Corex-M 系列中的 MPU 单元，如 STM32F429。 FreeRTOS 系统简单、小巧、易用，通常情况下内核占用 4k-9k 字节的空间。 高可移植性，代码主要 C 语言编写。 高效的软件定时器。 强大的跟踪执行功能。 堆栈溢出检测功能。 任务数量不限。 任务优先级不限。 官方 API 手册 FreeRTOS 官网 FreeRTOS 仓库 Amazon FreeRTOS 官网 Amazon FreeRTOS 仓库 FreeRTOS 基础篇 FreeRTOS 高级篇 ","date":"2021-06-15","objectID":"/20210615/:0:2","tags":["FreeRTOS","RTOS"],"title":"FreeRTOS 实时操作系统应用笔记","uri":"/20210615/"},{"categories":["software","MCU"],"content":"基本功能配置 点击展开内容 //主要功能头文件 #include \"FreeRTOSConfig.h\"#include \"FreeRTOS.h\"#include \"task.h\"#include \"queue.h\"#include \"semphr.h\"#include \"event_groups.h\" //基本功能配置 FreeRTOSConfig.h 网文：学 RTOS 从配置文件开始 ","date":"2021-06-15","objectID":"/20210615/:0:3","tags":["FreeRTOS","RTOS"],"title":"FreeRTOS 实时操作系统应用笔记","uri":"/20210615/"},{"categories":["software","MCU"],"content":"临界中断开关 点击展开内容 //配置 (FreeRTOSConfig.h) #define configMAX_SYSCALL_INTERRUPT_PRIORITY 191 //有一个临界区中断优先级（数值越小优先级越低） //线程中调用 taskENTER_CRITICAL(); //\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e taskEXIT_CRITICAL(); //\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c //中断中调用 UBaseType_t uxSavedInterruptStatus; uxSavedInterruptStatus = taskENTER_CRITICAL_FROM_ISR(); //\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e taskEXIT_CRITICAL_FROM_ISR(uxSavedInterruptStatus); //\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c 网文：FreeRTOS 系统内核控制函数与临界段保护 ","date":"2021-06-15","objectID":"/20210615/:0:4","tags":["FreeRTOS","RTOS"],"title":"FreeRTOS 实时操作系统应用笔记","uri":"/20210615/"},{"categories":["software","MCU"],"content":"调度器上解锁 点击展开内容 //使用 vTaskSuspendAll(); //\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e xTaskResumeAll(); //\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c ","date":"2021-06-15","objectID":"/20210615/:0:5","tags":["FreeRTOS","RTOS"],"title":"FreeRTOS 实时操作系统应用笔记","uri":"/20210615/"},{"categories":["software","MCU"],"content":"系统延时函数 点击展开内容 //配置 (FreeRTOSConfig.h) #define configUSE_16_BIT_TICKS 0 //32位类型节拍计数器 #define configTICK_RATE_HZ ((TickType_t)100) //系统节拍频率（10毫秒一个节拍） //使用 vTaskDelay(50); //相对节拍延时（调用那一刻开始计时。） TickType_t tick = xTaskGetTickCount(); //获取节拍计数（获取那一刻开始计时，） vTaskDelayUntil(\u0026tick, 50); //绝对节拍延时（之后以tick增量计时。） ","date":"2021-06-15","objectID":"/20210615/:0:6","tags":["FreeRTOS","RTOS"],"title":"FreeRTOS 实时操作系统应用笔记","uri":"/20210615/"},{"categories":["software","MCU"],"content":"线程基本操作 点击展开内容 //配置 #define NETWORK_THREAD_STK_SIZE 512 //线程堆栈大小 #define NETWORK_THREAD_PRIO 2 //线程优先级（数值越小优先级越低） //创建 (动态线程) TaskHandle_t *const p_network; //动态线程句柄 xTaskCreate(network_thread_entry, //动态线程函数 \"network\", //动态线程名称 NETWORK_THREAD_STK_SIZE, //动态线程堆栈大小 NULL, //动态线程入口 NETWORK_THREAD_PRIO, //动态线程优先级 p_network); //动态线程句柄（当填 NULL 表示不需要获取） //使用 UBaseType_t pri = uxPriorit = uxTaskPriorityGet(); //获取当前线程优先级 vTaskPrioritySet(NULL, 1); //修改当前线程优先级（如果指出线程句柄,则表示指定线程） taskYIELD(); //主动让出cpu让同优先级的其他task获得cpu vTaskDelete(p_network); //删除线程（自杀最后还要 return 退出） //线程 void vAppTask(void *pvParameters) { for(;;) { vTaskDelay(50); } } 网文：FreeRTOS 修改任务优先级 ","date":"2021-06-15","objectID":"/20210615/:0:7","tags":["FreeRTOS","RTOS"],"title":"FreeRTOS 实时操作系统应用笔记","uri":"/20210615/"},{"categories":["software","MCU"],"content":"任务通知操作 点击展开内容 相比于消息队列、信号量、事件组的应用，使用任务通知速度更快、内存更少、执行更高效。任务通知只能由发送方指定线程，与线程耦合在一起。 //eSetBits:事件标志, //eIncrement:计数信号量, //eSetValueWithOverwrite:直接写覆盖消息值, //eSetValueWithoutOverwrite:不写覆盖消息值(写失败返回pdFAIL), //eNoAction:通知线程但不更新通知值。 BaseType_t true /*= pdTRUE*/; uint32_t u32d; //二值信号量形式通知 true = xTaskNotifyGive(p_network/*线程*/); //以【二值信号量形式】通知任务 true = xTaskNotify(p_network/*线程*/, 0/*无效*/, eIncrement); //以【二值信号量形式】通知任务（等同 xTaskNotifyGive()） true = xTaskNotifyAndQuery(p_network, 0/*无效*/, eIncrement, \u0026u32d);//以【二值信号量形式】通知任务（相比 xTaskNotify() 多了个回传更新前的通知值） u32d = ulTaskNotifyTake(pdTRUE/*读后清零通知值*/, portMAX_DELAY); //以【二值信号量形式】获取通知（最终的通知值：清零后的值） //计数信号量形式通知 true = xTaskNotifyGive(p_network/*线程*/); //以【计数信号量形式】通知任务 true = xTaskNotify(p_network/*线程*/, 0/*无效*/, eIncrement); //以【计数信号量形式】通知任务（等同 xTaskNotifyGive()） u32d = ulTaskNotifyTake(pdFALSE/*计数信号量减1*/, portMAX_DELAY); //以【计数信号量形式】获取通知（最终的通知值：减一后的值） //事件标志形式通知 true = xTaskNotify(p_network/*线程*/, 0x00000001, eSetBits); //以【事件标志形式】通知任务 true = xTaskNotifyAndQuery(p_network, 0x00000001, eSetBits, \u0026u32d); //以【事件标志形式】通知任务（相比 xTaskNotify() 多了个回传更新前的通知值） true = xTaskNotifyWait(0xFFFFFFFE/*获取前清bit31~1标志*/, 0x00000001/*获取后清bit0标志*/, \u0026u32d/*获取前后两个清除操作中间的值*/, portMAX_DELAY); //以【事件标志形式】获取通知 //在中断里通知任务 BaseType_t xHigherPriorityTaskWoken = pdFALSE; //在中断里以【计数信号量形式】通知任务(中断-\u003e线程) vTaskNotifyGiveFromISR(p_network/*线程*/, \u0026xHigherPriorityTaskWoken); portYIELD_FROM_ISR(xHigherPriorityTaskWoken); //需要调用本函数执行一次上下文切换 BaseType_t xHigherPriorityTaskWoken = pdFALSE; //在中断里以【事件标志形式】通知任务(中断-\u003e线程) true = xTaskNotifyFromISR(p_network/*线程*/, 0x00000001, eSetBits/*事件标志*/, \u0026xHigherPriorityTaskWoken); portYIELD_FROM_ISR(xHigherPriorityTaskWoken); //如果 true == pdTRUE, 则要调用本函数执行一次上下文切换 BaseType_t xHigherPriorityTaskWoken = pdFALSE; //在中断里以【事件标志形式】通知任务(中断-\u003e线程) true = xTaskNotifyAndQueryFromISR(p_network/*线程*/, 0x00000001, eSetBits/*事件标志*/, \u0026u32d, \u0026xHigherPriorityTaskWoken); //（相比 xTaskNotifyFromISR() 多了个回传更新前的通知值） portYIELD_FROM_ISR(xHigherPriorityTaskWoken); //如果 true == pdTRUE, 则要调用本函数执行一次上下文切换 网文：FreeRTOS 任务通知 网文：FreeRTOS 快速笔记——信号量（动态/静态） ","date":"2021-06-15","objectID":"/20210615/:0:8","tags":["FreeRTOS","RTOS"],"title":"FreeRTOS 实时操作系统应用笔记","uri":"/20210615/"},{"categories":["software","MCU"],"content":"信号量操作 点击展开内容 关于二值信号量与计数信号量无本质区别，当计数信号量最大计数值为 1 及初始值为 0 时，即是二值信号量。 //配置 (FreeRTOSConfig.h) #define configSUPPORT_DYNAMIC_ALLOCATION 1 //开启信号量 #define INCLUDE_vTaskSuspend 1 //如果需要永远等待-\u003eportMAX_DELAY //建删 SemaphoreHandle_t Sem_Handle = NULL; //信号量句柄 Sem_Handle = xSemaphoreCreateBinary(); //动态【二值信号量】创建 Sem_Handle = xSemaphoreCreateCounting(0xFFFF, 0); //动态【计数信号量】创建（入口：最大值,初始值） vSemaphoreDelete(Sem_Handle); //信号量删除（如果有任务阻塞在这个信号量上，则这个信号量不要删除!） //使用 BaseType_t true /*= pdTRUE*/; true = xSemaphoreGive(Sem_Handle); //信号量释放 （线程与线程） true = xSemaphoreTake(Sem_Handle, portMAX_DELAY); //信号量获取 （线程与线程）(非死等必要判断返回值:pdTRUE) true = xSemaphoreTake(Sem_Handle, 0); //不等待获取 （线程与线程）(非死等必要判断返回值:pdTRUE) while (pdTRUE == xSemaphoreTake(Sem_Handle, 0)); //信号量重置 （FreeRTOS 没提供信号量重置功能，只能单个死循环清空） //在中断里使用 BaseType_t xHigherPriorityTaskWoken = pdFALSE; //在中断里信号量释放（中断-\u003e中断)或(中断-\u003e线程) true = xSemaphoreGiveFromISR(Sem_Handle, \u0026xHigherPriorityTaskWoken); portYIELD_FROM_ISR(xHigherPriorityTaskWoken); //如果 true == pdTRUE, 则要调用本函数执行一次上下文切换 BaseType_t true /*= pdTRUE*/; BaseType_t xHigherPriorityTaskWoken; //在中断里信号量获取（中断-\u003e中断) true = xSemaphoreTakeFromISR(Sem_Handle, \u0026xHigherPriorityTaskWoken); 网文：FreeRTOS 信号量分析 ","date":"2021-06-15","objectID":"/20210615/:0:9","tags":["FreeRTOS","RTOS"],"title":"FreeRTOS 实时操作系统应用笔记","uri":"/20210615/"},{"categories":["software","MCU"],"content":"互斥量操作 点击展开内容 关于可递归锁也可称为可重入锁，与非递归锁唯一的区别是：同一个线程可以多次获取同一个递归锁，不会产生死锁。而如果一个线程多次获取同一个非递归锁，则会产生死锁。还有需要注意：中断是不能使用互斥锁的！ //配置 (FreeRTOSConfig.h) #define configUSE_MUTEXES 1 //开启互斥量 #define configUSE_RECURSIVE_MUTEXES 1 //开启递归互斥量 #define INCLUDE_vTaskSuspend 1 //如果需要永远等待-\u003eportMAX_DELAY //建删 SemaphoreHandle_t MuxSem_Handle = NULL; //信号量句柄 MuxSem_Handle = xSemaphoreCreateMutex(); //动态【互斥量】创建 MuxSem_Handle = xSemaphoreCreateRecursiveMutex(); //动态【递归互斥量】创建 vSemaphoreDelete(MuxSem_Handle); //信号量删除（如果有任务阻塞在这个信号量上，则这个信号量不要删除!） //使用 BaseType_t true /*= pdTRUE*/; true = xSemaphoreGive(MuxSem_Handle); //【互斥量】释放 true = xSemaphoreTake(MuxSem_Handle, portMAX_DELAY); //【互斥量】获取（portMAX_DELAY 表示永远等待）(非死等必要判断返回值:pdTRUE) true = xSemaphoreGiveRecursive(MuxSem_Handle); //【递归互斥量】释放 true = xSemaphoreTakeRecursive(MuxSem_Handle, portMAX_DELAY);//【递归互斥量】获取（portMAX_DELAY 表示永远等待）(非死等必要判断返回值:pdTRUE) 网文：可递归锁与非递归锁 ","date":"2021-06-15","objectID":"/20210615/:0:10","tags":["FreeRTOS","RTOS"],"title":"FreeRTOS 实时操作系统应用笔记","uri":"/20210615/"},{"categories":["software","MCU"],"content":"事件标志操作 点击展开内容 获取事件标志一般有两个分类操作：读后是否清除指定要读取的标志、当指定的标志全部触发时才读取。 //建删 EventGroupHandle_t xCreatedEventGroup = NULL; //动态事件句柄 xCreatedEventGroup = xEventGroupCreate(); //动态事件创建（返回 NULL 表示事件标志组创建失败） vEventGroupDelete(xCreatedEventGroup); //动态事件删除 //使用 EventBits_t bits; bits = xEventGroupSetBits(xCreatedEventGroup, 0x00000011); //事件标志设置（事件位置位之后的事件组值）（事件标志释放） bits = xEventGroupGetBits(xCreatedEventGroup); //事件标志获取（但不清除标志）（等同 bits = xEventGroupClearBits(xCreatedEventGroup, 0)） bits = xEventGroupClearBits(xCreatedEventGroup, 0x00000011); //事件标志清除（事件位清零之前的事件组值） bits = xEventGroupWaitBits(xCreatedEventGroup, 0x00000011, pdTRUE/*读后清除*/, pdTRUE /*当指定的条件全部成立时才触发*/, 10/*最长等待节拍数*/); //事件标志获取（返回值可以判断是否得到想要的标志位） bits = xEventGroupWaitBits(xCreatedEventGroup, 0x00000011, pdTRUE/*读后清除*/, pdFALSE/*当指定的条件中有成立都可触发*/, portMAX_DELAY/*永远等待*/);//事件标志获取（返回值可以判断是否得到想要的标志位） //在中断里使用 BaseType_t true /*= pdTRUE*/; BaseType_t xHigherPriorityTaskWoken = pdFALSE; //在中断里事件标志释放(中断-\u003e线程) true = xEventGroupSetBitsFromISR(xCreatedEventGroup, 0x00000011, \u0026xHigherPriorityTaskWoken); portYIELD_FROM_ISR(xHigherPriorityTaskWoken); //如果 true == pdTRUE, 则要调用本函数执行一次上下文切换 EventBits_t bits; BaseType_t true /*= pdTRUE*/; bits = xEventGroupGetBitsFromISR(xCreatedEventGroup); //事件标志获取（但不清除标志） true = xEventGroupClearBitsFromISR(xCreatedEventGroup, 0x00000011);//事件标志清除 网文：FreeRTOS 事件标志组 ","date":"2021-06-15","objectID":"/20210615/:0:11","tags":["FreeRTOS","RTOS"],"title":"FreeRTOS 实时操作系统应用笔记","uri":"/20210615/"},{"categories":["software","MCU"],"content":"消息队列操作 点击展开内容 投递消息一般分为两种：向队列尾部投递、向队列头部投递。FreeRTOS 的消息每次获取都是固定长度的信息（其获取函数是没有返回信息长度参数），所以如果用于传递变长的数据帧，则由应用自行处理。 //建删 QueueHandle_t xQueueHandle = NULL; xQueueHandle = xQueueCreate(20/*消息条数*/, 4/*单条大小*/); //创建消息 （单条大小:字节） vQueueDelete(xQueueHandle); //删除消息 vQueueAddToRegistry(xQueueHandle, \"msg name\"); //注册消息名称（仅仅用于调试） vQueueUnregisterQueue(xQueueHandle); //解除注册消息（仅仅用于调试） //使用 char msg[] = {1, 2, 3}; BaseType_t true /*= pdTRUE*/; true = xQueueReset(xQueueHandle); true = xQueueOverwrite(xQueueHandle, msg); //覆盖消息（仅仅适合只有一条消息的队列） true = xQueueSend(xQueueHandle, msg, portMAX_DELAY); //投递消息（等同 xQueueSendToBack()） true = xQueueSendToBack(xQueueHandle, msg, portMAX_DELAY); //【向队列尾部】投递消息 true = xQueueSendToFront(xQueueHandle, msg, portMAX_DELAY); //【向队列头部】投递消息 true = xQueueReceive(xQueueHandle, msg, portMAX_DELAY); //获取消息（返回 pdTRUE 表示获取到消息） true = xQueuePeek(xQueueHandle, msg, portMAX_DELAY); //查看消息（相比 xQueueReceive() 不会清除队列中读出的消息） UBaseType_t n = uxQueueMessagesWaiting(xQueueHandle); //查看入列信息数目（单位:条数） UBaseType_t n = uxQueueSpacesAvailable(xQueueHandle); //查看队列空闲数目（单位:条数） //在中断里使用 char msg[] = {1, 2, 3}; BaseType_t xHigherPriorityTaskWoken = pdFALSE; //在中断里覆盖消息(中断-\u003e中断)或(中断-\u003e线程)（仅仅适合只有一条消息的队列） true = xQueueOverwriteFromISR(xQueueHandle, msg, \u0026xHigherPriorityTaskWoken); portYIELD_FROM_ISR(xHigherPriorityTaskWoken); //如果 true == pdTRUE, 则要调用本函数执行一次上下文切换 char msg[] = {1, 2, 3}; BaseType_t xHigherPriorityTaskWoken = pdFALSE; //在中断里投递消息(中断-\u003e中断)或(中断-\u003e线程) true = xQueueSendFromISR(xQueueHandle, msg, \u0026xHigherPriorityTaskWoken); portYIELD_FROM_ISR(xHigherPriorityTaskWoken); //如果 true == pdTRUE, 则要调用本函数执行一次上下文切换 char msg[] = {1, 2, 3}; BaseType_t xHigherPriorityTaskWoken = pdFALSE; //在中断里【向队列尾部】投递消息(中断-\u003e中断)或(中断-\u003e线程) true = xQueueSendToBackFromISR(xQueueHandle, msg, \u0026xHigherPriorityTaskWoken); portYIELD_FROM_ISR(xHigherPriorityTaskWoken); //如果 true == pdTRUE, 则要调用本函数执行一次上下文切换 char msg[] = {1, 2, 3}; BaseType_t xHigherPriorityTaskWoken = pdFALSE; //在中断里【向队列头部】投递消息(中断-\u003e中断)或(中断-\u003e线程) true = xQueueSendToFrontFromISR(xQueueHandle, msg, \u0026xHigherPriorityTaskWoken); portYIELD_FROM_ISR(xHigherPriorityTaskWoken); //如果 true == pdTRUE, 则要调用本函数执行一次上下文切换 char msg[4]; BaseType_t xHigherPriorityTaskWoken = pdFALSE; //在中断里获取消息 true = xQueueReceiveFromISR(xQueueHandle, msg, \u0026xHigherPriorityTaskWoken); portYIELD_FROM_ISR(xHigherPriorityTaskWoken); //如果 true == pdTRUE, 则要调用本函数执行一次上下文切换 char msg[4]; BaseType_t xHigherPriorityTaskWoken = pdFALSE; //在中断里查看消息 true = xQueuePeekFromISR(xQueueHandle, msg, \u0026xHigherPriorityTaskWoken); portYIELD_FROM_ISR(xHigherPriorityTaskWoken); //如果 true == pdTRUE, 则要调用本函数执行一次上下文切换 true = xQueueIsQueueEmptyFromISR(xQueueHandle); //查看消息队列是否为空（返回 pdTRUE 表示为空） true = xQueueIsQueueFullFromISR(xQueueHandle); //查看消息队列是否为满（返回 pdTRUE 表示为满） UBaseType_t n = uxQueueMessagesWaitingFromISR(xQueueHandle);//查看入列信息数目（单位:条数） ","date":"2021-06-15","objectID":"/20210615/:0:12","tags":["FreeRTOS","RTOS"],"title":"FreeRTOS 实时操作系统应用笔记","uri":"/20210615/"},{"categories":["software","MCU"],"content":"动态内存操作 点击展开内容 //配置 (FreeRTOSConfig.h) #define configTOTAL_HEAP_SIZE ( ( size_t ) ( 17 * 1024 ) ) //动态内存大小定义（单位:字节） //使用 size_t size = xPortGetFreeHeapSize(); //获得FreeRTOS动态内存的剩余 void *pd = pvPortMalloc(1024); //申请动态内存 vPortFree(pd); //释放动态内存 // 五种动态内存管理方式简单总结如下，实际项目中，用户根据需要选择合适的文件： //（1）heap_1.c：五种方式里面最简单的，但是申请的内存不允许释放。 //（2）heap_2.c：支持动态内存的申请和释放，但是不支持内存碎片的处理，并将其合并成一个大的内存块。 //（3）heap_3.c：将编译器自带的malloc和free函数进行简单的封装，以支持线程安全，即支持多任务调用。 //（4）heap_4.c：支持动态内存的申请和释放，支持内存碎片处理，支持将动态内存设置在个固定的地址。 //（5）heap_5.c：在heap_4的基础上支持将动态内存设置在不连续的区域上。 网文：FreeRTOS 动态内存管理 网文：FreeRTOS 动态内存管理《heap_1.c》详解 ","date":"2021-06-15","objectID":"/20210615/:0:13","tags":["FreeRTOS","RTOS"],"title":"FreeRTOS 实时操作系统应用笔记","uri":"/20210615/"},{"categories":["linux"],"content":"linux 基本知识及基本命令使用","date":"2021-06-13","objectID":"/20210613/","tags":["命令","linux 工具/应用"],"title":"linux 基本命令使用","uri":"/20210613/"},{"categories":["linux"],"content":"一、认识linux linux发行版本 deb派系--桌面版系统 1、Debian（读音：‘debeen 待宾） 2、Ubuntu（读音：u’bʌntu 乌班图） 3、Deepin（读音：diːpin 低评） …… #〖安装本地软件包方法〗 sudo dpkg -i xxxx.deb #安装【本地软件包】（dpkg 是 Debian Package /ˈpækɪdʒ/ 简写，即 Debian 软件包） sudo dpkg -r xxxx #卸载【本地软件包】（保留配置）（不保留配置使用 -P 选项） sudo dpkg -l xxxx #显示软件的版本 #【安装远程软件包方法】 sudo apt-get install xxxx #安装软件包的最新版本（apt 是 Advanced Package Tool（高级软件包工具）简写，apt-get、apt-cache 是 apt 工具的传统命令行接口，apt 现在被推荐为更现代的用法，例如：apt list --installed 列出已安装的软件包） sudo apt-get remove xxxx #从系统中删除指定的软件包 sudo apt-get update #检测已安装软件包是否有更新（如果指定软件名则表示指定软件包是否有更新） sudo apt-get upgrade xxxx #升级指定的软件包(前提：先运行 update 检测)(而使用 dist-upgrade 则以更聪明的方式来解决更新过程中出现的软件依赖问题) sudo apt-cache list xxxx #从资源库中查询可用的软件包 sudo apt-cache search g++ #搜索单词为g++的软件包 sudo apt-cache show g++ #显示g++软件包详细信息 rpm派系--服务器系统 1、RedHat（读音：‘redhæt [红帽]） 2、CentOS（读音：sen’tus 圣斗士） 3、Fedora（读音：fɪ’dɔːrə 费多拉帽） …… #〖安装本地软件包方法〗 sudo rpm -ivh xxxx.rpm #安装【本地软件包】（其中 v 显示详细信息，h 显示安装进度） sudo rpm -e xxxx #卸载【本地软件包】 sudo rpm -Uvh xxxx.rpm #升级软件　（其中 v 显示详细信息，h 显示安装进度） #【安装远程软件包方法】 sudo yum install xxxx #安装软件包的最新版本 sudo yum remove xxxx #从系统中删除指定的软件包 sudo yum update xxxx #升级指定的软件包 sudo yum list #列出所有可安装的软件包（如果指定软件名则表示列出指定可安装的软件包） sudo yum list installed #列出已安装的软件包 sudo yum list updates #列出所有可更新的软件包 linux在线源码 如果想了解 linux 内核源代码，强烈推荐在 Bootlin 上阅读。 Linux 全称 GNU/Linux，是一种免费使用和自由传播的类 UNIX 操作系统，其内核由 Linus Benedict Torvalds（林纳斯·本纳第克特·托瓦兹）于 1991 年 10 月 5 日首次发布，它主要受到 Minix 和 Unix 思想的启发，是一个基于 POSIX 的多用户、多任务、支持多线程和多 CPU 的操作系统。它能运行主要的 Unix 工具软件、应用程序和网络协议。它支持 32 位和 64 位硬件。Linux 继承了 Unix 以网络为核心的设计思想，是一个性能稳定的多用户网络操作系统。Linux 有上百种不同的发行版，如基于社区开发的 debian、archlinux，和基于商业开发的 Red Hat Enterprise Linux、SUSE、Oracle Linux 等。 linux核心思想 ● linux 核心思想 首先记住这个：Linux 的核心思想即一切皆是文件，设备是文件，系统是文件。比如在我们插入一个 USB 设备，/etc 的目录下多一个 USB 设备的文件夹。而对 USB 所有的操作都是通过读写这个文件进行。脚本（Script /skrɪpt/）是存储在文件中的命令的集合，命令（Command /kə'mɑːnd/）是针对计算机的指令，终端/控制台（tty,Termial /'tɜːmɪnl//console /kən'səʊl/）是命令行接口，壳（Shell /ʃel/）是一个命令行解释器，内核（Kernel /'kɜːnl/）是 Linux 操作系统的核心。 ● linux 脚本解释器 Bash /bæʃ/是大多数 Linux 系统默认的 shell 脚本解释器（注：我们平时说 Linux 中有多少种 shell 其实指的就是其中存在几种 shell 脚本解释器），可以使用命令cat /etc/shells打开文件查看到系统可用的 shell 。在脚本文件中，我们常看到第一行内容为#!/bin/bash，表示告知系统使用哪个脚本解释器来执行脚本文件，即使用哪一种 shell 。（补充：Bourne Again shell /bʊən/ə'ɡen/ʃel/（简写为 Bash）（标记为#!/bin/bash）是 Bourne shell（标记为#!/bin/sh） 的扩展，与 Bourne shell 完全向后兼容，并且在 Bourne shell 的基础上增加、增强了很多特性。特别说明：#!/bin/bash这些信息在首行且必须使用\\n来换行，不能是\\r\\n之类的来换行，否则会提示 ^M 错误!!! ● linux 环境变量 shell 中环境变量变量分三种：内部变量、系统变量、用户变量。 内部变量：系统提供，不用定义，不可修改；（$$ $? $0 $# $* $@ $1 … $SHELL(当前使用的shell(路径)) $HOME(家目录)） 系统变量：系统提供，不用定义，可以修改，利用export将用户变量转为系统变量； 用户变量：用户提供，用户定义，可以修改，利用export将用户变量转为系统变量； 环境变量（environment variables /ɪn'vaɪrənmənt/'veəriəbls/）一般是指在操作系统中用来指定操作系统运行环境的一些参数，其中一个目的是告诉系统知道应用程序所在哪个路径下，让系统可直接运行应用程序（如果应用程序已在系统标准位置下，则不需要增加环境变量。linux系统几个标准位置：/bin、/sbin、/usr/bin、/usr/sbin、/usr/local/bin 等）（Windown 系统使用分号分隔，而 linux 系统使用冒号分隔）。一般提到的环境变量主要指系统变量。环境变量配置推荐：如果要修改所有用户环境配置的话修改/etc/profile，修改单个用户的话修改~/.bashrc（如：开发板的 /root/.bashrc）。 1.1、export显示包括利用 export 将用户变量转为环境变量的 shell 变量。 1.2、echo $PATH命令为输出当前的 PATH 环境变量的值（以冒号分割不同路径） 1.3、export PATH=$PATH:/home/abc/mysql/bin可临时/永久配置环境变量（例子）。 2.1、/etc/environment整个系统环境变量，不能使用 export PATH，不建议改！ 2.2、/etc/profile所有用户环境变量，只在用户登录的时候读取一次。 2.3、/etc/bash.bashrc所有用户环境变量，每次运行 Shell 就会读取一次，影响效率。 2.4、~/.profile只针对当前用户，只在用户登录的时候读取一次（不同系统可能是：~/.bash_profile、~/.bash_login、~/.profile） 2.5、~/.bashrc只针对当前用户，每次运行 Shell 就会读取一次。 2.6、source xxxxxx手动生效上面脚本文件（如：source /etc/profile）。 linux软件安装 所谓命令，其实就是在终端机下调用某个软件（工具）运行。这些软件大部分是系统自带的，但有些需要我们去安装，安装的方式有在线安装、离线安装（离线软件包括：解压版、源码版、安装版）。 在线版：利用系统提供的服务，直接运行命令安装软件；（常规方式） 解压版：直接解压即可使用，建议移到合理目录；（推荐方式） 源码版：先编译源代码，再复制到目标(板)运行； 安装版：执行后按照提示安装； 【补充：通常还需要配置环境变量！】 ● 在线版-安装示例： sudo apt-get update # 更新软件包列表 sudo apt-get install python3 # 安装python3 ● 解压版-安装示例： wget https://developer.arm.com/-/media/Files/downloads/gnu-rm/10.3-2021.10/gcc-arm-none-eabi-10.3-2021.10-x86_64-linux.tar.bz2 # 下载交叉编译器压缩包 sudo tar -xjvf gcc-arm-none-eabi-10.3-2021.10-x86_64-linux.tar.bz2 -C /usr/lib/gcc # 将交叉编译器压缩包解压到：/usr/lib/gcc sudo gedit /etc/profile","date":"2021-06-13","objectID":"/20210613/:0:1","tags":["命令","linux 工具/应用"],"title":"linux 基本命令使用","uri":"/20210613/"},{"categories":["linux"],"content":"二、基本命令 1、常用的快速键 Ubuntu 拥有多个操作终端（使用Ctrl+Alt+F1~F7切换），F7为系统默认启动\u0026加载的图形操作终端，其余都是为纯命令行界面终端。 Ctrl+Alt+F1切换到命令行界面终端。 Ctrl+Alt+F7切换到图形界面终端。 Ctrl+Alt+t在图形界面下打开命令行终端机。 Ctrl+d关闭当前命令行终端机（纯终端则重启）。 Ctrl+c强制退出在当前命令行终端机的程序。 Ctrl+Insert复制选择的文本内容。 Shift+Insert粘贴缓存的文本内容。 Ctrl+a 或 Home转到行的开头。 Ctrl+e 或 End转到行的结尾。 Ctrl+u把光标前面的内容全删掉。 Ctrl+k把光标后面的内容全删掉。 Ctrl+l输入行移到页面顶部（相当清屏）。 ↑ 和 ↓方向键调取之前执行过的 Linux 命令。 Tab 自动补全命令，提高输入速度及精准度。 $ 命令行前面显示此字符，表示以用户权限操作。 # 命令行前面显示此字符，表示管理员权限操作。（root 权限） 2、系统权限操作 sudo su chmod chown chgrp sudo su # su 仅仅取得 root 权限【Permission】，工作环境不变。 su root # 切换到root exit # 退出root(前提已进入root) # 【关于提示符】: # ~$ 表示处于普通用户权限 # ~# 表示处于 root 权限 sudo passwd # 设置root的密码 (根据提示输入:一般先要经过输入当前用户密码验证,再输入两次设置root新密码) # 【扩展说明】: # [su ] 向当前用户授权管理员权限级别许可,但工作环境没有任何变动 # [sudo ] 以管理员身份操作(只在操作过程中变成管理员工作环境,平常还是当前用户工作环境) # [chmod] 修改文件(夹)操作权限,特别是从Windows拷贝到linux时,经常要改权限,否则不能执行 sudo chmod -R 777 /srv/ftp/upload/ # 修改[该目录里面的所有文件]操作权限：拥有者rwx,用户组rwx,其它用户rwx sudo chmod 777 /srv/ftp/upload/ # 修改目录[/srv/ftp/upload ]操作权限：拥有者rwx,用户组rwx,其它用户rwx sudo chmod 751 /srv/ftp/23.txt # 修改文件[/srv/ftp/23.txt ]操作权限：拥有者rwx,用户组r-x,其它用户--x sudo chmod ug+rw /srv/ftp/upload/ # 修改目录[/srv/ftp/upload ]操作权限：拥有者u和用户组g[增加]读r和写w权限 sudo chmod ug-rw /srv/ftp/upload/ # 修改目录[/srv/ftp/upload ]操作权限：拥有者u和用户组g[移除]读r和写w权限 sudo chmod ug=rw /srv/ftp/upload/ # 修改目录[/srv/ftp/upload ]操作权限：拥有者u和用户组g[设为]读r和写w权限 # 【扩展说明】: # [u] 表文件拥有者 | [+] 添加某个权限 | [r] 可读 # [g] 表示同组用户 | [-] 取消某个权限 | [w] 可写 # [o] 表示其它用户 | [=] 重设 rwx权限 | [x] 可执行 # [a] 表示全部用户 | | sudo chown root /var/run/httpd.pid # 改变 /var/run/httpd.pid 文件的拥有者为 root sudo chown runoob:runoobgroup f.txt # 改变 f.txt 文件的拥有者为 runoob，用户组为 runoobgroup sudo chown :runoobgroup f.txt # 改变 f.txt 文件的用户组为 runoobgroup sudo chown xiaoming 123.txt # 改变 123.txt 文件的拥有者为 xiaoming sudo chown -R xiaoming /home/abc/ # 改变 /home/abc/ 目录及其下面所有文件(夹)的拥有者为 xiaoming（拥有者owner /'əʊnə(r)/） sudo chgrp -R xiaoming /home/abc/ # 改变 /home/abc/ 目录及其下面所有文件(夹)的用户组为 xiaoming（用户组group /ɡruːp/） # 【权限总结】： # 1.文件(夹)的拥有者（用户/用户组） # 2.拥有者的操作权限（读/写/执行） # 3.新建用户时，系统会自动创建一个与用户名同名的私有组（称为 “主组”），该用户默认属于这个组。 # 查看所有用户：cat /etc/passwd（系统用户通常 UID \u003c 1000，自建用户 UID ≥ 1000）。 # 查看所有组　：cat /etc/group # 查看某个用户所属的组：groups \u003c用户名\u003e 备注：-R 大写一般用在权限命令这里（还有ls），-r 小写一般用在其它命令那里。 3、根与目录操作 cd ./ ../ pwd ls ll !! tree cd .. # 退回上一级目录 cd ../.. # 退回上两级目录 cd ftp/upload # 进入当前子目录 cd ./ftp/upload # 进入当前子目录(同上)(平常可以省略[./]) cd /usr/local # 进入 绝对目录 # [../] 表示相对路径(上级目录) # [./] 表示相对路径(当前目录) # [/] 表示绝对路径 # [~] 表示家目录 cd ~ # 进入当前用户的家目录 cd - # 回到之前所在的目录 pwd # 显示当前工作目录的全路径 (print working directory) !! # 显示上一条命令及上一条命令的结果 ./qt-creator-linux-x86.run # 运行[qt-creator-linux-x86.run]此文件 ls # 查看当前目录下文件 ls upload # 查看当前目录下[upload]目录下文件 ls *.o # 查看当前目录下扩展名为[*.o]的相关文件 ls -l \u003e lsoutput.txt # 以长格式显示文件的详细信息, 直接将打印内容保存到当前目录下lsoutput.txt(创建覆盖内容) ls -l \u003e\u003e lsoutput.txt # 以长格式显示文件的详细信息, 直接将打印内容保存到当前目录下lsoutput.txt(尾部插入内容) ls -R # 连同子目录的内容一起列出（递归列出） ls -a # 显示所有文件（包含以点(.)开头的隐藏文件） ls -l # 以长格式显示文件的详细信息，可以查看文件权限，所属用户，日期等 ll # 同 ls -l（其它选项：-t 按修改时间列出，-s 显示出大小） ls -l libmad.so.0 # 以长格式显示文件的详细信息查看 libmad.so.0 文件 ls -l | grep rwxrwxr- # 列出当前目录文件(夹),但只显示经过[grep]筛选含有[rwxrwxr-]的内容(grep是独立命令,|是管道命令) # 【扩展说明】: # 文件属性第一个字符表示是什么? 如: -rwxrwxrwx, drwxrwxrwx, …… # [-] 常规文档(regular file): 纯文本文档(ASCII),二进制文件(binary),数据格式文件(data) # [d] 目录(directory) # [l] 连接文件(link),就是类似 Windows 系统底下的快捷方式 # [b] 区块(block)设备文件 # [c] 字符(character)设备文件 # [s] 资料接口文件(sockets) # [p] 数据输送文件(FIFO, pipe) tree # 列出指定目录下的所有文件(夹)，包括子目录里的文件(夹) tree -L 1 # 显示一级目录和文件 tree -L 1 -d # 显示一级目录 # 【目录结构】： # /bin: 常用命令(二进制执行文件) # /sbin: 系统命令(二进制执行文件) # /dev: 设备文件目录(设备以档案形态存于本目录) # /media:可移动媒体设备挂载目录(与/mnt无本质区别) # /mnt: 存储设备挂载目录(一般为挂载临时的安装目录) # /etc: 系统配置文件目录 # /home: 用户主目录 # /root: 管理员主目录 # /opt: 可选的附加应用程序(第三方协力软件) # /boot: 系统内核文件和引导装载程序文件 # /lib: 存放系统的库文件 # /proc: 虚拟机系统，记录进程，网络信息等 # /sys: 虚拟文件系统，记录内核数据 # /var: 系统运行产生的文件 # /usr: 用户程序目录(Unix Software Resource) # /usr/bin — 众多的应用程序（是对/bin、/sbin的一个补充） # /usr/sbin — 超级用户的一些管理程序（是对/bin、/sbin的一个补充） # /usr/doc — linux文档 # /usr/include — linux下开发和编译应用程序所需要的头文件 # /usr/lib — 常用的动态链接库和软件包的配置文件 # /us","date":"2021-06-13","objectID":"/20210613/:0:2","tags":["命令","linux 工具/应用"],"title":"linux 基本命令使用","uri":"/20210613/"},{"categories":["software"],"content":"本人 C 语言编程规范介绍","date":"2021-06-09","objectID":"/20210609/","tags":["C","编程规范"],"title":"本人 C 语言编程规范","uri":"/20210609/"},{"categories":["software"],"content":"前言 代码编写规范应该在建立一个工程项目之前，并且贯穿整个项目的始终，以保证代码的一致性。采用标准的代码编写惯例，可以大大简化项目的维护负担，最终达到：简洁、一致、易理解、易维护、易移植的目的，非常有利于团队成员的合作。关于本人 C 语言编程规范，以简单实用为主，不会设置过多规则。写这篇文章目的是为以后介绍我开发的一些模块，其按规范编写以保持统一风格方便大家阅读代码。 ","date":"2021-06-09","objectID":"/20210609/:0:1","tags":["C","编程规范"],"title":"本人 C 语言编程规范","uri":"/20210609/"},{"categories":["software"],"content":"总体规范 1、规范总规则概述 一）单词与单词使用下划线连接，字符使用全大写或全小写；二）源文件和头文件名称使用全小写；三）变量和数据结构名称使用全小写；四）枚举成员、宏名称使用全大写；五）数据类型名称以_t结尾，枚举类型名称以_e结尾，联合体类型名称以_u结尾；六）指针名称以p_开头，函数指针名称以_fn结尾，回调函数名称以_cb结尾；七）一元操作符（如地址符\u0026）与参数之间不留空格，二元操作符（如运算符+，但.和-\u003e操作符除外）和三元操作符（如? :）前后留有空格；八）括号与内则内容不留空格，逗号与右侧内容之间应有空格。 2、源文件命名规范 使用全小写形式，单词与单词之间使用_连接； 为了避免文件（夹）重名，一般在名称前面加入前缀标识； 示范如下： o2o_eeprom.c o2o_eeprom.h 3、头文件总体规范 使用统一的头部声明； 加入防重复包含的宏； 此头文件包含重映射； 一些依赖头文件包含； 加入C++的兼容语句； 参数配置； 数据类型； 操作函数； 示范如下： /** * @file o2o_eeprom.h * @brief EEPROM存储器操作对象模块 * COPYRIGHT (C) 2021, 一春又一春设计部 * Change Logs: * Date Author Notes * 2021-05-30 o2ospring 原始版本 */ #ifndef O2O_EEPROM_H__ #define O2O_EEPROM_H__ //######################################################################################################## #include \"app_cfg.h\" /////////////////////// \u003c- 按规定[app_cfg.h]作为工程所有应用模块统一配置头文件！ ###ifdef __O2O_EEPROM_REMAP_H //////////////// \u003c- 如果在[app_cfg.h]定义此宏，则启动头文件重映射功能←┐ ## #include \"o2o_eeprom_remap.h\" ////////////// \u003c- 当启动重映射,则头文件包含将映射到本行定义的头文件←┘ ###else //################################################################################################## #include \u003cstdint.h\u003e //////////////////////// \u003c- 使用的数据定义，如: int8_t, uint32_t 等#ifdef O2O_EEPROM_C__ #include \u003cstring.h\u003e //////////////////////// \u003c- 使用的字符处理，如: strcpy(), memcpy() 等#include \"rtthread.h\" ////////////////////// \u003c- 使用RT-Thread操作系统#include \"rthw.h\" ////////////////////////// \u003c- 使用RT-Thread操作系统#endif #ifdef __cplusplus extern \"C\" { #endif /********************************************************************************************************/ /*++++++++++++++++++++++++++++++++++++++++++++++ 参数配置 ++++++++++++++++++++++++++++++++++++++++++++++*/ /********************************************************************************************************/ // 模块硬件级别临界处理: #define O2O_EEPROM_VARIAB() register rt_base_t level; // 使用到的变量声明 #define O2O_EEPROM_LOCKED() level = rt_hw_interrupt_disable() // [关]中断总开关 #define O2O_EEPROM_UNLOCK() rt_hw_interrupt_enable(level) // [开]中断总开关 /********************************************************************************************************/ /*++++++++++++++++++++++++++++++++++++++++++++++ 数据类型 ++++++++++++++++++++++++++++++++++++++++++++++*/ /********************************************************************************************************/ typedef struct o2o_eeprom_ //新定义的结构体数据类型以“_”结束 { uint8_t chip_addr; uint16_t i2c_ch; }o2o_eeprom_t; //新定义的结构体数据类型以“_t”结束 /********************************************************************************************************/ /*++++++++++++++++++++++++++++++++++++++++++++++ 操作函数 ++++++++++++++++++++++++++++++++++++++++++++++*/ /********************************************************************************************************/ extern int o2o_eeprom_write(o2o_eeprom_t *pob, uint32_t addr, uint8_t *pda, uint16_t len); #ifdef __cplusplus } #endif #endif //#ifdef __O2O_EEPROM_REMAP_H #endif //#ifndef O2O_EEPROM_H__ 4、源文件总体规范 头部声明； 文件包含； 模块开关； 全局变量； 函数声明； 函数实现； 示范如下： /** * @file o2o_eeprom.c * @brief EEPROM存储器操作对象模块 * COPYRIGHT (C) 2021, 一春又一春设计部 * Change Logs: * Date Author Notes * 2021-05-30 o2ospring 原始版本 */ #define O2O_EEPROM_C__ #include \"o2o_eeprom.h\"#if (defined(O2O_APP_EEPROM_EN) \u0026\u0026 (O2O_APP_EEPROM_EN == DEF_ENABLED)) #ifdef O2O_EEPROM_X__ //再次调用头文件,用于增加存在交叉关系的内容! #undef O2O_EEPROM_H__ #include \"o2o_eeprom.h\"#endif //全局变量 uint32_t o2o_g_eeprom_flag = 0; //函数声明 int o2o_eeprom_write(o2o_eeprom_t *pob, uint32_t addr, uint8_t *pda, uint16_t len); int o2o_eeprom_read(o2o_eeprom_t *pob, uint32_t addr, uint8_t *pbf, uint16_t len); /** * @brief EEPROM对象写操作 * @param *pob 要操作的EEPROM对象 * @param addr 要写入的位置 * @param *pda 要写入的数据源 * @param len 要写入的数据长度 * @return ＞0:操作成功 */ int o2o_eeprom_write(o2o_eeprom_t *pob, uint32_t addr, uint8_t *pda, uint16_t len) { uint8_t i, dat; } #endif //#if (O2O_APP_EEPROM_EN == DEF_ENABLED) ","date":"2021-06-09","objectID":"/20210609/:0:2","tags":["C","编程规范"],"title":"本人 C 语言编程规范","uri":"/20210609/"},{"categories":["software"],"content":"头部规范 1、文件头格式规范 文件名称； 模块摘要； 版权声明； 修改记录； 示范如下： /** * @file o2o_eeprom.c * @brief EEPROM存储器操作对象模块 * COPYRIGHT (C) 2021, 一春又一春设计部 * Change Logs: * Date Author Notes * 2021-05-30 o2ospring 原始版本 */ 2、函数头格式规范 函数摘要； 入口参数； 出口参数； 示范如下： /** * @brief 主函数 * @param argc 输入选项/参数的个数 * @param *argv[] 全部选项/参数内容 * @return 返回参数 */ int main(int argc, char *argv[]) { } ","date":"2021-06-09","objectID":"/20210609/:0:3","tags":["C","编程规范"],"title":"本人 C 语言编程规范","uri":"/20210609/"},{"categories":["software"],"content":"代码规范 1、宏定义名称书写规范 使用全大写形式，单词与单词之间使用_连接； 为了防止与其它模块重名，建议宏名称加入前缀； 宏的每个参数都要使用()括住； 只代表数值的宏，不需要使用()作为结尾； 示范如下： #define O2O_EEPROM_SIZE (32UL * 1024UL) #define O2O_MAX(a, b) (((a) \u003e (b)) ? (a) : (b)) 2、自定义类型书写规范 使用全小写形式，单词与单词之间使用_连接； 新定义数据类型名称以_t结尾； 对于结构体名称以_结尾； 示范如下： typedef unsigned char uint8_t; typedef signed char int8_t; typedef int (*o2o_pfunc_t)(int *, int); typedef struct o2o_limit_motor_ { uint8_t action; uint8_t load_act; uint16_t load_val; }o2o_limit_motor_t; typedef union o2o_motor_ { uint8_t load_act; uint16_t load_val; }o2o_motor_t; 3、变量书写规划 使用全小写形式，单词与单词之间使用_连接； 为了防止与其它模块重名，建议全局变量加入前缀； 如果变量对属性或类型敏感，则可以加入组合标识； g+ 表示属性为全局变量； s+ 表示属性为静态变量； c+ 表示属性为只读变量； p+ 表示属性为指针； vo_ 表示空数据类型；（只针对空指针） xx_ 表示可变动类型；（根据应用场合可设定数据类型，例如外置存储器大小） un_ 表示共用体类型； ob_ 表示结构体类型； sc_、ss_、sl_ 分别为 1、2、4 字节有符号数类型； uc_、us_、ul_ 分别为 1、2、4 字节无符号数类型； 完整变量命名：前缀 + 属性\u0026类型 + 描述 示范如下： int8_t o2o_gsc_delay; //如果局部变量则写法: sc_delay int16_t o2o_gss_delay; //如果局部变量则写法: ss_delay int32_t o2o_gsl_delay; //如果局部变量则写法: sl_delay uint8_t o2o_guc_delay; //如果局部变量则写法: uc_delay uint16_t o2o_gus_delay; //如果局部变量则写法: us_delay uint32_t o2o_gul_delay; //如果局部变量则写法: ul_delay uint32_t *o2o_pul_delay; //如果局部变量则写法: pul_delay (实际写法一般为 pul) void *o2o_pvo_delay; //如果局部变量则写法: pvo_delay (实际写法一般为 pvo) const int8_t o2o_csc_delay; static uint8_t o2o_suc_delay; o2o_limit_motor_t o2o_gob_motor; //如果局部变量则写法: ob_motor o2o_limit_motor_t *o2o_pob_motor; //如果局部变量则写法: pob_motor (可以简写为 p_motor) 对于平常时的使用，很少指出变量的类型，因为编程的重点在代码的业务逻辑及架构上。例如上面的变量统一写法为：delay motor g_delay g_motor p_delay p_motor即可。 4、代码书写规划 关键字与其它语句使用空格隔开，但else{}空置语句除外； 所有运算符都需要使用空格隔开；但for()条件判断除外； 示范如下： /** * @brief EEPROM对象写操作 * @param *pob 要操作的EEPROM对象 * @param addr 要写入位置 * @param *pda 要写入的数据源 * @param len 要写入的数据长度 * @return ＞0:操作成功 */ int o2o_eeprom_write(o2o_eeprom_t *pob, uint32_t addr, uint8_t *pda, uint16_t len) { int i; if (pda == 0) return; if (pob == 0) return; if (len == 0) return; if (addr \u003e= O2O_EEPROM_SIZE) return; if ((pob == 0) \u0026\u0026 (pda == 0)) { return; } else{} for (i=0; i\u003c20; i++) { pob-\u003ecnt_h = i; } while (1) { i += 1; i++; i = 0; } do { pda = \u0026i; } while (i \u003e 0); switch (addr) { case 1: break; case 2: break; default: break; } } ","date":"2021-06-09","objectID":"/20210609/:0:4","tags":["C","编程规范"],"title":"本人 C 语言编程规范","uri":"/20210609/"},{"categories":["software"],"content":"单词缩写 1、单词缩写字典 字母 描述 缩写词 A Average Avg Addition Add Accumulator Acc Address Addr Action Act Active Act Amplitude Amp Analog Input AI Anolog I/O AIO All All Alarm Alm Allocate Alloc Analog Output AO Apparent App Argument Arg Arrange Arrng Array Array Assemble Asm Attribute Attrib B Back Bk Background Bg Break Brk Bar Bar Bit Bit Block Blk Buffer Buf Button Btn Bypass Bypass C Calibration Cal Calculate Calc Configuration Cfg Channel Ch Change Chg Check Chk Clock Clk Clear Clr Clear Screen Cls Command Cmd Compare Cmp Complete Comp Count Cnt Counter Ctr Column Col Communication Comm Connect Con Construct Cons Control Ctrl Context Ctx Convert Conv Copy Cp Current Cur Cursor Csr Control Word CW Color Cr(clr) D Data Dat Date Date Day Day Day-of-week DOW Delay Dly Debounce Debounce Decrease Dec Decimal Dec Decode Decode Define Def Degree Deg Delete Del Destination Dst Descriptor Desc Device Dev Discrete Input DI Digit Dig Discrete I/O DIO Discrete Output(s) DO Disable Dis Display Disp Discovery Disc Division Div Divisor/Division Div Document Doc Down Down Dummy Dummy Dynamic Dyn E Edge Edge Edit Edt Effective Eff Electric Elec Empty Empty Enable En Engine Eng Enter Enter Entries Entries Equivalent Equiv Error(s) Err Ethernet Eth Engineering Units EU Event(s) Event Extension Ext Exit Exit Exception Exc Expiration Exp Exponent Exp F Field Fld Flag Flg Flush Flush Function(s) Fnct Format Frm Fraction Fract Free Free Frequency Freq Full Full G Grid Grd Gain Gain Get Get Generate Gen Group(s) Grp H Handler Handler Harmonic Harm Hexadecimal Hex High Hi History Hist Hit Hit High Priority Task HPT Hour(s) Hr I I.D. Id Idle Idle Impulse Imp Image Img Increment Inc Information Info Initial Init Insert Ins Input(s) In Initialization Init Initialize Init Instruction Instr Interrupt Int Invert Inv Interrupt Service Routine ISR Index Ix K Key Key Keyboard Kdb L Label Lab Length Len List Lst(Ls) Library Lib Limit Lim Low Lo Lower Le Lowest Lo Lock Lock Low Priority Task LTP M Manager Mngr(mgr) Magnitude Mag Mantissa Man Manual Man Manufacture Mfg Maximum Max Mailbox Mbox Minimum Min Mode Mode Month Month Move Mov Message Msg Measure Meas Mask Msk Multiplication Mul Multiplex Mux Make Mk N Negative Neg Number of Num Nesting Nesting Neutral Neut New New Next Next O Offset Offset Old Old Operation System OS Optimize Opt Original Orig Output Out Overflow Ovf P Password Pwd Picture Pic Point Pt Print Prn Program Prg Package Pkg Parameter Param Pass Pass Performance Perf Period Per Phase Ph Port Port Position Pos Positive Pos Power Pwr Previous Prev Priority Prio Printer Prt process Proc Product Prod Protocol Prot Pointer Ptr Put Put Q Queue Q Quality Qlty Quarter Quar R Raw Raw Reactive React Recall Rcl Rectangle Rect Read Rd Ready Rdy Reference Ref Register Reg Request Req Reset Reset Reserve Resv Resume Resume Response Resp Return Rtn Reverse Revs Ring Ring Row Row Repeat Rpt Real-Time RT Running Running Receive Rx S Server Srv Source Src Statistic Stat String Str Sybase Syb Sample Smp Scale Scale Scale Factor SF Scaling Scaling Scan Scan Schedule Sched Scheduler Sched Screen Scr Second(s) Sec Segment(s) Seg Select Sel Semaphore Sem Sequence Seq Server Svr Set Set Setting Setting Signal Sig Size Size Seven-segments SS Sourse Src Start Start Statistic(s) Stat Status Stat Stack Stk Standard Std Stop Stop String Str Subtraction Sub Suspend Suspend Switch Sw Synchronize Synch System Syst T Temp Tmp Text Txt Task Task Table Tbl Threshold Th Tick Tick Time Time Timer Tmr Toggle Tgl Total Tot Trigger Trig Time-stamp TS Timeout TO Unlock Unlock U User Usr Up Up Update Update Utility Util V Value Val Vector Vect Version Ver Variable Var Visible Vis Voltage Vol W Watchdog Wdog(wdg) Window Wnd(win) Write Wr Y Year Year ","date":"2021-06-09","objectID":"/20210609/:0:5","tags":["C","编程规范"],"title":"本人 C 语言编程规范","uri":"/20210609/"},{"categories":["MCU"],"content":"介绍 STM32CubeMX 的基本使用","date":"2021-06-06","objectID":"/20210606/","tags":["STM32CubeMX","ARM Cortex-M"],"title":"STM32CubeMX 基本使用","uri":"/20210606/"},{"categories":["MCU"],"content":"一【基本知识】 ● STM32CubeMX 是 ST 意法半导体近几年来大力推荐的 STM32 芯片图形化配置工具，目的就是为了方便开发者，允许用户使用图形化向导【生成初始化代码】，省去了我们配置各种外设复杂的参数，大大的节省了时间。STM32CubeMX 支持多种工具链，比如 MDK、IAR For ARM、TrueStudio 以及 Makefile 等。STM32CubeMX 几乎覆盖了 STM32 全系列芯片，比如 STM32F、STM32G、STM32H、STM32L 等。 ● HAL 库是 Hardware Abstraction Layer 的缩写，中文名称为硬件抽象层，是 ST 公司为 STM32 的 MCU 最新推出的硬件抽象层驱动库，为更方便的实现跨 STM32 产品的最大可移植性。 网文：STM32 CubeMx 使用教程 ","date":"2021-06-06","objectID":"/20210606/:0:1","tags":["STM32CubeMX","ARM Cortex-M"],"title":"STM32CubeMX 基本使用","uri":"/20210606/"},{"categories":["MCU"],"content":"二【STM32CubeMX 安装】 1、安装 JRE 由于 STM32CubeMX 软件是基于 JAVA 环境运行的，所以事先需要安装 JRE。JRE 包含了 JVM 虚拟机以及 Java 语言的核心类库，用于运行 java 程序。打开【官网】，选择 Windows Offline (64-bit) 版本下载。安装方法很简单，点击“安装”即可。备注：想了解更多 JRE 的知识，请移步《linux JAVA 开发环境 JDK》。 2、安装 STM32CubeMX 首先到官网下载 STM32CubeMX，由于需要填写 Email 相关信息及官网下载网速可能过慢，个人建议到普通软件网站下载再升级到最新版（升级方法：Help → Check for Updates → Refresh）。STM32CubeMX 的安装很简单，一路 Next 及选择同意，最后 Done 即可。备注：无论安装目录还是创建工程，都不应使用中文，否则可能会出错！ 3、安装 HAL 库 HAL 库的安装分两种：离线安装、在线安装。如果你之前已经下载 HAL 库离线包，点击菜单：Help → Manage embedded software packages → From Local… 直接导入即可；否则建议在线安装：Help → Manage embedded software packages → Install Now。 ","date":"2021-06-06","objectID":"/20210606/:0:2","tags":["STM32CubeMX","ARM Cortex-M"],"title":"STM32CubeMX 基本使用","uri":"/20210606/"},{"categories":["MCU"],"content":"三【STM32CubeMX 使用】 1、第一步新键工程（如图） 2、选择芯片及封装（如图） 3、配置晶振及时钟（如图） 补充： STM32F429xxx时钟配置参考 4、配置 GPIO 引脚（如图） 5、配置 UART 串口（如图） 6、工程配置及生成（如图） ","date":"2021-06-06","objectID":"/20210606/:0:3","tags":["STM32CubeMX","ARM Cortex-M"],"title":"STM32CubeMX 基本使用","uri":"/20210606/"},{"categories":["MCU"],"content":"四【STM32CubeMX 更多】 1、【调试引脚】初始与使用（如图） 必须使能调试引脚，否则烧录一次之后将无法再使用仿真器仿真或烧录程序！（补救方法还是有的，只是操作起来有点麻烦。方法一：按着 MCU 的复位键不放，点击 Keil 下载，等界面进入下载流程时松开按键，如果不成功多试几次；方法二：BOOT1=X BOOT0=0 两引脚电平决定程序从单片机内部 Flash 存储器启动，暂时修改 BOOT0=1 为高电平，则程序启动不起就不会影响调试引脚功能，此时即可烧录程序，不过前提硬件需要预留 BOOT0 引脚为可设置高低电平！） 2、【普通IO脚】初始与使用（如图） 3、【外部中断】初始与使用（如图） 4、【串口通讯】初始与使用（如图） 5、【定 时 器】初始与使用（如图） 待续…… 6、【PWM 输出】初始与使用（如图） 7、【看 门 狗】初始与使用（如图） 8、【SPI 总线】初始与使用（如图） ","date":"2021-06-06","objectID":"/20210606/:0:4","tags":["STM32CubeMX","ARM Cortex-M"],"title":"STM32CubeMX 基本使用","uri":"/20210606/"},{"categories":["software"],"content":"介绍 Visual Scope 串口虚拟示波器工具的使用","date":"2021-06-02","objectID":"/20210602/","tags":["Visual Scope"],"title":"Visual Scope 串口虚拟示波器工具","uri":"/20210602/"},{"categories":["software"],"content":"前言 我们做项目时，往往需要查看数据曲线。例如：查看单片机使用率的曲线、查看 AD 读出温度值的曲线、查看电机转速的曲线…… 那么有没有像示波器一样显示曲线图的工具呢？当然是有的，今天为大家介绍一款串口虚拟示波器软件 Visual Scope（Serial Digital Scope）。Visual Scope 串口虚拟示波器是一个电脑软件，它将通过串口传输给电脑的数据以示波曲线方式显示出来，方便我们对数据分析，是您必不可缺的开发助手。Visual Scope 支持 4 通道的波形显示，支持 X、Y 轴任意缩放及移动，支持打开与保存波形数据的 Matlab 分析文件，支持 check sum 和 CRC16 两种数据校验方式。 ","date":"2021-06-02","objectID":"/20210602/:0:1","tags":["Visual Scope"],"title":"Visual Scope 串口虚拟示波器工具","uri":"/20210602/"},{"categories":["software"],"content":"使用 1、工作原理 首先Visual Scope向单片机发送启动通道传输数据指令，单片机收到指令后获知要传输哪几路通道的哪段数据（实际上 Visual Scope 为每个通道使用 4 字节指出一个数值，至于数值何含义则是由用户自行定义），然后单片机源源不断传送数据， Visual Scope把这些数据以图形曲线的方式呈现出来。备注：实际上单片机无须收到启动指令也可以源源不断传送数据给Visual Scope显示。 2、工具下载 Visual Scope为串口虚拟示波器工具，用于接收串口数据以曲线可视化方式展示出来； ECOM为串口调试助手工具，用于模拟单片机向电脑发送数据。 关于下载，可以到普通的软件网站下载即可： ● 西西软件：Visual Scope 串口示波器 网页下面点击 普通下载地址 下面的链接地址下载。 ● 脚本之家：ECOM 串口助手 网页下面点击 其它下载地址 下面的链接地址下载。 3、应用例子：连接电脑串口 把 USB 转串口工具插到电脑上，然后把 USB 转串口的RX、TX、地分别接到单片机的TX、RX、地 4、应用例子：配置通讯参数 由于Visual Scope试用版限制只能使用串口1，USB 转串口的串口号往往不是 1，所以只能我们强制修改串口号 配置Visual Scope使用串口的参数（试用版的波特率、串口号这几项不可修改） 配置Visual Scope传输数据使用哪种校验方式（本例子使用 CRC16 校验） 5、应用例子：配置界面显示 在Visual Scope勾选显示哪几路通道（本例 4 路通道全部显示）和设置栅格起始及宽度（本例设置 1000，X 轴其实就是通道上第几个取样点，而非时间轴），点RUN运行监测下位机数据 6、应用例子：模拟数据展示 模拟测试：为了方便测试，没有使用单片机，而是使用电脑两个串口互发数据进行测试。其中Visual Scope使用串口1，数据发送软件ECOM 串口调试助手使用串口6，串口1的RX、TX、地分别连接串口6的TX、RX、地。ECOM 串口调试助手支持多条数据循环发送，同时可以自动在数据尾部插入CRC校验，很方便我们的测试。 操作介绍：打开ECOM 串口调试助手启动串口6，根据图示设置相关发送数据。根据上几节内容设置Visual Scope，然后按RUN按钮。 后记： ● 关于启动命令和曲线数据的格式，上图已很清晰标明。 ● 关于 CRC16 运算、数据格式和协议更多细节内容可查看Visual Scope的菜单：Help / Communication Protocol了解。 7、特别例子：逻辑分析仪 利用Visual Scope虚拟示波器显示引脚电平状态，实现虚拟的逻辑分析仪功能，方便我们分析新写的模拟总线驱动模块的正确性！ ","date":"2021-06-02","objectID":"/20210602/:0:2","tags":["Visual Scope"],"title":"Visual Scope 串口虚拟示波器工具","uri":"/20210602/"},{"categories":["MCU"],"content":"ARM-Cortex-M 系列 MCU 错误追踪库-CmBacktrace","date":"2021-05-26","objectID":"/20210526/","tags":["ARM Cortex-M","CmBacktrace"],"title":"ARM-Cortex-M 系列 MCU 错误追踪库-CmBacktrace","uri":"/20210526/"},{"categories":["MCU"],"content":"前言 ● 对于 “hard falut” 死机，是玩 ARM Cortex-M 系列 MCU 工程师望而生畏的错误，虽然大多数情况下都是内存溢出引起，但想定位出错误代码位置，那可是一件不容易的事。 ● 对于入门新人，定位错误的方法也往往是连接上仿真器，一步步 F10/F11 单步运行调试，定位到具体的错误代码，再去猜测、排除、推敲错误原因，这种过程十分痛苦。 ● 对于熟练老手，知道可以通过故障寄存器信息来定位故障原因及故障代码地址，虽然这样能解决一小部分问题，但是重复的、繁琐的分析过程也会耽误很多时间。而且对于一些复杂问题，只依靠代码地址是无法解决的，必须得还原错误现场的函数调用逻辑关系。虽然连接仿真器可以查看到的函数调用栈，但故障状态下是无法显示的，所以还是得老老实实一步一步 F10/F11 单步去定位错误代码的位置。 ● 工欲善其事，必先利其器。今天为大家介绍 CmBacktrace（Cortex Microcontroller Backtrace）（/‘kɔːteks /maɪkrəʊkɒnt’rəʊlə /bæk treɪs） ARM Cortex-M 系列 MCU 错误追踪库，配合 addr2line 工具，可以对故障进行精确定位。 ","date":"2021-05-26","objectID":"/20210526/:0:1","tags":["ARM Cortex-M","CmBacktrace"],"title":"ARM-Cortex-M 系列 MCU 错误追踪库-CmBacktrace","uri":"/20210526/"},{"categories":["MCU"],"content":"使用 1、工具简介及异常事件： 工具 介绍 CmBacktrace ARM Cortex-M 系列 MCU 错误追踪库。支持断言（assert）、故障（Hard Fault, Memory Management Fault, Bus Fault, Usage Fault, Debug Fault） addr2line 是一个可以将指令的地址和可执行映像转换成文件名、函数名和源代码行数的工具。它是标准的 GNU Binutils 中的一部分。 首先我们假设已经移植了 CmBacktrace 库到我们工程项目上，以及在电脑上安装了 addr2line 工具软件。 假设我们的单片机发生死机并通过串口打印出由 CmBacktrace 生成错误信息。 打开命令窗口，输入由 CmBacktrace 提示的 addr2line 命令串，生成错误代码定位位置信息。 2、生成的错误信息例子： 3、输入的错误定位命令： 4、输出的错误位置信息： 从上面的使用例子可以看出，我们很容易地使用工具为我们精准定位错误代码的位置。 ","date":"2021-05-26","objectID":"/20210526/:0:2","tags":["ARM Cortex-M","CmBacktrace"],"title":"ARM-Cortex-M 系列 MCU 错误追踪库-CmBacktrace","uri":"/20210526/"},{"categories":["MCU"],"content":"移植 一、CmBacktrace 移植： 1、将追踪模块加入工程： 2、初始及对接异常中断： 3、配置和适配平台环境： 4、人为地制造一个异常： 出现的异常及获取异常代码位置的方法请查看上一节内容！ 二、addr2line 移植： 1、addr2line 分析工具简介： Linux 系统一般会集成这个工具（它是标准的 GNU Binutils 中的一部分），而 Windows 系统需要我们自己下载添加。Windows 系统下我们可以从 CmBacktrace 项目的 tools 文件夹中获取 addr2line.exe，也可以安装 MinGW 在其安装目录的 bin 文件夹里获取 addr2line.exe。将其直接拷贝至 C:\\Windows 下使用或自定义路径下使用。关于 MinGW 的相关知识，请移步《MinGW-w64 编译套件(GNU 工具集)》 2、Windows 环境变量添加： 当 addr2line.exe 放到自定义路径下使用需要设置环境变量： 3、CmBacktrace 模块下载： 官方介绍及下载网址：gitee、github ","date":"2021-05-26","objectID":"/20210526/:0:3","tags":["ARM Cortex-M","CmBacktrace"],"title":"ARM-Cortex-M 系列 MCU 错误追踪库-CmBacktrace","uri":"/20210526/"},{"categories":["MCU"],"content":"Keil MDK(ARM)-在已运行单片机硬件上中途插入调试","date":"2021-05-20","objectID":"/20210520/","tags":["ARM Cortex-M","Keil MDK"],"title":"Keil MDK(ARM)-在已运行单片机硬件上中途插入调试","uri":"/20210520/"},{"categories":["MCU"],"content":"前言 一台没有上调试仿真器（如：j-link）的设备突然死机、调试控制大功率机器过程中调试仿真器突然掉线、给测试部测试了近一个月的设备突然死机（难以重现的 BUG 可遇不可求），而此时你想查看单片机当前内部一些变量、寄存器、堆栈的现场，想在实际断点处继续运行单片机程序，如何是好？我们都知道，平常在 KEIL 环境下，单片机连接仿真器后进入调试模式时，KEIL 就会自动将整个单片机进行复位，甚至有可能重新下载程序。不要说访问 RAM 数据了，程序 ROM 的代码都可能改变了！针对上面的问题，我们有没有一种方法，在不改变及不破坏单片机运行现场情况下直接切入调试模式？方法当然是有的，不急，听我慢慢道来。 ","date":"2021-05-20","objectID":"/20210520/:0:1","tags":["ARM Cortex-M","Keil MDK"],"title":"Keil MDK(ARM)-在已运行单片机硬件上中途插入调试","uri":"/20210520/"},{"categories":["MCU"],"content":"方法 注意：为了防止一些操作引起单片机复位，首先我们把仿真器拔离单片机。 1、新建工程目标： 只是克隆一模一样工程配置，之后再修改几项配置。 2、修改工程配置： 事先在工程根目录下创建文件，本例文件名为abn-debug-load-axf.ini，其内容为： LOAD %L INCREMENTAL 注：该文件用于加载 axf 文件到 KEIL 中，但是不会下载到单片机中，而 axf 文件可以方便我们进行源码级别的调试。 接着修改配置+添加文件： 3、直接进入调试： 在已运行的硬件板重新插上仿真器（如：j-link 仿真器），然后在 keil 开发环境直接点击debug按钮（注意：不要点击编译/下载/烧录这类按钮）。相当于从正常运行状态，暂停一下，再进入仿真模式，之后按照平时调试方式正常操作即可。注意-有两个前提条件： 1、原程序没有开启看门狗； 2、保留原来的代码、 axf、map 文件，或使用原来代码编译出一样的 axf、map 文件； ","date":"2021-05-20","objectID":"/20210520/:0:2","tags":["ARM Cortex-M","Keil MDK"],"title":"Keil MDK(ARM)-在已运行单片机硬件上中途插入调试","uri":"/20210520/"},{"categories":["software"],"content":"介绍 Serial Studio 数据可视化工具的使用","date":"2021-05-15","objectID":"/20210515/","tags":["Serial Studio"],"title":"Serial Studio 数据可视化工具","uri":"/20210515/"},{"categories":["software"],"content":"一、简介 Serial Studio（/‘sɪəriəl /‘stjuːdiəʊ/） 是一个多平台、多用途的串行数据可视化应用软件。此程序的目标是使嵌入式开发人员可以轻松地可视化呈现和分析其设备（或项目）生成的数据，而无需为每个项目编写专用的计算机软件。由于开源，这个工具可以扩展支持几乎所有与数据采集/测量相关的项目。Serial Studio 使用 MIT 开源协议，我们可以自由使用、复制、修改、合并、发布、分发，再许可和(或)出售。 在实际使用上发现 Serial Studio 主要针对飞行器数据可视化的一款应用软件，因为它的可视化仪表盘主要分为陀螺仪、地图坐标（经纬度）、加速计、电池指示器。Serial Studio 类似汽车的仪表盘，专业性比不上虚拟示波器这类测量软件。 ","date":"2021-05-15","objectID":"/20210515/:0:1","tags":["Serial Studio"],"title":"Serial Studio 数据可视化工具","uri":"/20210515/"},{"categories":["software"],"content":"二、使用 1、工作原理 首先在 Serial Studio 电脑软件上向设备发送启动命令，被启动的设备不断地向 Serial Studio 发送数据，Serial Studio 以仪表盘可视化方式把这些数据展示出来。关于仪表盘呈现界面需要事先通过电脑的 json 文件或者由设备第一时间直接发 json 信息给 Serial Studio 进行即时定制。Serial Studio 与设备连接的方式可以是串口、TCP/UDP、MQTT。设备为服务端，Serial Studio 为客户端。 2、安装方法 下载安装包直接安装，一直点下一步即可（注：实测只能安装到 C 盘）。相关网址：官方下载 、GitHub开源 、官方通讯协议说明 3、界面简介 3.1、界面语言选择： 3.2、界面功能介绍： 4、应用例子：仪表盘界面配置 4.1、配置仪表盘界面及数据格式： 本例使用电脑 json 配置文件来配置仪表盘界面（使用设备发来 json 配置未测试成功），具体请看下图： 4.2、json 描述仪表盘语法说明： 数据结构组成：\"g\":所有小窗口 ＞ \"d\":小窗口所有数据 ＞ \"w\":单个标准部件（包括：小窗口部件 ＞ 数据小部件） t：项目标题（字符串，必填） g：组（数组） t：组标题（字符串，必填） w：窗口小部件类型（字符串），可选-可以如下： map：创建在地图上显示位置的小部件 bar：垂直进度栏（带有max＆min值） gyro：陀螺仪指示器（带有x，y＆z值） accelerometer：加速计指示（与x，y，＆z值） d：组数据集（数组） t：数据集标题（字符串，可选） v：数据集值（变量，必填） u：数据集单位（字符串，可选） g：数据集图（布尔值，可选） w：窗口小部件类型（字符串），取决于组窗口小部件类型，可能如下： 对于gyro＆accelerometer小部件： x：X轴的值 y：Y轴的值 z：Z轴的值 对于map小部件： lat：纬度 lon：经度 对于bar小部件： max：最大值 min：最小值 4.3、json 描述仪表盘界面例子： ● 新建 test.json 文件，其须为UTF-8编码，因为数据单位使用一些特殊字符。 ● 编写仪表盘界面描述：（实际上无须重新编写 json，只需要对下面参考例子增删改即可） { \"t\":\"%1\", \"g\":[ { \"t\":\"Mission Status-任务状态\", \"d\":[ { \"t\":\"Runtime\", \"v\":\"%2\", \"u\":\"ms\" }, { \"t\":\"Packet count\", \"v\":\"%3\" }, { \"t\":\"Battery voltage\", \"v\":\"%4\", \"g\":true, \"u\":\"V\", \"w\":\"bar\", \"min\":3.6, \"max\":4.3 } ] }, { \"t\":\"Sensor Readings-传感器读数\", \"d\":[ { \"t\":\"Temperature(温度)\", \"v\":\"%5\", \"g\":true, \"u\":\"°C\", \"w\":\"bar\", \"min\":0, \"max\":80 }, { \"t\":\"Altitude(海拔)\", \"v\":\"%6\", \"u\":\"m\", \"w\":\"bar\", \"min\":0, \"max\":3000 }, { \"t\":\"Pressure(压力)\", \"v\":\"%7\", \"u\":\"KPa\", \"g\":true, \"w\":\"bar\", \"min\":54, \"max\":102 }, { \"t\":\"External Temperature\", \"v\":\"%8\", \"g\":true, \"u\":\"°C\", \"w\":\"bar\", \"min\":0, \"max\":80 }, { \"t\":\"Humidity(湿度)\", \"v\":\"%9\", \"g\":true, \"u\":\"%\", \"w\":\"bar\", \"min\":0, \"max\":100 } ] }, { \"t\":\"GPS-地图坐标\", \"w\":\"map\", \"d\":[ { \"t\":\"GPS Time\", \"v\":\"%10\" }, { \"t\":\"Longitude(经度)\", \"v\":\"%11\", \"u\":\"°E\", \"w\":\"lon\" }, { \"t\":\"Latitude(纬度)\", \"v\":\"%12\", \"u\":\"°N\", \"w\":\"lat\" }, { \"t\":\"Altitude(海拔)\", \"v\":\"%13\", \"u\":\"m\" }, { \"t\":\"No. Sats\", \"v\":\"%14\" } ] }, { \"t\":\"Accelerometer-加速计\", \"w\":\"accelerometer\", \"d\":[ { \"t\":\"X\", \"v\":\"%15\", \"u\":\"m/s^2\", \"g\":true, \"w\":\"x\" }, { \"t\":\"Y\", \"v\":\"%16\", \"u\":\"m/s^2\", \"g\":true, \"w\":\"y\" }, { \"t\":\"Z\", \"v\":\"%17\", \"u\":\"m/s^2\", \"g\":true, \"w\":\"z\" } ] }, { \"t\":\"Gyroscope-陀螺仪\", \"w\":\"gyro\", \"d\":[ { \"t\":\"X\", \"v\":\"%18\", \"u\":\"°\", \"g\":true, \"w\":\"yaw\" }, { \"t\":\"Y\", \"v\":\"%19\", \"u\":\"°\", \"g\":true, \"w\":\"roll\" }, { \"t\":\"Z\", \"v\":\"%20\", \"u\":\"°\", \"g\":true, \"w\":\"pitch\" } ] } ] } 5、应用例子：仪表盘界面启动 配置 Serial Studio 与设备的连接方式，本例为使用 UDP 方式进行连接，并向设备发送自定义“start”启动命令（收到命令后，设备端就可以不断发送相关可视化数据到仪表盘显示了）： 6、应用例子：仪表盘界面显示 6.1、设备发送的可视化数据包格式说明： ● 数据包协议：起始符为/*，结束符为*/，数据之间使用,分隔。json 中诸如\"%1\"、\"%2\"……表示第几个数据。上面例子最大为\"%20\"表示共有 20 个数据，其中第 1 个数据为数据集合的标题。 ● 特别要注意：数据须为UTF-8编码，如果是全英文字符则可以ACSII编码。 /*title,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20*/ 6.2、将收到的数据在仪表盘界面显示： 使用 UDP 软件模拟设备发送数据给 Serial Studio，然后分别在 Serial Studio 的控制台、仪表盘、小部件窗口查看数据： ","date":"2021-05-15","objectID":"/20210515/:0:2","tags":["Serial Studio"],"title":"Serial Studio 数据可视化工具","uri":"/20210515/"},{"categories":["hardware"],"content":"介绍 RGB 屏与 MIPI 屏的基本知识","date":"2021-03-23","objectID":"/20210323/","tags":["RGB","MIPI","显示屏"],"title":"RGB 屏与 MIPI 屏基本知识","uri":"/20210323/"},{"categories":["hardware"],"content":"前言 性能较弱的单片机一般没有视频接口，我们只能使用并行总线方式驱动并口显示屏，其最大分辨率一般为 480×320。但随着工业的不断进步，现在的单片机性能越来越强，慢慢出现了自带显示总线控制器（视频接口），其中 RGB 接口最为常见，其分辨率可达 800×600 上下。顺带介绍一下手机使用的 MIPI 接口，其可用于多方面的数据传输，显示屏数据传输只是它的其中一项功能。 ","date":"2021-03-23","objectID":"/20210323/:0:1","tags":["RGB","MIPI","显示屏"],"title":"RGB 屏与 MIPI 屏基本知识","uri":"/20210323/"},{"categories":["hardware"],"content":"RGB 屏 点击展开内容 RGB：称为色光三原色，分别为红、绿、蓝。目前的显示器大都是采用了 RGB 颜色标准。在显示器上，是通过电子枪打在屏幕的红、绿、蓝三色发光极上来产生色彩的，目前的电脑一般都能显示 32 位颜色，约有一百万种以上的颜色。 YUV：其的发明是由于彩色电视与黑白电视的过渡时期。Y 表示明亮度（Luminance 或 Luma），也就是灰阶值；U 和 V 表示的是色度（Chrominance 或 Chroma），作用是描述影像色彩及饱和度，用于指定像素的颜色。 RGB 控制端口 端口名称 说明 R[7:0] 红色数据 G[7:0] 绿色数据 B[7:0] 蓝色数据 CLK 像素同步时钟信号 HSYNC 水平同步信号 VSYNC 垂直同步信号 DE 数据使能信号 显示格式 说明 RGB888 红、绿、蓝分别为 8、8、8 根线，共 24 位色 RGB666 红、绿、蓝分别为 6、6、6 根线，共 18 位色 RGB565 红、绿、蓝分别为 5、6、5 根线，共 16 位色 RGB 接口时序 HBP 和 HFP 存在的必要性：从道理上说，LCD 使用矩阵寻址这两个阶段完全可以没有。但是考虑到从前 CRT 电子枪行扫描时，需要一个返回时间，而且目前的制式中，在有效信号的两端分别加入了消隐时间。就是为了做到一致，这二者才出来的。 VBP 和 VFP 存在的必要性：同理。 ","date":"2021-03-23","objectID":"/20210323/:0:2","tags":["RGB","MIPI","显示屏"],"title":"RGB 屏与 MIPI 屏基本知识","uri":"/20210323/"},{"categories":["hardware"],"content":"MIPI 屏 点击展开内容 MIPI（移动行业处理器接口）是 Mobile Industry Processor Interface 的缩写。MIPI（移动行业处理器接口）是 MIPI 联盟发起的为移动应用处理器制定的开放标准。MIPI 并不是一个单一的接口或协议，而是包含了一套协议和标准，以满足各种子系统（图像子系统[摄像头和显示器]、存储子系统、无线子系统、电源管理子系统、低带宽子系统[音频、键盘、鼠标、蓝牙]）独特的要求。 分层结构 层级 解析 Application 层 描述高层编码和解析数据流（类似 485 总线用户定义的控制数据协议） Low Level Protocol 层 定义了如何组帧和解析以及错误检测等（类似 485 总线串口数据帧格式定义） Lane Management 层 发送和收集数据流到每条 lane（类似485总线串口的 RX、TX 控制端定义） PHY 层 定义了传输媒介，输入/输出电路和和时钟和信号机制（类似 485 总线RS485收发器芯片） 规范 所在层级 功能 DCS 规范 Application 层 DCS 是一个标准化的命令集，用于命令模式的显示模组（类似 485 总线用户定义的控制指令） DSI 规范 Low Level Protocol 层 Lane Management 层 定义了一个位于处理器和显示模组之间的高速串行接口（类似 485 总线串口驱动器） D-PHY 规范 PHY 层 提供DSI和CSI的物理层定义（类似 485 总线RS485 收发器芯片） 串行接口 解析 DSI（Display Serial Interface） 定义了一个位于处理器和显示模组之间的高速串行接口 CSI（Camera Serial Interface） 定义了一个位于处理器和摄像模组之间的高速串行接口 接口定义 接口定义 解析 时钟 一个时钟 lane（由两根差分信号线组成） 数据 一个或多个数据 lane（每个都是由两根差分信号线组成） 速度模式 速度 电平 LP 低功耗信号模式（Low-Power signaling mode） 10MHz (max) 0-1.2V（差分） HS 高速信号模式（High-Speed signaling mode） 80Mbps ~ 1Gbps/Lane 100-300mV(200mV)（差分） ","date":"2021-03-23","objectID":"/20210323/:0:3","tags":["RGB","MIPI","显示屏"],"title":"RGB 屏与 MIPI 屏基本知识","uri":"/20210323/"},{"categories":["hardware"],"content":"接口区别 点击展开内容 RGB-TTL、LVDS、MIPI-DSI 接口比较：这些接口区别于信号的类型，也区别于信号内容。 接口类型 接口信号类型 信号内容 RGB-TTL TTL电平 RGB666 或 RGB888 及行场同步和时钟（R、G、B、CLK、HSYNC、VSYNC、DE） LVDS LVDS 信号（低电压差分信号） RGB 数据还有行场同步和时钟（1 组时钟 CLK，4 组 DATA） MIPI-DSI LVDS 信号（低电压差分信号） 视频流数据和控制指令（1 组时钟 CLK，1~4 组 lane） LVDS、MIPI-DSI 接口比较： 接口类型 传输内容 LVDS 传输视频数据 MIPI-DSI 不仅能够传输视频数据，还能传输控制指令 接口类型 信号与格式 LVDS 将 RGB TTL 信号按照 SPWG / JEIDA 格式转换成 LVDS 信号进行传输 MIPI-DSI LVDS 信号进行传输，及按照特定的握手顺序和指令规则传输屏幕控制所需的视频数据和控制数据 ","date":"2021-03-23","objectID":"/20210323/:0:4","tags":["RGB","MIPI","显示屏"],"title":"RGB 屏与 MIPI 屏基本知识","uri":"/20210323/"},{"categories":["hardware"],"content":"参考资料 点击展开内容 网文-1：MIPI DSI 协议介绍 网文-2：STM32F429 » 21. LTDC 液晶屏幕 网文-3：LCD 接口和 RGB 介绍 网文-4：MIPI-DSI、MIPI-CSI、LVDS 等接口解析 网文-5：RGB_TTL、LVDS、MIPI 接口液晶屏学习笔记 ","date":"2021-03-23","objectID":"/20210323/:0:5","tags":["RGB","MIPI","显示屏"],"title":"RGB 屏与 MIPI 屏基本知识","uri":"/20210323/"},{"categories":["MCU"],"content":"获取 ARM 编译后的 ROM 及 RAM 大小方法及原理","date":"2021-03-18","objectID":"/20210318/","tags":["ARM Cortex-M","Keil MDK"],"title":"获取 ARM 编译后的 ROM 及 RAM 大小方法及原理","uri":"/20210318/"},{"categories":["MCU"],"content":"前言 ● 我们常用的 RT-Thread、Free OS 这类的操作系统都有动态内存管理，这段内存是编译后剩余的空间。那么是如何获知 Keil 编译器编译后剩余 RAM 的大小呢？ ● 前些年我做了 IAP 在线升级功能，其中需要程序能获知自己大小。那么又是如何通过特殊语法获取的呢？ ","date":"2021-03-18","objectID":"/20210318/:0:1","tags":["ARM Cortex-M","Keil MDK"],"title":"获取 ARM 编译后的 ROM 及 RAM 大小方法及原理","uri":"/20210318/"},{"categories":["MCU"],"content":"知识 1、RO段、RW段、ZI段 的组成： 名称 组成 RO段 是程序中的指令(Code)和常量(RO-Data) RW段 是程序中已初始化的变量(RW-Data) ZI段 是程序中未初始化的变量(ZI-Data)（默认初始化为0） 2、RO段、RW段、ZI段 的分布： ","date":"2021-03-18","objectID":"/20210318/:0:2","tags":["ARM Cortex-M","Keil MDK"],"title":"获取 ARM 编译后的 ROM 及 RAM 大小方法及原理","uri":"/20210318/"},{"categories":["MCU"],"content":"方法 1、获取 RO段、RW段、ZI段 地址及大小的方法： /*--------------IROM1--------------*/ extern int Image$$ER_IROM1$$RO$$Base; extern int Image$$ER_IROM1$$RO$$Limit; extern int Image$$ER_IROM1$$RO$$Length; #define LINKER_VAR_RO_START ((void *)\u0026Image$$ER_IROM1$$RO$$Base) //RO段起始地址 #define LINKER_VAR_RO_LIMIT ((void *)\u0026Image$$ER_IROM1$$RO$$Limit) //RO段结尾地址的后一个地址 #define LINKER_VAR_RO_SIZE ((void *)\u0026Image$$ER_IROM1$$RO$$Length) //RO段正使用空间的大小（即 _LIMIT - _START） /*--------------IRAM1--------------*/ extern int Image$$RW_IRAM1$$RW$$Base; extern int Image$$RW_IRAM1$$RW$$Limit; extern int Image$$RW_IRAM1$$RW$$Length; #define LINKER_VAR_RW_START ((void *)\u0026Image$$RW_IRAM1$$RW$$Base) //RW段起始地址 #define LINKER_VAR_RW_LIMIT ((void *)\u0026Image$$RW_IRAM1$$RW$$Limit) //RW段结尾地址的后一个地址 #define LINKER_VAR_RW_SIZE ((void *)\u0026Image$$RW_IRAM1$$RW$$Length) //RW段正使用空间的大小（即 _LIMIT - _START） extern int Image$$RW_IRAM1$$ZI$$Base; extern int Image$$RW_IRAM1$$ZI$$Limit; extern int Image$$RW_IRAM1$$ZI$$Length; #define LINKER_VAR_ZI_START ((void *)\u0026Image$$RW_IRAM1$$ZI$$Base) //ZI段起始地址 #define LINKER_VAR_ZI_LIMIT ((void *)\u0026Image$$RW_IRAM1$$ZI$$Limit) //ZI段结尾地址的后一个地址 #define LINKER_VAR_ZI_SIZE ((void *)\u0026Image$$RW_IRAM1$$ZI$$Length) //ZI段正使用空间的大小（即 _LIMIT - _START） /*------------应用例子-------------*/ ro_segment_size = (unsigned int)LINKER_VAR_RO_SIZE; //RO段大小 rw_segment_size = (unsigned int)LINKER_VAR_RW_SIZE; //RW段大小 zi_segment_size = (unsigned int)LINKER_VAR_ZI_SIZE; //ZI段大小 zi_segment_size = (unsigned int)LINKER_VAR_ZI_LIMIT - (unsigned int)LINKER_VAR_ZI_START; //ZI段大小 p_zi = LINKER_VAR_ZI_START; //ZI段起始地址 p_free_ram = LINKER_VAR_ZI_LIMIT; //空闲RAM起始地址 rom_size = ro_segment_size + rw_segment_size; //编译生成bin文件的大小 2、实测 rom_size 与实际 bin 文件大小不同原因： 那是因为编译器做了优化压缩，个人猜想是将RW段中初始化为 0 的变量优化掉，将它移到ZI段。大小差异如下图： ","date":"2021-03-18","objectID":"/20210318/:0:3","tags":["ARM Cortex-M","Keil MDK"],"title":"获取 ARM 编译后的 ROM 及 RAM 大小方法及原理","uri":"/20210318/"},{"categories":["MCU"],"content":"扩展 1、各种编译器的识别宏 ///////////////////////////////////////////////// //用于 ARM 处理器程序识别不同编译器，这些宏用于隐 //藏可由多个编译器编译的代码中与编译器相关的内容： ///////////////////////////////////////////////// // 1、MDK-ARM 使用编译器的宏名称（ARM RealView） #if defined(__CC_ARM) || defined(__CLANG_ARM) // 2、IAR-ARM 使用编译器的宏名称（IAR EWARM） #elif defined(__ICCARM__) // 3、GNU-gcc 使用编译器的宏名称（GNU Compiler Collection） #elif defined(__GNUC__) #endif 2、gcc 环境下获取 ROM、RAM 编译大小的方法 类型 说明 text 代码（Code）和常量（RO-Data）的大小（ROM） data 【已初始化】的全局变量（global）和静态变量（static）的大小（RAM/ROM） bss 【未初始化】的全局变量（global）和静态变量（static）的大小（RAM)。 其值一般默认为零！从 STM32F103 官方的 .ld 链接文件生成的 .map 文件查到，其包括：heap（堆）和 stack （栈）的大小！ dec text + data + bss 的总和值（十进制表示） hex text + data + bss 的总和值（十六进制表示） 补充 1、程序固件大小（ROM）：text + data 2、程序已用内存（RAM）：data + bss（包括：heap 和 stack 的大小） // 在 C 语言中，通过如下方式获取某个分段 // 的起始与结束地址，再由计算可得出大小。 // 具体变量名称在链接脚本中找出！！！！！ extern int _sbss; extern int _ebss; #define LINKER_VAR_ZI_START ((void *)\u0026_sbss) #define LINKER_VAR_ZI_LIMIT ((void *)\u0026_ebss) #define LINKER_VAR_ZI_SIZE (((void *)\u0026_ebss) - ((void *)\u0026_sbss)) 关于 text、data、bss、heap、stack 的分布更多知识，请查阅《linux-STM32F开发-makefile 构建与使用》→【提升】→【关于 text、data、bss、heap、stack 的分布】！ 3、MCU 的堆栈及静态区 RAM 区域 地址分布 说明 （1）静态区（static） 在低地址 存储包括未初化、已初始化的全局变量和静态变量的一块区域！ （2）堆区（heap） 在中地址 一般由程序员分配和释放，若程序员不释放，程序结束时可能由操作系统回收。分配方式类似于数据结构中的链表。通过malloc函数申请，通过free函数释放！堆：向高地址扩展！ （3）栈区（stack） 在高地址 由编译器自动分配和释放，存放函数的参数值、局部变量的值等，其操作方式类似于数据结构中的栈。函数调用及函数退出时自动处理！栈：向低地址扩展！ 4、scatter 分散加载文件 keil 默认使用自定义链接文件 link.sct（scatter 分散加载文件。扩展：对应 gcc 编译器就是链接脚本，文件扩展名一般为 .ld，链接参数 -T，用法如：-Txxx.ld），简单的 IAP 则建议不用它，使用 keil 图形化配置即可（下图）。更多 scatter 分散加载文件知识以后再深入了解，可参考下面几篇网文： 网文 1：《如何在C代码中获取编译后的BIN文件的大小》 网文 2：《keil如何生成scatter文件》 网文 3：《试图搞懂MDK程序下载到flash(二)–分散加载文件scatter》《搞懂MDK的分散加载文件》 ","date":"2021-03-18","objectID":"/20210318/:0:4","tags":["ARM Cortex-M","Keil MDK"],"title":"获取 ARM 编译后的 ROM 及 RAM 大小方法及原理","uri":"/20210318/"},{"categories":["software"],"content":"介绍 X-MACRO 数据与代码序列化的原理及使用","date":"2020-12-24","objectID":"/20201224/","tags":["宏定义","X-MACRO"],"title":"X-MACRO 数据与代码序列化","uri":"/20201224/"},{"categories":["software"],"content":"概述 X-MACRO（X-宏）是一种可靠的维护代码或数据的并行列表技术，其保证这些并行列表以相同（匹配）顺序出现。它可应用于数组、枚举、结构体、列表，以及代码段生成等。X-MACRO 定义的是【汇总集合表】，当使用时可以从它【批量】取出某(几)类元素。 ","date":"2020-12-24","objectID":"/20201224/:0:1","tags":["宏定义","X-MACRO"],"title":"X-MACRO 数据与代码序列化","uri":"/20201224/"},{"categories":["software"],"content":"一、原理与语法 点击展开内容 typedef int (*PF)(void *); const PF pfunc[] = { func_play, func_pause, func_stop, func_play_next, func_play_prev }; 对于上面的数组，我们不希望使用pfunc[0]这种方式来访问，我们希望使用宏pfunc[PLAY]方式来访问，这样可以更直观明了。使用枚举enum {PLAY, PAUSE, STOP, PLAY_NEXT, PLAY_PREV}方式定义每个组员编号对应的宏，但是这样需要维护两个表（要匹配它们相同顺序相同个数），极容易出错。那么如何使用预编译为我们生成组员编号对应的宏呢？ 语法如下：（点击展开） //事先编排的宏与组员关系表（注：DEF_X() 还没有定义，后面使用时才定义-用完即时取消定义） #define XCMD_PFUNC \\ DEF_X(PLAY , func_play ) \\ DEF_X(PAUSE , func_pause ) \\ DEF_X(STOP , func_stop ) \\ DEF_X(PLAY_NEXT, func_play_next) \\ DEF_X(PLAY_PREV, func_play_prev) //利用预编译生成组员编号对应的宏(表)：enum {PLAY, PAUSE, STOP, PLAY_NEXT, PLAY_PREV} typedef enum { #define DEF_X(n,p) n, XCMD_PFUNC #undef DEF_X XCMD_MAX }tXCMD; //利用预编译生成指针数组(表)：pfunc[] = {func_play, func_pause, func_stop, func_play_next, func_play_prev} typedef int (*PF)(void *); const PF pfunc[] = { #define DEF_X(n,p) p, XCMD_PFUNC #undef DEF_X }; ","date":"2020-12-24","objectID":"/20201224/:0:2","tags":["宏定义","X-MACRO"],"title":"X-MACRO 数据与代码序列化","uri":"/20201224/"},{"categories":["software"],"content":"二、通讯的用法 点击展开内容 当我们设计一个播放器时，通过串口开放给第三方控制时，我们协议一般是定义为命令+参数，通过不同的命令来控制播放器执行不同的动作。对命令解码的写法演变如下： 1、常规写法：（点击展开） 这种写法代码结构单一、执行效率高（前提：命令连续），但可读性差、耦合性过高、难维护。 补充说明：此代码不完整，只是为了展示写法。 switch (cmd) { case 0: //播放 /* 略（执行代码 或 调用控制函数） */ break; case 1: //暂停 /* 略（执行代码 或 调用控制函数） */ break; case 2: //停止 /* 略（执行代码 或 调用控制函数） */ break; case 3: //下一曲 /* 略（执行代码 或 调用控制函数） */ break; case 4: //上一曲 /* 略（执行代码 或 调用控制函数） */ break; default: break; } 2、查表写法：（点击展开） 这种写法代码结构简单，可读性好、耦合低、容易维护、灵活、支持命令不连续，不过查表会对效率有一定损耗。 补充说明：此代码不完整，只是为了展示写法。 #define XCMD_PLAY 0 #define XCMD_PAUSE 1 #define XCMD_STOP 2 #define XCMD_PLAY_NEXT 3 #define XCMD_PLAY_PREV 50 struct _tFunc { unsigned char cmd; //命令 int (*pfunc)(void *); //对应执行函数(指针) }; struct _tFunc pfunc[] = { /*------平常只需维护此表-------*/ {XCMD_PLAY , func_play }, {XCMD_PAUSE , func_pause }, {XCMD_STOP , func_stop }, {XCMD_PLAY_NEXT, func_play_next}, {XCMD_PLAY_PREV, func_play_prev} } void player_cmd(unsigned char cmd, void *p) { int i; for (i=0; i\u003csizeof(pfunc)/sizeof(pfunc[0]); i++) { //查表，对效率有一定损耗 if ((pfunc[i].cmd == cmd) \u0026\u0026 (pfunc[i].pfunc != NULL)) { (*pfunc[cmd])(p); return; } } printf(\"cmd(%d) invalid!\\r\\n\", cmd); } 3、X 宏写法：（点击展开） 这种写法代码结构简单、执行效率高，可读性好、耦合低、容易维护，但要求命令必须是连续的。 补充说明：此代码不完整，只是为了展示写法。 #include \u003cstdio.h\u003e //事先编排的宏与组员关系表： /*----------平常只需维护此表----------*/ #define XCMD_PFUNC \\ DEF_X(XCMD_PLAY , func_play ) \\ DEF_X(XCMD_PAUSE , func_pause ) \\ DEF_X(XCMD_STOP , func_stop ) \\ DEF_X(XCMD_PLAY_NEXT, func_play_next) \\ DEF_X(XCMD_PLAY_PREV, func_play_prev) //利用预编译生成函数声明： #define DEF_X(n,p) extern int p(void *); XCMD_PFUNC #undef DEF_X //利用预编译生成组员编号对应的宏(表)： typedef enum { #define DEF_X(n,p) n, XCMD_PFUNC #undef DEF_X XCMD_MAX }tXCMD; //利用预编译生成指针数组(表)： typedef int (*PF)(void *); const PF pfunc[] = { #define DEF_X(n,p) p, XCMD_PFUNC #undef DEF_X }; //命令解码函数 int func_play(void *p) { printf(\"%s() decode\\r\\n\", __FUNCTION__); } int func_pause(void *p) { printf(\"%s() decode\\r\\n\", __FUNCTION__); } int func_stop(void *p) { printf(\"%s() decode\\r\\n\", __FUNCTION__); } int func_play_next(void *p) { printf(\"%s() decode\\r\\n\", __FUNCTION__); } int func_play_prev(void *p) { printf(\"%s() decode\\r\\n\", __FUNCTION__); } //应用与演示 void player_cmd(tXCMD xcmd, void *p) { // xcmd -= 20; //偏移量移到0点位置 if (xcmd \u003c XCMD_MAX) { //直接访问，高效 (*pfunc[xcmd])(p); } else { printf(\"xcmd(%d) invalid!\\r\\n\", xcmd); } } int main(int argc, char *argv[]) { player_cmd(XCMD_PLAY, (void *)0); player_cmd(XCMD_PAUSE, (void *)0); player_cmd(XCMD_PLAY_NEXT, (void *)0); } ","date":"2020-12-24","objectID":"/20201224/:0:3","tags":["宏定义","X-MACRO"],"title":"X-MACRO 数据与代码序列化","uri":"/20201224/"},{"categories":["software"],"content":"三、数据的重构 点击展开内容 在通讯应用中，我们往往使用字节对齐方式定义数据结构体。某特殊情况下，为了提高数据处理效率，我们会把以单字节对齐数据结构体转成默认的多字节对齐数据结构体。利用 X-Macros 实现数据重构，可方便以后代码维护。注意：对有嵌套的结构体可能不支持，但你可以增加宏参数指出特别处理，因为它的灵活性超乎你的想像！ 语法如下：（点击展开） #define XSTRUCT_DATA \\ DEF_XDATA(x, unsigned char) \\ DEF_XDATA(y, unsigned short) \\ DEF_XDATA(z, int) //多字节对齐--------------------------------------- typedef struct { #define DEF_XDATA(var, type) type var; XSTRUCT_DATA #undef DEF_XDATA }tXDATA1; //单字节对齐--------------------------------------- #pragma pack(push,1) //(push)与(pop)要配对, 可以嵌套 typedef struct { #define DEF_XDATA(var, type) type var; XSTRUCT_DATA #undef DEF_XDATA }tXDATA2; #pragma pack(pop) //重构 tXDATA2 数据到 tXDATA1 结构体 void xdata2_to_xdata1(tXDATA1 *const pxdat1, const tXDATA2 *const pxdat2) { #define DEF_XDATA(var, type) \\ memcpy(\u0026(pxdat1-\u003evar), \u0026(pxdat2-\u003evar), sizeof(pxdat1-\u003evar)); XSTRUCT_DATA #undef DEF_XDATA } //重构 tXDATA1 数据到 buffer[] 缓冲 void xdata1_to_buf(unsigned char *buffer, const tXDATA1 *const pxdat1) { #define DEF_XDATA(var, type) \\ memcpy(buffer, \u0026(pxdat1-\u003evar), sizeof(pxdat1-\u003evar)); \\ buffer += sizeof(pxdat1-\u003evar); XSTRUCT_DATA #undef DEF_XDATA } //重构 buffer[] 数据到 tXDATA1 缓冲 void buf_to_xdata1(tXDATA1 *const pxdat1, const unsigned char *buffer) { #define DEF_XDATA(var, type) \\ memcpy(\u0026(pxdat1-\u003evar), buffer, sizeof(pxdat1-\u003evar)); \\ buffer += sizeof(pxdat1-\u003evar); XSTRUCT_DATA #undef DEF_XDATA } ","date":"2020-12-24","objectID":"/20201224/:0:4","tags":["宏定义","X-MACRO"],"title":"X-MACRO 数据与代码序列化","uri":"/20201224/"},{"categories":["software"],"content":"四、知识的扩展 点击展开内容 从上面的例子可以看到，宏定义每行都使用了＼续行符，正常情况是没有什么影响的，但当要想使用#if这些预编译判断语句时，这样就出现问题了（因为#if要求必须是单独占一行，不能与其它语句共用一行）。那么如何解决这个限制问题？用#include包含功能来解决！以播放器为例说明，它有两个版本，新版本才支持上一曲控制： 语法如下：（点击展开） 新建《xmacro.h》文件，在里面添加内容： //《xmacro.h》 DEF_X(PLAY , func_play ) DEF_X(PAUSE , func_pause ) DEF_X(STOP , func_stop ) DEF_X(PLAY_NEXT, func_play_next) #if (SWF_VER == 2) DEF_X(PLAY_PREV, func_play_prev) #endif 使用#include来解决＼续行符限制问题： typedef enum { #define DEF_X(n,p) n, #include \"xmacro.h\" //说明：#include \"xmacro.h\"（语句） 等同 XCMD_PFUNC（前面案例宏调用） //XCMD_PFUNC ↑↑↑↑↑ // xmacro.h（文件内容) 等同 #define XCMD_PFUNC（前面案例宏定义内容） #undef DEF_X XCMD_MAX }tXCMD; typedef int (*PF)(void *); const PF pfunc[] = { #define DEF_X(n,p) p, #include \"xmacro.h\" #undef DEF_X }; 上面只是一些基本功能应用，其实还有很多就高级应用。X-MACRO 里面的内容你尽情利用，你可以用它来生成函数名称、变量声明等，它只是保证为你生成一段相同顺序的东西（数据、代码、声明等）。下面简单做了几个例子，更多应用等你发掘。 例子如下：（点击展开） //打印出所有函数名称 void print_finc(void) { #define DEF_X(n,p) printf(\"int %s(void *)\\n\", #p); XCMD_PFUNC #undef DEF_X } //利用预编译生成函数声明： #define DEF_X(n,p) extern int p(void *); XCMD_PFUNC #undef DEF_X //生成另一组功能函数声明： #define DEF_X(n,p) extern int callback_##p(void *); XCMD_PFUNC #undef DEF_X ","date":"2020-12-24","objectID":"/20201224/:0:5","tags":["宏定义","X-MACRO"],"title":"X-MACRO 数据与代码序列化","uri":"/20201224/"},{"categories":["software"],"content":"介绍 CRC 数据校验原理和应用","date":"2020-12-12","objectID":"/20201212/","tags":["CRC"],"title":"CRC 数据校验原理和应用","uri":"/20201212/"},{"categories":["software"],"content":"一、简介 CRC 循环冗余校验（Cyclic Redundancy Check） 是一种根据网络数据包或计算机文件等数据产生简短固定位数校验码的一种信道编码技术，主要用来检测或校验数据传输或者保存后可能出现的错误。它是利用除法及余数的原理来作错误侦测的。CRC 成为计算机信息通信领域最为普遍的校验方式。常见应用有以太网/USB通信，压缩解压，视频编码，图像存储，磁盘读写等。 常用的校验算法 有奇偶校验、校验和、CRC，还有 LRC、BCC 等不常用的校验算法。 常规数据帧格式 帧头 + 长度 + 数据 + 校验 ","date":"2020-12-12","objectID":"/20201212/:0:1","tags":["CRC"],"title":"CRC 数据校验原理和应用","uri":"/20201212/"},{"categories":["software"],"content":"二、原理 点击展开内容 单纯谈 CRC 的 模 2 除法 其实并不困难，但实际计算中经常会遇到计算出来的结果和实际不一致的情况，这就需要我们知道几个组成部分或者说计算概念：多项式公式、多项式简记式、数据宽度、初始值、输入值反转、输出值反转、结果异或值、参数模型。 多项式公式 对于 CRC 标准除数，一般使用多项式（或二项式）公式表示，例如除数 11011 的二项式为 X4+X3+X+1，X 的指数就代表了该 bit 位上的数据为 1。 多项式简记式（POLY） 通过对 CRC 的基本了解我们知道，多项式的头部和首尾必定为 1，所以就把头部这个 1 给省略掉了，出现了一个叫简记式的东西，例如除数 11011 的简记式为 1011。对于CRC_16标准下 X16+X15+X2+1（0x18005）的 poly 值实际上是 8005，这里使用的就是简记式。 数据宽度（WIDTH） 数据宽度指的就是 CRC 校验码的长度（二进制位数），知道了 CRC 的运算概念和多项式，就可以理解这个概念了，CRC 长度始终要比除数位数少1，与简记式长度是一致的。 ① CRC 初始值（INIT） 在一些标准中，规定了运算寄存先赋初始值，之后才会与原始数据进行运算。初始值位数要求与数据宽度一致。 ② 输入值反转（REFIN - 是/否） 输入值反转的意思是在计算之前先将二项式反转，之后一直用得到的新值和数据进行计算。如对于 X16+X15+X2+1（0x18005），其正向值为 1 1000 0000 0000 0101，反转值则为 1010 0000 0000 0001 1 ③ 输出值反转（REFOUT - 是/否） 输出值反转则是将与多项式运算后得到最终的 CRC 结果进行反转。例如计算得到的 CRC 值：0x97 = 1001 0111，如果 REFOUT 为 true，进行翻转之后为 1110 1001 = 0xE9。 通常，输入值反转后的结果值也会是反转的，所以这两个选项一般是同向的，我们只有在在线CRC计算器中会看到自由选择正反转的情况存在。 ④ 结果异或值（XOROUT） 在所有运算得出的最后 CRC 结果值与[结果异或值]进行一次异或计算，得到的最终值才是我们需要的 CRC 校验码。结果值的位数要求与数据宽度一致。 模2除法运算例子：设需要发送的信息为 1010001101，产生多项式为 110101（共6bit），则发送信息后面需要加5个0，然后对信息做模2除法运算，得余数为 01110。故实际需要发送的数据是 1010001101（信息）01110（校验）。 以上内容主要解析 CRC 基本概念及原理，下面三图才是实际使用的 CRC 种类和运算过程： ","date":"2020-12-12","objectID":"/20201212/:0:2","tags":["CRC"],"title":"CRC 数据校验原理和应用","uri":"/20201212/"},{"categories":["software"],"content":"三、使用 点击展开内容 比如由网友whik分享的C语言版本： https://gitee.com/whik/crc-lib-c 直接把“crcLib.c”“crcLib.h”加入工程使用即可。 uint16_t crc16; uint32_t crc32; unsigned char datasrc[13] = {12, 214, 234, 3, 4, 5, 89, 21, 48, 92, 14, 7, 10}; //要运算的数据 crc16 = crc16_usb(datasrc, sizeof(datasrc)); //计算CRC crc32 = crc32_mpeg_2(datasrc, sizeof(datasrc)); //计算CRC 补充说明： 为什么我们使用 STM32 处理器的 CRC 硬件运算器 与 crc32_mpeg_2()或 网上一些 CRC 计算工具计算的结果不一样？ 那是因为 STM32 处理器为小端数据处理方式，CRC 规则要求为大端数据处理方式；同时 STM32 处理器 CRC 硬件运算器以 4 字节对齐方式处理，最后几字节不足 4 字节需要用户补齐（如：补齐填充 0）。 标准的 CRC 函数的入口以及内部处理都是以字节作为基本处理单元，这样可避免出现大小端格式问题，所以用户调用计算函数时无须关心大小端问题。 ","date":"2020-12-12","objectID":"/20201212/:0:3","tags":["CRC"],"title":"CRC 数据校验原理和应用","uri":"/20201212/"},{"categories":["software"],"content":"四、工具 点击展开内容 CRC 在线计算工具 CRC 离线计算工具下载-CRC_Calc v0.1 CRC 离线计算工具下载-格西CRC计算器 ","date":"2020-12-12","objectID":"/20201212/:0:4","tags":["CRC"],"title":"CRC 数据校验原理和应用","uri":"/20201212/"},{"categories":["software"],"content":"简单介绍 MD5 对数据加密与校验的应用","date":"2020-12-11","objectID":"/20201211/","tags":["MD5"],"title":"MD5 对数据加密与校验","uri":"/20201211/"},{"categories":["software"],"content":"一、前言 对于网络传输的数据，无非就是三点要求：一、保证数据传输的正确性；二、防止数据被篡改；三、对数据进行加密。对于前两点要求，普遍使用 MD5 来处理。 ","date":"2020-12-11","objectID":"/20201211/:0:1","tags":["MD5"],"title":"MD5 对数据加密与校验","uri":"/20201211/"},{"categories":["software"],"content":"二、介绍 点击展开内容 MD5 的全称是 Message-Digest Algorithm 5，在90年代初由 MIT 的计算机科学实验室和 RSA Data Security Inc 发明，经 MD2、MD3 和 MD4 发展而来。MD5 将任意长度的“字节串”变换成一个 128bit（即：16字节） 的大整数，相当于这串数据的“数据指纹”。主要用于确保信息传输完整一致，更多用在文档校验上，用来生成密钥检测文档是否被篡改。是计算机广泛使用的摘要算法（哈希算法）之一，主流编程语言普遍已有 MD5 实现。 MD5 算法具有以下特点： 压 缩 性：任意长度的数据，算出的 MD5 值长度都是固定的。 容易计算：从原数据计算出 MD5 值很容易。 抗修改性：对原数据进行任何改动，哪怕只修改1个字节，所得到的 MD5 值都有很大区别。 强抗碰撞：已知原数据和其 MD5 值，想找到一个具有相同 MD5 值的数据（即伪造数据）是非常困难的。 不可逆性：加密过程本身就是一个有损的加密过程，因此几乎不能还原出原始数据。 ","date":"2020-12-11","objectID":"/20201211/:0:2","tags":["MD5"],"title":"MD5 对数据加密与校验","uri":"/20201211/"},{"categories":["software"],"content":"三、用途 点击展开内容 本人理解它有三大类用途： 校验数据传输/存储是否出错。例如：我们使用电脑读取文件时，曾经就遇过提示文件破损。那么电脑如何知道文件破损了？其原理就是读文件前先运算 MD5 码，再与文件保存那时存储的 MD5 码进行比较，MD5 码不一样，那就说明文件破损了。 校验用户密码，保护用户隐私。例如：在手机输入登录某网站密码，手机 APP 发送的是由密码生成的 MD5 码给网站服务器。服务器则是使用用户注册密码生成的 MD5 码与手机 APP 发来的 MD5 码进行比较。如果一样，则表示密码正确。这样的好处是保护用户密码在传输过程中不被泄漏。（补注：实际应用中服务器是不保存用户原始密码，只保存 MD5 码，这样连服务器也不知道用户原始密码，可以更有效保护用户私隐） 校验证书的唯一性，防止证书或内容被篡改。例如：一个简单支付业务操作，把用户支付帐号、支付金额、支付密码拼接起来生成 MD5 码证书，最后把支付帐号、支付金额、MD5 码证书三项内容发给支付平台进行支付操作。因为坏人不知道你密码，如果他中途拦截并恶意篡修支付金额，但支付平台使用相同方法运算的 MD5 码证书发现不一致，就会拒绝本次支付操作，这样就有效地保护用户的支付安全。 ","date":"2020-12-11","objectID":"/20201211/:0:3","tags":["MD5"],"title":"MD5 对数据加密与校验","uri":"/20201211/"},{"categories":["software"],"content":"四、应用 点击展开内容 比如由网友 talent518 分享的 C 语言版本： https://github.com/talent518/md5 直接把“md5.c”“md5.h”加入工程使用即可。 MD5_CTX md5; //MD5对象 unsigned char datasrc[13] = {12, 214, 234, 3, 4, 5, 89, 21, 48, 92, 14, 7, 10}; //要运算的数据 unsigned char decrypt[16]; //结果寄存器 //每次运算 MD5 码，必须依次调用 3 个函数进行操作 MD5Init(\u0026md5); //初始化 MD5Update(\u0026md5, datasrc, sizeof(datasrc)); //导入数据（此处可以多次导入多段数据） MD5Final(\u0026md5, decrypt); //计算并输出 16 字节 MD5 到 decrypt[] ","date":"2020-12-11","objectID":"/20201211/:0:4","tags":["MD5"],"title":"MD5 对数据加密与校验","uri":"/20201211/"},{"categories":["linux"],"content":"linux 调试仿真工具","date":"2020-09-16","objectID":"/20200916/","tags":["调试","GNU","GDB","CGDB","linux 工具/应用"],"title":"linux 调试仿真工具","uri":"/20200916/"},{"categories":["linux"],"content":"一、前言 GDB（GNU symbolic debugger）是 Linux 平台下使用最多的一款调试器，常用命令虽不多，但操作起来真心不方便。操作不方便、代码不能高亮、不能边看代码边调试，这几点应该是造成很多人不愿意长期使用的原因（后来集成 TUI 模式有所改善，在调试窗口按Ctrl+X+A进入/退出 TUI 模式）。CGDB 可以看作 GDB 的界面增强版，用来替代 GDB 的 gdb-tui。CGDB 主要功能是在调试时进行代码的同步显示，这无疑增加了调试的方便性，提高了调试效率。由于界面类似 vi，符合 unix/linux 下开发人员习惯，所以如果熟悉 gdb 和 vi，几乎可以立即使用 CGDB。除此之外，还有更强更好用的 GDB 前端软件（如：Emacs GDB），具体请参考网文：《Linux 终端调试大全》，其转自 《终端调试哪家强》。 ","date":"2020-09-16","objectID":"/20200916/:0:1","tags":["调试","GNU","GDB","CGDB","linux 工具/应用"],"title":"linux 调试仿真工具","uri":"/20200916/"},{"categories":["linux"],"content":"二、安装 1、GDB 的安装 GDB（GNU symbolic debugger）是 Linux 平台下使用最多的一款调试器，是 GNU 开源组织发布的一个强大的 Linux 下的程序调试工具，除支持 c/c++ 语言外还支持 go、D、object-c、fortran 等语言调试。资料：GNU 官网、GDB 主页、GDB 官网下载。 1.1、linux 系统下安装： ########################################## # 安装：直接下载最新版安装 ########################################## wget http://ftp.gnu.org/gnu/gdb/gdb-12.1.tar.gz # 下载gdb软件 tar -xzvf gdb-12.1.tar.gz # 解压文件 cd gdb-12.1 # 进入文件夹 ./configure --prefix=/usr/local/gdb-12.1 # 手工修改配置，并设置安装目录 sudo gedit /etc/profile # 打开环境变量，在文件最后添加内容：export PATH=$PATH:/usr/local/gdb-12.1/bin source /etc/profile # 使能环境变量。 sudo apt-get install texinfo # 安装依赖工具。（有些网文提到还要安装另一依赖：https://ftp.gnu.org/gnu/termcap/termcap-1.3.1.tar.gz） sudo apt-get install libgmp-dev # 安装依赖工具。（官网：https://gmplib.org/） make # 编译GDB软件， sudo make install # 安装GDB软件。 gdb --version # 查看GDB版本。（验证是否安装成功） ########################################## # 处理：多版本共存处理方法 ########################################## #####首先修改软件名称##### sudo mv /usr/bin/gdb /usr/bin/gdb-old # 旧版gdb改名 （因将要创建gdb 的快捷方式处于同名同路径下，所以旧版本必须要改名） sudo mv /usr/bin/gdbserver /usr/bin/gdbserver-old # 旧版gdbserver改名（因将要创建gdbserver的快捷方式处于同名同路径下，所以旧版本必须要改名） #####加版本优先级方法##### # 注意要把之前在环境变量加入的软件执行文件路径移除，否则可能会冲突！ sudo update-alternatives --install /usr/bin/gdb gdb /usr/bin/gdb-old 999 --slave /usr/bin/gdbserver gdbserver /usr/bin/gdbserver-old sudo update-alternatives --install /usr/bin/gdb gdb /usr/local/gdb-12.1/bin/gdb 121 --slave /usr/bin/gdbserver gdbserver /usr/local/gdb-12.1/bin/gdbserver #####选择工作版本方法##### sudo update-alternatives --config gdb # 选择gdb工作版本，根据界面提示输入对应数字+回车选择 # ● 原理只是快捷方式链接不同对象 ● #####移除某优先级方法##### sudo update-alternatives --remove gdb /usr/local/gdb-12.1/bin/gdb # 移除gdb-12.1版的优先级（将从优先级列表中移除） 1.2、安装出错问题记录： 1.2.1、编译 gdb-12.1 提示的错误 2、CGDB 的安装 CGDB 可以看作 GDB 的界面增强版（其参考了 GDB TUI 设计和实现），分上下两屏，【上屏】代码区的界面模仿了 Unix 经典的文本编辑器界面：vi，【下屏】还是 GDB 的命令窗口，所以如果熟悉 vi 和 gdb，几乎可以立即使用 CGDB。官方提供源码编译安装方式，用户到 官网 或 github 下载源码，然后自己编译并安装程序。资料：CGDB 中文手册。 ###################################### # 一、安装相关依赖软件 ###################################### sudo apt install autoconf # 安装 autotools 系列工具，包括：autoconf,automake,aclocal,autoheader,autoscan sudo apt install libtool-bin # 安装 libtool 工具 sudo apt install bison # 安装 bison 工具 sudo apt install flex # 安装 flex 工具 sudo apt install texinfo # 安装依赖 sudo apt install libreadline6 # 安装依赖 sudo apt install libreadline6-dev # 安装依赖 sudo apt install libreadline-dev # 安装依赖 sudo apt install libncurses5-dev # 安装依赖 sudo apt install libncursesw5-dev # 安装依赖 ###################################### # 二、下载、编译、安装 ###################################### git clone https://github.com/cgdb/cgdb.git # 下载（使用git工具克隆仓库） cd cgdb # 进入文件夹 ./autogen.sh # 自动生成配置（文件）（前提需要安装依赖：sudo apt-get install autoconf automake libtool-bin） ./configure --prefix=/usr/local/cgdb # 手工修改配置，并设置安装目录 sudo gedit /etc/profile # 打开环境变量，在文件最后添加内容：export PATH=$PATH:/usr/local/cgdb/bin source /etc/profile # 使能环境变量。 make # 编译CGDB软件 sudo make install # 安装CGDB软件 cgdb --version # 查看CGDB版本（验证是否安装成功） ","date":"2020-09-16","objectID":"/20200916/:0:2","tags":["调试","GNU","GDB","CGDB","linux 工具/应用"],"title":"linux 调试仿真工具","uri":"/20200916/"},{"categories":["linux"],"content":"三、使用 ■【使用的演示工程说明】■ 本文主要基于【3_large】工程来演示，同时已将 CGDB/GDB 调试启动命令加到工程 Makefile 里，事前先配置父 Makefile 中的DEBUG = 1，再编译生成执行文件后，最后直接运行make debug即可启动 CGDB/GDB 调试。特别说明：一、使用 CGDB/GDB 调试程序，在编译时必须增加-g选项参数，否则只能汇编调试而无法源码调试！二、CGDB（v0.8.0）要求 GDB 版本≥7.12（如果 GDB 过低，CGDB 调用 GDB 时会抛出错误）！ 1、CGDB/GDB 的启动方式 #########【方式一】######### cgdb -d gdb ./build/objs/app.exe # 启动cgdb+gdb,并装载调试文件（嵌入式调试文件为 xxx.elf） tb main # 在gdb里:在main函数设置临时断点 r # 在gdb里:运行程序（如果程序有入口参数，写法如：r ./build/objs/app.exe argv1 argv2） #【备注】嵌入式 arm-none-eabi-gdb 不能使用 run 指令来运行程序！改用 c 直接运行程序即可！ #########【方式二】######### cgdb -d gdb # 启动cgdb+gdb file ./build/objs/app.exe # 在gdb里:装载调试文件（嵌入式调试文件为 xxx.elf） tb main # 在gdb里:在main函数设置临时断点 r # 在gdb里:运行程序（如果程序有入口参数，写法如：r ./build/objs/app.exe argv1 argv2） #【备注】嵌入式 arm-none-eabi-gdb 不能使用 run 指令来运行程序！改用 c 直接运行程序即可！ #########【方式三】######### cgdb -d gdb -x gdb.script # 启动cgdb+gdb,并装载GDB命令脚本文件 # gdb.script 命令脚本文件内容为： # file ./build/objs/app.exe # tb main # r #########【方式四】######### cgdb -d gdb -ex 'file ./build/objs/app.exe' -ex 'tb main' -ex 'r' # 启动cgdb+gdb,并自动在GDB里运行多条命令（适合 makefile 里直接调用命令运行调试） #【知识扩展】 # -iex 在GDB本体外执行一条命令（如：GDB调试程序前先执行启动openocd服务） # -ex 在GDB本体内执行一条命令（如：执行一条GDB的r命令） # -x 从文件获取并运行多条GDB命令 #【嵌入式 arm-none-eabi-gdb 案例】 # cgdb -d arm-none-eabi-gdb \\ # -ex 'set remotetimeout 60' \\ # -iex 'target extended-remote | openocd -c \"gdb_port pipe\" -f \"interface/jlink_swd.cfg\" -f \"target/stm32f1x.cfg\"' \\ # -ex 'monitor sleep 1000' \\ # -ex 'monitor reset halt' \\ # -ex 'monitor sleep 1000' \\ # -ex 'file ../build/gcc/rt-thread.elf' \\ # -ex 'load' \\ # -ex 'tb main' \\ # -ex 'c' ########################### #【其它应用知识】 ########################### gdb out/app.exe 1234 # 调试已经运行的程序（1234 为 ps aux 命令查看 out/app.exe 程序对应的 PID 数值） gdb -p 1234 # 同上，忽略执行程序名称 gdb out/app.exe core.9579 # core.9579 为程序异常挂掉时候生成的core文件，我们可以直接对这个core文件进行分析 运行结果： 补充：由于 CGDB 启动时调用 GDB 运行，所以 CGDB 与 GDB 启动是一致的。如果想直接运行 GDB，开头命令去除cgdb -d语句即可，其它命令完全一样（其实都是 GDB 内部命令）！上面介绍几种启动方式，前两种是分多条分多次命令输入执行，如果每次都这样操作，效率会很低，时间久了一些命令可能会忘记了！所以在实际开发中，使用类似“一键”启动方式（方式四），里面的几条命令由脚本调用执行。 2、CGDB/GDB 的退出方法 # 1、如果程序正在运行 Ctrl+c键 # 按ctrl+c组合键强制暂停程序 # 2、当程序已暂停运行 Ctrl+d键 # 按ctrl+d组合键退出GDB， q # 或输入quit命令退出GDB。 # 备注：在CGDB代码窗口输入【:q】也可直接并强制退出！ 运行结果： 3、CGDB/GDB 的视窗切换 ########################### # CGDB 视窗切换 ########################### o键 # 打开CGDB文件列表窗口（可查找及打开对应源文件） q键 # 退出CGDB文件列表窗口 i键 # 切换进入GDB命令视窗 Esc键 # 切换回CGDB代码视窗 Ctrl+[键 # 切换回CGDB代码视窗 -键 # 减小CGDB代码视窗大小（也可使用 _键 快速减小） =键 # 增大CGDB代码视窗大小（也可使用 +键 快速增大） ########################### # GDB 视窗切换 ###########################（特别说明：在CGDB里不要执行下面命令，有冲突会花屏，且不能关闭） layout src # 显示源代码窗口　(关闭/重开:ctrl+x+a) layout asm # 显示汇编代码窗口　(关闭/重开:ctrl+x+a) layout regs # 显示寄存器窗口　(关闭/重开:ctrl+x+a) focus src # 将焦点移到源代码窗口　(上下方向键和PageUp/PageDown键浏览内容) (focus /ˈfəʊkəs/) focus asm # 将焦点移到汇编代码窗口 (上下方向键和PageUp/PageDown键浏览内容) focus regs # 将焦点移到寄存器窗口　(上下方向键和PageUp/PageDown键浏览内容) winheight src -5 # 代码窗口減少5行 各类窗口： 特别说明：在 CGDB 里不要执行 GDB 视窗切换命令layout，有冲突会花屏，且不能关闭！ 4、CGDB/GDB 的调试操作 4.01、CGDB 类 vi 操作 ########################### # 1、光标操作 ########################### k键 # 向上移动一行 j键 # 向下移动一行 h键 # 向左移动一列 l键 # 向右移动一列 gg键 # 移动到文件顶部 G键 # 移动到文件底部 Ctrl+b键 或 Page Up键 # 向上翻一页 Ctrl+f键 或 Page Down键 # 向下翻一页 Ctrl+u键 # 向上翻半页 Ctrl+d键 # 向下翻半页 ########################### # 2、搜索操作 ########################### /键 # 启动从当前光标处向下搜索（之后输入搜索字符串后按回车，支持正则表达式） ?键 # 启动从当前光标处向上搜索（之后输入搜索字符串后按回车，支持正则表达式） n键 # 向下继续搜索 N键 # 向上继续搜索 ########################### # 3、调试操作 ########################### F5键 # 运行程序(重新运行程序)，即向GDB发送一个run命令 F6键 # 恢复运行(直至遇到断点)，即向GDB发送一个continue命令 F7键 # 完成运行并跳出当前函数，即向GDB发送一个finish命令 F8键 # 单步运行(不进入子函数)，即向GDB发送一个next命令 F10键 # 单步运行(会进入子函数)，即向GDB发送一个step命令 空格键 # 当前行设置(或取消)断点 t键 # 当前行设置(或取消)临时断点 4.02、GDB 命令r -------- run #################################### # 命令作用: 运行程序 # 命令简写: r # 命令全写: run # 单　词: run #################################### r #【运行程序】运行程序（以默认/上次方式运行） run app.exe argv1 argv2 #【运行程序】指定执行文件及参数运行程序 # 特别说明：对于嵌入式 arm-none-eabi-gdb 不能使用 run 指令来运行代码！直接使用 c 运行程序即可。 4.03、GDB 命令c -------- continue #################################### # 命令作用: 继续运行程序 # 命令简写: c # 命","date":"2020-09-16","objectID":"/20200916/:0:3","tags":["调试","GNU","GDB","CGDB","linux 工具/应用"],"title":"linux 调试仿真工具","uri":"/20200916/"},{"categories":["linux"],"content":"三、扩展 1、IDE 集成开发环境的组成 组件 说明 代码编辑工具 IDE 直接使用 QScitinal 这类的编辑器库 代码智能提示 IDE 后台调用 clang 工具 语法错误检测 IDE 后台调用 gcc 或者 clang 对代码语法错误动态检测 工程文件组织 IDE 使用的是 makefile，后台调用 make 工具 编译 IDE 后台调用 gcc 或者 clang 编译器编译 调试器 IDE 后台调用 OpenOCD 连接调试器和板子 下载 IDE 后台调用 OpenOCD 命令下载固件 调试 IDE 后台调用 gdb，给 gdb 发命令，gdb 再给 OpenOCD 发命令，OpenOCD 再指挥调试器控制板子。实现单步执行，查看变量值，寄存器等 2、CGDB/GDB 在 STM32F 上的应用 《linux-STM32F开发㈠-makefile 构建与使用》 《linux-STM32F开发㈡-调试器的安装与使用》 《linux-STM32F开发㈢-在线调试工具CGDB》 ","date":"2020-09-16","objectID":"/20200916/:0:4","tags":["调试","GNU","GDB","CGDB","linux 工具/应用"],"title":"linux 调试仿真工具","uri":"/20200916/"},{"categories":["linux"],"content":"linux 编译构建工具使用","date":"2020-09-15","objectID":"/20200915/","tags":["编译","GNU","GCC","linux 工具/应用"],"title":"linux 编译构建工具","uri":"/20200915/"},{"categories":["linux"],"content":"前言 Linux 下可用的编译器有 GCC、LLVM-clang、EGCS 和 PGCC，其中 GCC 是绝对的老大！GCC（GNU Compiler Collection）是由 GNU 开发的编程语言译器套件。GNU 编译器套件包括 C、C++、Objective-C、Fortran、Ada、Go 及 D 语言前端，也包括了这些语言的库（如：libstdc++，libgcj 等） 1、关于工具链关系 ●CMake【构建工具】（跨平台构建工具），其将程序员编写的 CMakeLists.txt 文件转化 makefile 文件，调用 make 执行命令，make 调用 gcc 执行编译工作。 ●make 【脚本工具】（执行编译规则脚本工具），用于解释执行 Makefile 脚本的命令工具。 ●makefile【脚本语言】（定义编译规则的脚本语言），用于描述了整个工程的编译、链接等规则，调用 GCC（也可以是其它编译器，如：clang）命令执行编译、链接动作。 ●gcc【编译器】，用于编译源文件，链接生成执行文件。 ●gdb【调试器】，用于调试 c/c++ 程序，也可以调试 Ada、Objective-C、Pascal 及其它语言。 2、关于交叉编译器 GNU 的 GCC 主要用于编译电脑软件，主要针对 x86 体系的处理器；对于 ARM 、MIPS 等体系的处理器，我们需要使用交叉编译器（如：arm-none-linux-gnueabi-gcc）来编译，其过程：先在电脑上使用交叉编译器编译生成执行文件，再将执行文件复制/烧录到控制板上运行。 3、工具或源码下载 工具 源码包 make 官网下载、清华镜像 gcc 官网下载、清华镜像 ","date":"2020-09-15","objectID":"/20200915/:0:1","tags":["编译","GNU","GCC","linux 工具/应用"],"title":"linux 编译构建工具","uri":"/20200915/"},{"categories":["linux"],"content":"一、gcc 编译器 1、linux 系统下安装 ● 1.1、Ubuntu 系统下的在线安装 在 Ubuntu 下安装 GCC 和其他一些 Linux 系统有点不一样。默认的 Ubuntu 存储库包含一个名为build-essential的元包，它包含 GCC 编译器以及编译软件所需的许多库和其他实用程序。 #####方法一##### sudo apt update #首先更新包列表， sudo apt install build-essential #安装`build-essential`软件包， gcc --version #查看 gcc 版本用于验证是否安装成功。 #####方法二##### # sudo apt-get build-dep gcc #安装`gcc` # gcc -v #查看 gcc 版本用于验证是否安装成功。 #####方法三##### # sudo apt-get install gcc #安装`gcc` # sudo apt-get install g++ #安装`g++` # gcc -v #查看 gcc 版本用于验证是否安装成功。 1.2、Ubuntu 下在线安装最新版 因为个别工程需要多个 GCC 的编译器或者是库来支持，我们可能需要在同一个 Linux 系统当中安装多个 GCC 版本来实现支持的目的。从低版本到高版本，以及最新版本的 GCC，都可从 Ubuntu Toolchain PPA 获得。虽然 Ubuntu 官方软件仓库尽可能囊括所有的开源软件，但仍有很多软件包由于各种原因不能进入官方软件仓库，为了方便 Ubuntu 用户使用，Ubuntu 为软件开发者提供了 launchpad 平台来创建自己的 repositories（仓库）提供了个人软件包集，即 PPA（Personal Package Archives）个人软件包档案。从网上找到的 ppa:ubuntu-toolchain-r/test 支持很多 gcc 版本，列表【Package】项表示 gcc 软件包名称，【Version】项表示具体版本及支持 Ubuntu 版本，例如：版本10.3.0-1ubuntu1~20.04表示 gcc 10.3.0 以及支持 Ubuntu 20.04（备注：原以为支持 1~20.04 全部版本，结果测试 Ubuntu 16.04 提示找不到软件包，即是只支持 Ubuntu 20.04）。其实从 gcc 官网也找到此作者的仓库，其路径：https://gcc.gnu.org\u003e\u003eDownload\u003e\u003eBinaries → GFortran Wiki → GNU/Linux\u003e\u003eMost Linux distributions offer gfortran packages → Ubuntu\u003e\u003eminor updates（小更新）或 new testing versions（新的测试版本）。 #####安装仓库以及gcc方法##### sudo apt install software-properties-common #安装`PPA`仓库工具（只需安装一次） sudo add-apt-repository ppa:ubuntu-toolchain-r/test #加入`PPA`仓库 sudo apt update #更新`PPA`仓库信息 sudo apt install gcc-9 g++-9 #安装`GCC`和`G++`(需要安装什么版本就输入什么版本) #如果没找到软件包，则提示“E: Unable to locate package XXX” #####加gcc版本优先级方法##### #注意要把之前在环境变量加入的软件执行文件路径移除，否则可能会冲突！ sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-9 90 --slave /usr/bin/g++ g++ /usr/bin/g++-9 sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-5 999 --slave /usr/bin/g++ g++ /usr/bin/g++-5 #备注：①我的系统 Ubuntu 16.04 已安装：gcc 5.4.0；②上面的 --slave 的 g++ 表示的工作版本由 gcc 配置决定 #####选择gcc工作版本方法##### sudo update-alternatives --config gcc #选择gcc工作版本，根据界面提示输入对应数字+回车选择 #####移除专用PPA仓库方法##### sudo add-apt-repository --remove ppa:ubuntu-toolchain-r/test #移除上面加入的PPA仓库 #####移除gcc某优先级方法##### sudo update-alternatives --remove gcc /usr/bin/gcc-9 #移除 gcc 9 的优先级（将从优先级列表中移除） 1.3、Ubuntu 下自己编译与安装 待续…… 2、windows 下安装 ● 2.1、可选工具： ● GNU 并没提供 Windows 的 GCC 版本，但我们可以安装第三方制作的 GCC Windows 版本，其中集成 GCC 编译器的软件主要有：MinGW/MinGW-w64、TDM-GCC、Cygwin。 2.2、工具区别： ● MinGW/MinGW-w64（Minimalist GNU for Windows）是为 windows 系统打造的编译器套件，其主要是把 GNU 的 gcc、make 等编译工具移植到 Windows 平台下，使得原是在 linux 写的 C 源代码可以在 windows 上编译及运行（exe 执行文件）。 ● TDM-GCC 衍生自 MinGW 和 MinGW-w64 的项目（功能是一样的），也是分为 32 位与 64 位两个版本，32 位版本的编译目标仅兼容 32 位应用程序，64 位版本的编译目标兼容 32 和 64 位应用程序。TDM-GCC 对比 MinGW-w64 会集成更新的 gcc 编译器，目前集成的版本为 GCC 10.3.0。 ● Cygwin 是一个在 windows 平台上运行的类 unix 模拟环境，其集成绝大部分的 linux 软件包（其中就包括 GCC 编译工具）。 2.3、工具特点： ● Cygwin 大而全面，提供完整的类 Unix 环境，凡是在 Cygwin 环境中编译构建的软件在运行时必须依赖 cygwin1.dll 库文件。 ● MinGW / MinGW-w64 / TDM-GCC 小而高效，其主要是编译器，一般只支持编译使用 C/C++ 标准库的程序。 2.4、工具安装： ● 关于 Cygwin 的安装与使用，请移步《linux-工具-linux 模拟环境 cygwin》。 ● 关于 MinGW-w64 的安装与使用，请移步《MinGW-w64 编译套件(GNU 工具集)》。 ● 下载 TDM-GCC 编译工具，不需要勾选检测是否最新版本，直接点击Creat安装即可，最后在命令窗口输入gcc -v可查看 gcc 版本。特别说明：查看 make 版本的命令为mingw32-make -v。 3、GCC 的编译方法 ● 3.1、一步编译方法： gcc -o hello hello.c # 1步完成:预处理-\u003e编译-\u003e汇编-\u003e链接（可多个C文件编译） 3.2、两步编译方法： gcc -c -o hello.o hello.c -I./inc # 编译 (生成二进制机器码) → Makefile 中一般都是使用两步编译方式（[-I]为源文件的包含文件所在路径(如:头文件所在路径[./inc])）（绝大部分选项参数都在编译这里设置） gcc -o hello hello.o # 链接 (生成可执行文件)　→ Makefile 中一般都是使用两步编译方式（链接时常用选项参数：-Txxx.lds -Wl,-Map=xxx.map,--cref -Wl,--gc-sections） 3.3、多步编译方法： # ┌→指定生成文件名 （可多个C文件编译） gcc -E -o hello.i hello.c # 预处理(经过预处理的C原始程序) ┐ gcc -S -o hello.s hello.i # 编译 (编译生成汇编语言代码) ├→ ★助记★: 选项-\u003eESc, 生成文件-\u003eiso gcc -c -o hello.o hello.s # 汇编 (汇编生成二进制机器码) ┘ gcc -o hello hello.o # 链接 (链接生成可执行文件) 4、GCC 的编译参数 ● # 一些编译常用选项 gcc --version # 查看gcc版本 gcc -v # 查看gcc版本(包括配置参数信息) gcc -x c xxxx.b -x none hello.c # 忽略文件类型强制以C文件类型编译[xxxx.b]，自动识别文件类型编译[hello.c] gcc -std=c99 hello.c -o hello # 使用[C99]标准编译（gcc 默认使用的是 C89 的标准，而 -std=gun99 是 GNU 的 C99，及 -std=gnu11 是 C11 与 GNU 的拓展）） gcc -static hello.c -o hello # 静态编","date":"2020-09-15","objectID":"/20200915/:0:2","tags":["编译","GNU","GCC","linux 工具/应用"],"title":"linux 编译构建工具","uri":"/20200915/"},{"categories":["linux"],"content":"二、交叉编译器 1、交叉编译器命名规则 ● 1.1、arch(架构)-vendor(厂商)-os(系统)-eabi(接口) 分类 说明 arch（架构） 体系架构：ARM 、MIPS、x86 等 vendor（厂商） 工具链的供应商：苹果、none（无供应商）等 os（系统） 目标的操作系统：linux、none（裸机）等 eabi（接口） 嵌入式应用二进制接口：eabi、gnueabi 等 arch # 'ɑːrtʃ vendor # 'vendə(r) eabi # Embedded Application Binary Interface # ɪm'bedɪd 'baɪnəri 1.2、abi 与 eabi 的区别 ● ABI： 二进制应用程序接口。在计算机中，应用二进制接口描述了应用程序（或者其他类型）和操作系统之间或其他应用程序的低级接口。 ● EABI：嵌入式 ABI。嵌入式应用二进制接口指定了文件格式、数据类型、寄存器使用、堆积组织优化和在一个嵌入式软件中的参数的标准约定。开发者使用自己的汇编语言也可以使用 EABI 作为与兼容的编译器生成的汇编语言的接口。 ● 两者区别总结：ABI 用于计算机上，EABI 用于嵌入式平台上（如 ARM，MIPS 等）。 2、arm 框架交叉编译器 ● 2.1、armcc armcc 是 ARM 公司推出的商用收费编译工具，功能和 arm-none-eabi-gcc 类似，用于编译裸机程序（u-boot、kernel、单片机程序），但是不能编译 Linux 应用程序。armcc 一般和 ARM 开发工具一起，例如 Keil MDK、ADS、RVDS 和 DS-5 中的编译器都是 armcc。 2.2、arm-none-eabi-gcc arm-none-eabi-gcc 为 ARM 框架、无供应商、无系统、嵌入式二进制接口的交叉编译器，一般适合 ARM7、Cortex-M、Cortex-R 内核的芯片使用，它使用的是 newlib 这个专用于嵌入式系统的 C 库，用于编译裸机程序（u-boot、kernel、单片机程序），但是不能编译 Linux 应用程序。注意：交叉编译器目前都是 32 位执行程序，依赖 32 位库，事前需要安装 ia32-libs（网文）或 lsb-core。进入网页选择你需要的版本下载：官网最新版、官网 2021 版、Ubuntu-launchpad 软件开发者平台 及依赖 lsb-core。补充：关于 Windows 版本，为直接安装文件，双击安装即可，还有安装后需要手工加入环境变量【如图】。 wget https://launchpad.net/gcc-arm-embedded/5.0/5-2016-q3-update/+download/gcc-arm-none-eabi-5_4-2016q3-20160926-linux.tar.bz2 #下载交叉编译器压缩包 sudo tar -xjvf gcc-arm-none-eabi-5_4-2016q3-20160926-linux.tar.bz2 -C /usr/lib/gcc #将交叉编译器压缩包解压到：/usr/lib/gcc sudo gedit /etc/profile #打开环境变量,在文件最后添加内容：export PATH=$PATH:/usr/lib/gcc/gcc-arm-none-eabi-5_4-2016q3/bin source /etc/profile #使能环境变量。 sudo apt-get install lsb-core #64位操作系统需要安装32位依赖库：lsb-core （arm-none-eabi-gcc 用到） sudo apt-get install lib32ncurses5 #64位操作系统需要安装32位依赖库：lib32ncurses5（arm-none-eabi-gdb 用到） arm-none-eabi-gcc -v #查看版本(验证是否安装成功) #arm-none-eabi-gcc hello.c -o hello #编译一个程序例子 2.3、arm-none-linux-gnueabi-gcc arm-none-linux-gnueabi-gcc 是 Codesourcery 公司（目前已经被 Mentor 收购）基于 GCC（使用 Glibc 库）推出的的 ARM 交叉编译器。主要用于基于 ARM 架构的 Linux 系统，可用于编译 ARM 架构的 u-boot、Linux 内核、linux 应用等。一般 ARM9、ARM11、Cortex-A 内核，带有 Linux 操作系统的会用到。注意：交叉编译器目前都是 32 位执行程序，依赖 32 位库，事前需要安装 ia32-libs（网文）或 lsb-core。 wget http://www.codesourcery.com/sgpp/lite/arm/portal/package4571/public/arm-none-linux-gnueabi/arm-2014.05-29-arm-none-linux-gnueabi-i686-pc-linux-gnu.tar.bz2 #下载交叉编译器压缩包 sudo tar -xjvf arm-2014.05-29-arm-none-linux-gnueabi-i686-pc-linux-gnu.tar.bz2 -C /usr/lib/gcc #将交叉编译器压缩包解压到：/usr/lib/gcc sudo gedit /etc/profile #打开环境变量,在文件最后添加内容：export PATH=$PATH:/usr/lib/gcc/arm-2014.05/bin source /etc/profile #使能环境变量。 sudo apt-get install lsb-core #64位操作系统需要安装32位依赖库：lsb-core （arm-none-eabi-gcc 用到） sudo apt-get install lib32ncurses5 #64位操作系统需要安装32位依赖库：lib32ncurses5（arm-none-eabi-gdb 用到） arm-none-linux-gnueabi-gcc -v #查看版本(验证是否安装成功) #arm-none-linux-gnueabi-gcc hello.c -o hello #编译一个程序例子 不同系统/软件环境下的版本 ● Linux 解压版：在 Linux 系统（如：Ubuntu、RedHat 等）直接解压即可使用。推荐方式！ ● Linux 安装版：在 Linux 系统下执行后按照提示安装后使用。 ● Windows 解压版：在 Windows 系统下解压后使用，但是需要 MinGW32。 ● Windows 安装版：在 Windows 系统下安装后使用。 ● 源码版：交叉编译器源代码，按需编译生成相应版本。 下面为多种版本下载，同时增加网友博文提供的网盘下载： Linux 解压版 网友网盘 arm-2006q1-3-arm-none-linux-gnueabi-i686-pc-linux-gnu.tar.bz2 网盘 arm-2006q1-6-arm-none-linux-gnueabi-i686-pc-linux-gnu.tar.bz2 网盘 arm-2006q3-26-arm-none-linux-gnueabi-i686-pc-linux-gnu.tar.bz2 网盘 arm-2007q1-10-arm-none-linux-gnueabi-i686-pc-linux-gnu.tar.bz2 网盘 arm-2007q1-21-arm-none-linux-gnueabi-i686-pc-linux-gnu.tar.bz2 网盘 arm-2007q3-51-arm-none-linux-gnueabi-i686-pc-linux-gnu.tar.bz2 网盘 arm-2008q1-126-arm-none-linux-gnueabi-i686-pc-linux-gnu.tar.bz2 网盘 arm-2008q3-41-arm-none-linux-gnueabi-i686-pc-linux-gnu.tar.bz2 网盘 arm-2008q3-72-arm-none-linux-gnueabi-i686-pc-linux-gnu.tar.bz2 网盘 arm-2009q1-176-arm-none-linux-gnueabi-i686-pc-linux-gnu.tar.bz2 网盘 arm-2009q1-203-arm-none-linux-gnueabi-i686-pc-linux-gnu.bz2 网盘 arm-2009q3-67-arm-none-linux-gnueabi-i686-pc-linux-gnu.tar.bz2 网盘 arm-2010.09-50-arm-none-linux-gnueabi-i686-pc-linux-gnu.tar.bz2 网盘 arm-2010q1-202-arm-none-linux-gnueabi-i686-pc-linux-gnu.tar.bz2 网盘 arm-2011.03-41-arm-none-linux-gnueabi-i686-pc-linux-gnu.tar.bz2 网盘 arm-2012.09-64-arm-none-linux-gnu","date":"2020-09-15","objectID":"/20200915/:0:3","tags":["编译","GNU","GCC","linux 工具/应用"],"title":"linux 编译构建工具","uri":"/20200915/"},{"categories":["linux"],"content":"三、make+Makefile 脚本 1、make、Makefile 关系 ● ● make是一个脚本工具，用于解释执行 Makefile 脚本的命令工具。 ● makefile是脚本语言，用于描述整个工程的编译、链接等规则，调用 GCC（也可以是其它编译器，如：clang）命令执行编译、链接动作。脚本文件默认名称为 Makefile 或 makefile。 2、make 命令的使用方法 ● make 命令常用格式为：make [选项] [目标(操作)]。 make 命令是用来解释和执行 Makefile 脚本命令，所以[目标(操作)]是由 Makefile 脚本提供的，如果不指出则 make 工具默认执行 Makefile 中的第一个目标。 2.1、【目标】目标的名称约定常常有以下惯例： 目标名称 作用 all 表示编译所有并生成执行文件 install 表示安装刚刚生成的执行文件 clean 表示清除全部目标及执行文件 distclean 表示清除全部目标及执行文件，包括 Makefile dist 包装成一个压缩文件以供发布 distcheck 同上，并检查压缩包是否正常 2.2、【选项】选项参数较少用到，其主要包括： 选项 含义 -ffilename 指定执行名称为 filename 的 Makefile 文件 -Cdirname 指定执行目录为 dirname（Makefile 文件所在目录） -e 不允许在 Makefile 中替换环境变量的赋值 -k 执行命令出错时，放弃当前目标，继续维护其他目标 -n 按实际运行时的执行顺序模拟执行命令（包括用 @ 开头的命令），没有实际执行效果，仅仅用于显示执行过程 -p 显示 Makefile 中所有的变量和内部规则 -r 忽略内部规则 -s 执行但不显示命令，常用来检查 Makefile 的正确性 -S 如果执行命令出错就退出 -t 修改每个目标文件的创建日期 -I 忽略运行 make 中执行命令的错误 -V 显示 make 的版本号 2.3、【返回】make 命令执行后的三个返回码： 选项 含义 0 表示成功执行，则返回【0】 1 如果 make 运行时出现任何错误，则返回【1】 2 如果你使用了make的“-q”选项，并且 make 使得一些目标不需要更新，则返回【2】 2.4、【步骤】配置、编译、安装/卸载： 步骤 作用 configure 配置操作。configure 是一个 shell 脚本，它可以自动设定源程序以符合各种不同平台上 Unix 系统的特性，并且根据系统参数及环境产生合适的 Makefile 文件或是 C 的头文件，让源程序可以很方便地在这些不同的平台上被编译连接。待续…… make 编译操作（操作第一个目标） make install 安装操作 2.5、【使用】演示例子： 在命令窗口运行命令： make # 默认执行 Makefile 第一个目标 make all # 指定执行 Makefile 目标为 all（常见目标：all、install、clean） make -f mkf # 同`make` , 只是 Makefile 文件名称为 mkf make -f mkf all # 同`make all`，只是 Makefile 文件名称为 mkf 3、Makefile 的语法+例子 ● 3.1、【语法：基本知识】 3.1.1、Makefile 包含五项内容：1、显性规则，2、隐性规则，3、变量定义，4、文件指示，5、注释。 分类 使用 显性规则 书写者明显指出依赖文件或命令操作等规则 隐性规则 make 自动推导依赖文件或命令操作等规则 变量定义 变量只是定义一串字符串，其相当于宏定义 文件指示 预处理（引用另一个 Makefile、哪些代码不处理、变量定义处理） 注释 “#”为行注释符（没块注释，强烈建议独占一行并且在行首加“#”注释），如果需要使用“#”字符，则书写格式为\\# 3.1.2、Makefile 处理文件分为：目标、依赖。其中目标分为：实目标、伪目标。 分类 含义 实目标 真正要生成的以文件形式存放在磁盘上的目标（最终的目标只能是一个）。如果想生成多个实目标（文件），则在伪目标的依赖中加入若干个其它实目标（文件）。 伪目标 伪目标不要求生成实际的文件，它后面可以没有依赖文件（也可以加别的目标），它主要是用于完成一些辅助操作。其中典型案例：clean:清除操作。 多目标 一句依赖中有多个目标，它只是语法一种表达，实质多目标就是根据规则拆解为多个的单目标语句，目的只是简化书写。 关系 处理方式 目标与依赖的执行顺序关系 先执行最深层的依赖，再逐级往上执行目标！每对目标与依赖的执行总规则：尝试创建或更新目标文件（ include 包含文件同理）！ 目标与依赖的搜索对象关系 只要目标有依赖，make 工具就会尝试在搜索目录中寻找依赖文件是否存在或者是否为别的目标。如果都为否，则 make 运行就会抛出错误！备注：Makefile 搜索目录为当前 Makefile 根目录及 VPATH、vpath 设置的目录。 目标与依赖的路径定义关系 目标文件在书写时没写明路径表示为当前 Makefile 根目录文件，有写明路径就是指定目录文件。依赖文件没写明路径时由 Makefile 搜索目录中找出文件（优先搜索当前 Makefile 根目录文件），有写明路径时就是指定目录中找出文件（没找出可能还会尝试从搜索目录找出）；如果最后依赖文件没找出时，就会从另一个同路径同名称的目标中尝试生成！总结：对于实目标和实依赖，都必须现场得出确定的路径，之后才可以进一步的操作。备注：Makefile 搜索目录为当前 Makefile 根目录及 VPATH、vpath 设置的目录。 目标与依赖的规则执行关系 只有目标文件不存在或依赖文件更新（依赖新于目标），才会去运行规则(执行他们下面的操作命令)！对于编译工作来说，依赖就是代码的源文件与头文件，只有依赖文件发生改变，才会编译更新目标，否则不执行（会提示：无更新或已更新）！如果想重新全编译，则需要删除全部中间目标文件再运行编译！ 目标与依赖的包含文件关系 当使用 include 包含文件时，同时还会运行固有规则：搜索与包含文件同路径同名称的目标并尝试运行规则！具体有如下：只有当【包含文件存在】并且【没找到对应目标 或 对应目标无依赖 或 对应实目标新于依赖】才放弃运行规则，否则必定运行规则（它优先在用户操作的所有目标前执行以下规则：尝试创建或更新包含文件，并执行同路径同名称目标命令）。除上面情形外，当出现包含文件不存在、或找不到对应目标都会抛出错误！ 3.1.3、Makefile 整体执行顺序： 整体执行顺序 1、读入主 Makefile 2、读入被include包含进来的其他 Makefile 3、初始化文件中的变量 4、推导隐性规则，并分析所有规则 5、为所有的目标文件创建依赖关系链 6、根据依赖关系，决定哪些目标要重新生成 7、执行生成命令 3.1.4、Makefile 几个重要特殊字符：$ # ; \\ % * ? ~ -。 特殊字符 作用 $$$$ 随机号，自动产生的一个随机编号 $$ 变量符，是访问一个 shell 命令中定义的变量（如：$$var），而非 makefile 的变量。如果某规则在同一个 shell 运行多条命令，则这些命令之间使用“;”连接起来，这样命令相互之间共享变量；否则（多行命令或空格分隔命令）相互之间为没有关联的 shell 命令，不能共享变量 $ 变量符，定义一串字符串，其相当于宏定义。如：$(abc) 表示变量 abc # 注释符，如果通过 \\# 转义则为普通的 # 字符 ; 分隔符，命令与命令之间加入“;”，表示同一 shell 执行命令，可继承前面命令结果（典型例子：cd ~/123/ ; pwd 则结果是“~/123/”，否则是原目录下！） \\ 转义符 或 换行符（注意：换行符后面不能有任何字符，包括空格！） % 通配符，表示匹配零个或若干字符 * 所有符，表示任意一个或多个字符。如：*.c 表示所有 C 文件 ? 任一符，表示任意一个字符 或 对新的变量或文件执行操作 ~ 家目录。也可以指定用户目录（~xiaomin/test 表示用户 xiaomin 的宿主目录下的 test 目录），但 windows 系统需要由环境变量“HOME”决定 3.1.5、Makefile 命令前缀 命令前缀 作用 不加前缀 输出（打印）命令本身，输出（打印）命令执行的结果 @ 在命令前面加@，表示只输出命令执行的结果，不输出命令本身 - 在命令前面加-，表示忽略 Makefile 因命令出错而终止运行，典型应用：-include包含源码文件依赖信息，在源码文件依赖信息文件没创建(不存在)时忽略错误 3.1.6、Makefile 常用文件类型： 文件类型 unix/linux windows 描述 源文件 .c… .c… 源代码文件 关系文件 .d .d 源文件依赖关系信息，GNU 组织建议用编译器为每一个源文件自动生成依赖关系的内容放到一个文件中 中间文件 .o .obj 中间目标文件，是二进制机器码，把它们链接起来就是执行文件 库文件 .a .so .lib .dll 由于源文件太多，编译生成的中间目标文件太多，或是某个相对独立功能模块，可以打包为一个库文件 执行文件 .exe 执行文件（在 Windows 系统中编译生成的目标(PC 软件)必须要加.exe后缀，否则每次编译都会重新生成目标） 3.1.7、Ma","date":"2020-09-15","objectID":"/20200915/:0:4","tags":["编译","GNU","GCC","linux 工具/应用"],"title":"linux 编译构建工具","uri":"/20200915/"},{"categories":["linux"],"content":"四、相关的编译构建工具 CMake Qmake XMake Meson SCons BusyBox Autotools 待续…… ","date":"2020-09-15","objectID":"/20200915/:0:5","tags":["编译","GNU","GCC","linux 工具/应用"],"title":"linux 编译构建工具","uri":"/20200915/"},{"categories":["software"],"content":"简单介绍面向对象思维方式的 C 语言实现方法","date":"2020-09-13","objectID":"/20200913/","tags":["面向对象"],"title":"面向对象思维方式的 C 语言实现方法","uri":"/20200913/"},{"categories":["software"],"content":"一、前言 面向对象编程，也就是大家说的 OOP（Object Oriented Programming）。面向对象的三个基本特征：封装、继承、多态。 封装：根据职责将属性(参数)和方法(函数)封装到一个抽象的类中。 继承：指可以让某个类型的对象获得另一个类型的对象的属性的方法。 多态：以封装和继承为前提，相同的方法调用不同的子类对象，产生不同的执行结果。 备注：本文只是简单介绍面向对象的概念，以及使用 C 语言实现的方法，为以后介绍一些面向对象功能模块打基础。 ","date":"2020-09-13","objectID":"/20200913/:0:1","tags":["面向对象"],"title":"面向对象思维方式的 C 语言实现方法","uri":"/20200913/"},{"categories":["software"],"content":"二、特征 1、封装 封装：根据职责将属性(参数)和方法(函数)封装到一个抽象的类中。以显示屏作为一个例子，显示屏最重要一个属性(参数)是分辨率大小，以及几个基本方法(行为)是初始化、读、写： 补充说明：显示屏的读写操作入口参数还有其它参数（如：x、y 坐标等），这里为了简单，不深入显示屏具体操作。 2、继承 继承：指可以让某个类型的对象获得另一个类型的对象的属性的方法。继承与派生区别：只是角度不同，继承是从子类的角度讲的，派生是从基类的角度讲的。 以显示屏作为一个例子，新进了一个显示屏，其硬件支持待机操作： 补充说明：如果子类想操作父类的一些操作，只需把子类指针强制转成父类指针，之后按父类操作规范操作即可。 3、多态 多态：以封装和继承为前提，相同的方法调用不同的子类对象，产生不同的执行结果。它衍生两个概念：类（class）和 对象（object）。以显示屏作为一个例子，支持多种接口类型显示屏： ","date":"2020-09-13","objectID":"/20200913/:0:2","tags":["面向对象"],"title":"面向对象思维方式的 C 语言实现方法","uri":"/20200913/"},{"categories":["linux"],"content":"linux 集成开发工具 Eclipse 安装与使用","date":"2020-08-04","objectID":"/20200804/","tags":["Eclipse","IDE","linux 工具/应用"],"title":"linux 开发工具 Eclipse","uri":"/20200804/"},{"categories":["linux"],"content":"Eclipse 简介 Eclipse 是一个开放源代码的、基于 Java 的可扩展开发平台。就其本身而言，它只是一个框架和一组服务，用于通过插件组件构建开发环境。 ","date":"2020-08-04","objectID":"/20200804/:0:1","tags":["Eclipse","IDE","linux 工具/应用"],"title":"linux 开发工具 Eclipse","uri":"/20200804/"},{"categories":["linux"],"content":"Ubuntu 平台 系统版本：16.04.7（ubuntu-16.04.7-desktop-amd64.iso） 软件版本：4.14.0（eclipse-cpp-2019-12-R-linux-gtk-x86_64.tar.gz）【官网最新版】【4.14各种开发语言版】 官方网址：https://www.eclipse.org 软件依赖：JDK（因为 Eclipse 是用 Java 编写的 IDE） 软件简介 ● Eclipse 是一个用 Java 所撰写 IDE，因此可跨平台，所以在 Linux 和 Windows 平台下皆可使用 Eclipse，可降低程序员熟悉 IDE 的学习曲线。Eclipse 虽然主要拿来开发 Java 程序，但事实上 Eclipse 为一个『万用语言』的 IDE，只要挂上 plugin 后，就可以在 Eclipse 开发各种语言程序，所以我们只要挂上 CDT(C/C++ Development Toolkit) 后，就可以在 Eclipse 开发 C/C++ 程序了。（具体介绍请查看百度百科） 版本说明 ● 经常用到的是前五个版本： Eclipse IDE for Java EE Developers：是为 J2EE 开发的版本； Eclipse Classic：是 Eclipse 的经典版本(纯净版)，没有插件需要自己安装； Eclipse IDE for Java Developers：适用于 Java 开发； Eclipse IDE for C/C++ Developers：适用于 C/C++ 开发； Eclipse for Mobile Developers：适用于 Java 手机开发； Eclipse for RCP/Plug-in Developers：用于 RCP 和插件开发； 不同的 Eclipse 版本之间就是 plugins/features 目录下的文件不同而已。 初时安装 Eclipse 2020-06 (4.16)，使用时出现各种各样问题，基于兼容性稳定性以及插件支持度考虑，最后选用大约半年前一个版本：Eclipse 2019-12 (4.14) 来安装（使用过程中暂未发现问题）。 Eclipse 的发行版本： 代号 平台版本 项目 主要版本发行日期 N/A 3.0 [1] N/A 2004-6-21 N/A 3.1 N/A 2005-6-28 Callisto 3.2 Callisto projects 2006-6-30 Europa 3.3 Europa projects 2007-6-29 Ganymede 3.4 Ganymede projects 2008-6-25 Galileo 3.5 Galileo projects 2009-6-24 Helios 3.6 Helios projects 2010-6-23 Indigo 3.7 Indigo projects 2011-6-22 Juno 4.2 [2] Juno projects 2012-6-27 Kepler 4.3 Kepler projects 2013-6-26 Luna 4.4 Luna projects 2014-6-25 Mars 4.5 Mars projects 2015-6-24 Neon 4.6 2016-6-22 Oxygen 4.7 2017-6-28 Photon 4.8 2018-6-27 4.9 2018-09 4.10 2018-12 4.11 2019-03 4.12 2019-06 4.13 2019-09 4.14 2019-12 4.15 2020-03 4.16 2020-06 安装步骤 ● 3.1. 将压缩包解压（如图） # 解压 eclipse 压缩包到 opt 文件夹 sudo tar -zxvf eclipse-cpp-2019-12-R-linux-gtk-x86_64.tar.gz -C /opt 3.2. 制作启动脚本（如图） # 在/usr/bin目录下创建一个启动脚本eclipse，执行下面的命令来创建： sudo gedit /usr/bin/eclipse # 然后在该文件中添加以下内容（注意：#!/bin/sh 后必须使用 \\n 来换行!）： #!/bin/sh export MOZILLA_FIVE_HOME=\"/usr/lib/mozilla/\" export ECLIPSE_HOME=\"/opt/eclipse\" $ECLIPSE_HOME/eclipse $* # 再修改该脚本的权限，让它变成可执行，执行下面的命令： sudo chmod +x /usr/bin/eclipse 3.3. 添加应用图标（如图） # 在应用程序菜单上添加一个图标，执行下面的命令： sudo gedit /usr/share/applications/eclipse.desktop # 然后在该文件中添加以下内容（注意：行尾不能有空格!）： [Desktop Entry] Encoding=UTF-8 Name=Eclipse Comment=Eclipse IDE Exec=/opt/eclipse/eclipse Icon=/opt/eclipse/icon.xpm Terminal=false StartupNotify=true Type=Application Categories=Application;Development; # 再修改该应用图标的权限，让它变成可执行，执行下面的命令： sudo chmod +x /usr/share/applications/eclipse.desktop 网文：《Linux Desktop Entry 文件深入解析》，IBM Developer 中文网站，专为开发者打造的技术资源平台。 3.4. 运行应用方法（如图） 点击左上角的 Search your computer 功能图标，再输入 Eclipse，单击下面显示 Eclipse 图标打开即可。 3.5. 创建桌面启动（如图） 在 /usr/share/applications 目录下将 Eclipse 图标右键复制到桌面，双击桌面图即可打开软件。 3.6. 相关注意事项 如果按照上述方法安装了 eclipse 后能够创建图标但是运行不起来 eclipse，就可能是 Linux 位数与 Eclipse 的位数不一致！我就因为一时疏忽遇到这个问题，浪费了很多时间。 运行工程 ● 以 littlevGL/LVGL 开源的 GUI 演示工程作为例子说明 Eclipse 的基本使用： 4.1. 先从 github 下载 LVGL 整套 Eclipse 工程代码（网址） # 克隆LVGL项目（注：--recursive 用于把当前项目依赖的一些项目同时下载下来） git clone --recursive https://github.com/littlevgl/pc_simulator_sdl_eclipse.git 补注：关于 git 相关知识，请查《git学习笔记》。 4.2. 安装 gcc 和 g++ 编译工具链 sudo apt-get install gcc g++ 4.3. 安装 SDL 库（官网） 介绍：SDL 库的作用说白了就是封装了复杂的视音频底层操作，简化了视音频处理的难度。SDL（Simple DirectMedia Layer）是一套开放源代码的跨平台多媒体开发库，使用 C 语言写成。SDL 提供了数种控制图像、声音、输出入的函数，让开发者只要用相同或是相似的代码就可以开发出跨多个平台（Linux、Windows、Mac OS X 等）的应用软件。目前 SDL 多用于开发游戏、模拟器、媒体播放器等多媒体应用领域。SDL 使用 GNU 宽通用公共许可证为授权方式，意指动态链接（dynamic link）其库并不需要开放本身的源代码。因此诸如《雷神之锤4》等商业游戏也使用 SDL 来开发。 网文：《SDL 库安装、环境配置与使用》 sudo apt-get update \u0026\u0026 sudo apt-get install -y build-essential libsdl2-dev 4.4. 安装 CDT 插件（如图）（官网） 插件介绍：因为 Eclipse 是用 Java 开发的，其原设计主要进行 Jave 开发。如果要进行 C/C++ 开发，则需要安装一个 CDT 插件，不过现在官方已把 CDT 插件集成到了安装包里，可以在官网选择【Eclipse IDE for C/C++ Developers】下载就可以了。 手动安装： a) 在菜单打开：Help / Install New Software… / Add（进入另一个窗口操作） b) 在窗口上输入内容并点击 Add 按钮（本例 CDT 版本只能匹配 Eclipse 4.14.0）： Name: CDT Location: http://download.eclipse.org/tools/cdt/releases/9.10 c) 在窗口操作：SelectAll / Next / Next / 选择同意 / Finsh（进入另一个窗口操作） 注意事项：CDT 与 Eclipse 的版本必须要匹配！ 关于 CDT 各个版本汇总网址：https://www.eclipse.org/cdt/downloads.php 4.5. 导入工程（如图） File / Import / General / Ex","date":"2020-08-04","objectID":"/20200804/:0:2","tags":["Eclipse","IDE","linux 工具/应用"],"title":"linux 开发工具 Eclipse","uri":"/20200804/"},{"categories":["linux"],"content":"linux JAVA 开发环境 JDK 安装简介","date":"2020-08-03","objectID":"/20200803/","tags":["JDK","JAVA","linux 工具/应用"],"title":"linux JAVA 开发环境 JDK","uri":"/20200803/"},{"categories":["linux"],"content":"JDK 简介 JDK 是 Java 语言的软件开发工具包，主要用于移动设备、嵌入式设备上的 java 应用程序。JDK 是整个 java 开发的核心，它包含了 JAVA 的运行环境（JVM+Java系统类库）和 JAVA 工具。 ","date":"2020-08-03","objectID":"/20200803/:0:1","tags":["JDK","JAVA","linux 工具/应用"],"title":"linux JAVA 开发环境 JDK","uri":"/20200803/"},{"categories":["linux"],"content":"Ubuntu 平台 系统版本：16.04.7（ubuntu-16.04.7-desktop-amd64.iso） 软件版本：1.8.0_221（jdk-8u221-linux-x64.tar.gz (密码: m3eh)）【官网最新版】 官方网址：https://www.oracle.com 一、软件简介 工具 功能 JDK 开发工具包 JRE 运行环境 JVM Java 虚拟机 ● １.１、JDK 包含 JRE，JRE 包含 JVM。也可以说 JDK 是 JRE+Java 的开发工具。JRE 包含了 JVM+Java 语言的核心类库。JDK 用于开发，是给开发人员用的。JRE 用于运行 java 程序，和 JVM 一起是给普通用户使用的。如果只是运行 Java 程序，可以只安装 JRE，无需安装 JDK。也就是说：使用 JDK 开发完成的 java 程序，交给 JRE 去运行。 ● １.２、OracleJDK 替代版：AdoptOpenJDK，支持平台广泛。可到国内镜像【清华大学开源软件镜像站（tuna）】下载。Oracle 读音 /ˈɔːrəkl/；Adopt 读音 /əˈdɒpt/。 ● １.３、OpenJDK 可能有兼容问题，比如最近我在安装 eclipse 时就遇到了 OpenJDK 不能用的问题，所以最后还是建议安装 oracle jdk。 二、版本说明 ● ２.１、JAVA 有 3 个版本：J2SE、J2EE、J2ME，分别面向桌面应用、企业级应用、手机移动领域的应用。（注：JAVA 就是指 JDK 开发工具，所以我们可以理解为 JAVA 等价于 JDK） ● ２.２、关于版本的选择，推荐使用 jdk8（1.8.0），目前企业大多数都用的 jdk8，而且 jdk8 可以说是一个很经典的版本，虽然 oracle 停止维护了 jdk8。另外 JDK9/JDK10 这种非 LTS 还是别花力气了，直接上 JDK11，因为 Java11 是 Java8 后的首个长期支持版本。 ● ２.３、JDK 的历史版本（JDK 发行说明）： 版本 名称 发行日期 JDK 1.0 Oak(橡树) 1996-01-23 JDK 1.1 none（无） 1997-02-19 JDK 1.1.4 Sparkler（宝石） 1997-09-12 JDK 1.1.5 Pumpkin（南瓜） 1997-12-13 JDK 1.1.6 Abigail（阿比盖尔–女子名） 1998-04-24 JDK 1.1.7 Brutus（布鲁图–古罗马政治家和将军） 1998-09-28 JDK 1.1.8 Chelsea（切尔西–城市名） 1999-04-08 J2SE 1.2 Playground（运动场） 1998-12-04 J2SE 1.2.1 none（无） 1999-03-30 J2SE 1.2.2 Cricket（蟋蟀） 1999-07-08 J2SE 1.3 Kestrel（美洲红隼） 2000-05-08 J2SE 1.3.1 Ladybird（瓢虫） 2001-05-17 J2SE 1.4.0 Merlin（灰背隼） 2002-02-13 J2SE 1.4.1 grasshopper（蚱蜢） 2002-09-16 J2SE 1.4.2 Mantis（螳螂） 2003-06-26 Java SE 5.0 (1.5.0) Tiger（老虎） 2004-09-30 Java SE 6.0 (1.6.0) Mustang（野马） 2006-04 Java SE 7.0 (1.7.0) Dolphin（海豚） 2011-07-28 Java SE 8.0 (1.8.0) Spider（蜘蛛） （LTS 长期支持版本） 2014-03-18 Java SE 9.0 none（无） 2017-09-21 Java SE 10.0 none（无） 2018-03-21 Java SE 11.0 none（无） （LTS 长期支持版本） 2018-09-25 Java SE 12.0 none（无） 2019-03 Java SE 13.0 none（无） 2019-09 Java SE 14.0 none（无） 2020-03 Java SE 15.0 none（无） 2020-10 Java SE 16.0 none（无） 2021-04 Java SE 17.0 none（无） （LTS 长期支持版本） 2021-10 Java SE 18.0 none（无） 2022-04 三、安装步骤 3.1. 将压缩包解压（如图） # 解压 jdk 压缩包到 opt 文件夹 sudo tar -zxvf jdk-8u221-linux-x64.tar.gz -C /opt 3.2. 环境变量配置（如图） # 执行命令打开文件进行编辑： sudo gedit /etc/profile # 在打开的文件末尾添加如下脚本代码： export JAVA_HOME=/opt/jdk1.8.0_221 #定义变量（路径） export JRE_HOME=$JAVA_HOME/jre #定义变量（路径） export CLASSPATH=.:$JAVA_HOME/lib:$JRE_HOME/lib:$CLASSPATH #环境变量：`CLASSPATH`是[javac]编译器专用的一个环境变量 export PATH=$JAVA_HOME/bin:$JRE_HOME/bin:$PATH #环境变量：普通可执行文件路径 扩展知识：环境变量 ● 介绍：环境变量主要的目的是告诉系统知道应用程序所在哪个路径下，让系统可直接运行应用程序（如果应用程序已在系统标准位置下，则不需要增加环境变量。linux系统几个标准位置：/bin、/sbin、/usr/bin、/usr/sbin、/usr/local/bin等）。在安装一些软件（特别是工具链）时，必须要配置环境变量。对于 linux 系统环境变量，主要在两个文件增加环境变量：/etc/profile和/root/.bashrc，不过用户主目录上有个~/.bash_profile文件只对这个用户有效。配置环境变量后，还需要使用命令或重启系统才能生效。（参考网址） ● 语法：export PATH=$PATH:路径1:路径2:…:路径n ● 解析：export在子 shell 运行应用程序，不写时表示在当前 shell 运行。$PATH表示增加环境变量，注意不要漏掉。:为分隔符。$表示一个变量，如下面代码$JAVA_HOME代表/opt/jdk1.8.0_221的变量。 ● 注意：与 Windown 系统不同，linux 系统使用冒号分隔，而不是分号。 3.3. 环境变量生效（如图） # 文件保存退出后执行命令使环境变量即时生效： source /etc/profile 3.4. 查看 jdk 版本（如图） # 执行命令查看jdk版本信息（能查出版本信息表示安装成功） java -version ","date":"2020-08-03","objectID":"/20200803/:0:2","tags":["JDK","JAVA","linux 工具/应用"],"title":"linux JAVA 开发环境 JDK","uri":"/20200803/"},{"categories":["linux"],"content":"介绍 Ubuntu 系统及工具的安装","date":"2020-08-02","objectID":"/20200802/","tags":["Ubuntu","linux 工具/应用"],"title":"Ubuntu 系统与工具","uri":"/20200802/"},{"categories":["linux"],"content":"一、系统篇 1. Ubuntu 系统下载 虚拟机版本：VMware-Workstation-10.0.7 系统的版本：Ubuntu-16.04.7、【网易镜像】 官方网下载：http://releases.ubuntu.com/xenial Ubuntu 中文论坛 2. Ubuntu 版本说明 Ubuntu 系统是一个以桌面应用为主的 Linux 操作系统，Ubuntu 基于 Debian 发行版和 GNOME 桌面环境。Ubuntu 的目标在于为一般用户提供一个最新的、同时又相当稳定的主要由自由软件构建而成的操作系统，它可免费使用，并带有社团及专业的支持。 版本 别名（codename） 发布日期 4.10 Warty Warthog(长疣的疣猪) 2004年10月20日 5.04 Hoary Hedgehog(灰白的刺猬) 2005年4月8日 5.10 Breezy Badger(活泼的獾) 2005年10月13日 6.06 Dapper Drake(整洁的公鸭) 2006年6月1日(LTS) 6.10 Edgy Eft(急躁的水蜥) 2006年10月6日 7.04 Feisty Fawn(坏脾气的小鹿) 2007年4月19日 7.10 Gutsy Gibbon(勇敢的长臂猿) 2007年10月18日 8.04 Hardy Heron(耐寒的苍鹭) 2008年4月24日(LTS) 8.10 Intrepid Ibex (勇敢的野山羊) 2008年10月30日 9.04 Jaunty Jackalope(得意洋洋的怀俄明野兔) 2009年4月23日 9.10 Karmic Koala(幸运的考拉) 2009年10月29日 10.04 Lucid Lynx(清醒的猞猁) 2010年4月29日 11.10 Oneiric Ocelot(梦幻的豹猫) 2010年10月13日 11.04 Natty Narwhal(敏捷的独角鲸) 2011年4月28日 12.04 Precise Pangolin(精准的穿山甲) 2012年的4月26日(LTS) 12.10 Quantal Quetzal(量子的绿咬鹃) 2012年的10月20日 13.04 Raring Ringtail(铆足了劲的猫熊) 2013年4月25日 13.10 Saucy Salamander(活泼的蝾螈) 2013年10月17日 14.04 Trusty Tahr (可靠的塔尔羊) 2014年4月18日 (LTS) 14.10 Utopic Unicorn(乌托邦独角兽) 2014年10月23日 15.04 Vivid Vervet (活泼的小猴) 2015年4月 15.10 Wily Werewolf (狡猾的狼人) 2015年10月 16.04 Xenial Xerus (好客的非洲地松鼠) 2016年4月 （LTS） 16.10 Yakkety Yak（牦牛） 2016年10月 17.04 Zesty Zapus(开心的跳鼠) 2017年4月 17.10 Artful Aardvark(机灵的土豚) 2017年10月 18.04 Bionic Beaver（仿生海狸） 2018年4月(LTS) 18.10 Cosmic Cuttlefish（宇宙乌贼） 2018年10月18日 19.04 Disco Dingo（迪斯科澳洲野狗） 2019年4月18日 19.10 Eoan Ermine（伊欧安白鼬） 2019年10月17日 20.04 Focal Fossa（焦点窝） 2020年4月23日(LTS) 20.10 Groovy Gorilla（欢快的大猩猩） 2020年10月22日 21.04 Hirsute Hippo（多毛的河马） 2021年4月22日 21.10 Impish Indri（顽皮的大狐猴） 2021年10月14日 22.04 Jammy Jellyfish（活泼的水母） 2022年4月21日(LTS) 22.10 Kinetic Kudu（动感的捻角羚） 2022年10月20日 23.04 Lunar Lobster（月面龙虾） 2023年4月20日 23.10 Mantic Minotaur（预言的弥诺陶洛斯） 2023年10月12日 24.04 Noble Numbat（高贵的袋食蚁兽） 2024年4月25日(LTS) 24.10 Oracular Oriole（神谕的黄鹂） 2024年10月17日 备注：LTS 表示长期支持版本！ 3. Ubuntu 安装步骤 3.1. Ubuntu 在 VM 虚拟机上的安装过程 安装一般分为典型安装和自定义安装，本文为了更深入了解虚拟机相关知识而选择了自定义安装。 网友更详尽安装说明 网友介绍NAT模式和桥接模式文章 3.2. 如何在 VM 虚拟机打开 Ubuntu 系统 4. Ubuntu 操作界面基础 4.1 操作终端 Ubuntu 拥有多个操作终端，使用Ctrl+Alt+F1~F6切换到对应六个命令行终端，Ctrl+Alt+F7切换回图形桌面。 Ctrl+Alt+F7：切到图形桌面 Ctrl+Alt+F1：切到命令行终端桌面（F1~F6 共 6 个） Ctrl+Alt+t ：打开命令行终端窗口（图形桌面下） $命令行前字符，表示用户权限操作 #命令行首字符，表示管理员权限操作（root权限） 4.2 启动器 Ubuntu16.04 加显示桌面的快捷图标：System setting / Keyboard / Navigation / Hide all normal windows 设置即可。 Ubuntu16.04 加显示桌面到启动器：System setting / Appearance / Behavior / Add show desktop icon to the launcher 勾选上即可。 Ubuntu20.04 的显示桌面的快捷键Windows键+D 4.3 中文界面 因 Ubuntu20.04 可视界面下安装中文界面一直失败，改用命令安装： sudo apt update sudo apt install language-pack-zh-hans language-pack-gnome-zh-hans fonts-noto-cjk 然后在界面设置：Settings / Region \u0026 Language / Language 点击打开语言列表中找到 “Chinese (China)”，勾选它，然后点击 “Select”，最后点击 “Restart…” 重新登录用户账号即可！ 4.4 显示桌面 在 Ubuntu20.04 桌面加入【显示桌面】快捷图标： sudo apt update #安装准备 sudo apt install xdotool #安装工具（xdotool 快捷键模拟工具） xdotool key super+d #使用 xdotool 测试 Win+D 显示桌面快捷键是否可行 cd ~/Desktop/ #进入桌面目录（不知路径可以右击桌面点击 Open in Terminal） touch show-desktop.desktop #创建文件（show-desktop.desktop） sudo chmod +x show-desktop.desktop #修改文件（增加可执行） gedit show-desktop.desktop #编辑文件（使用 gedit 复制配置内容并保存。配置内容请查看备注） #右键点击该文件图标，选择 “Allow Launching（允许启动）” 即可生成桌面图标（双击图标可看到效果） sudo mv show-desktop.desktop /usr/share/applications/ #将快捷图标移到系统。 gsettings get org.gnome.shell favorite-apps #显示任务栏快捷图标。| ①假设显示的内容为 ['org.gnome.Nautilus.desktop', 'org.gnome.Terminal.desktop'] #添加任务栏快捷图标。| ②则添加图标内容为\"['org.gnome.Nautilus.desktop', 'org.gnome.Terminal.desktop', 'show-desktop.desktop']\" gsettings set org.gnome.shell favorite-apps \"['org.gnome.Nautilus.desktop', 'org.gnome.Terminal.desktop', 'show-desktop.desktop']\" #补充：将应用添加任务栏的常规操作→打开应用→任务栏上右击其图标→点击\"Add to Favourites\"（添加到收藏夹） 备注：show-desktop.desktop 配置内容 [Desktop Entry] Name=显示桌面 Comment=一键最小化所有窗口，显示桌面 Exec=xdotool key super+d Icon=desktop Terminal=false Type=Application Categories=Utility;Desktop; Keywords=show;desktop;minimize; 4.5 桌面快捷图标知识 在 Ubuntu 20.04 中创建 .desktop 配置文件（用于定义应用程序快捷方式、启动器等）的步骤如下，适用于自定义应用或系统工具的快捷方式： ","date":"2020-08-02","objectID":"/20200802/:0:1","tags":["Ubuntu","linux 工具/应用"],"title":"Ubuntu 系统与工具","uri":"/20200802/"},{"categories":["linux"],"content":"一、基本概念 .desktop 文件是 Linux 桌面环境（如 GNOME、KDE 等）识别的快捷方式配置文件，用于定义应用程序的名称、图标、启动命令等信息，可放在桌面、启动器目录或系统应用目录中。 ","date":"2020-08-02","objectID":"/20200802/:0:2","tags":["Ubuntu","linux 工具/应用"],"title":"Ubuntu 系统与工具","uri":"/20200802/"},{"categories":["linux"],"content":"二、创建 .desktop 文件的通用步骤 1. 确定文件位置 桌面快捷方式：通常放在 ~/桌面/（即 /home/用户名/桌面/），方便直接在桌面显示。 系统全局应用：放在 /usr/share/applications/（需要管理员权限），所有用户可见。 当前用户应用：放在 ~/.local/share/applications/，仅当前用户可见（推荐个人使用）。 2. 创建并编辑 .desktop 文件 以创建一个桌面快捷方式为例： 打开终端（Ctrl+Alt+T），通过文本编辑器（如 gedit 或 nano）创建文件： # 桌面快捷方式（以 gedit 为例，nano 更轻量，适合终端操作） gedit ~/桌面/自定义名称.desktop （将“自定义名称”替换为你的快捷方式名称，如 myapp.desktop） 写入基本配置模板 根据需求修改以下内容，粘贴到文件中： [Desktop Entry] Name=应用名称 # 显示的名称（如“我的工具”） Comment=应用描述 # 鼠标悬停时显示的说明（可选） Exec=/path/to/executable # 启动程序的绝对路径或命令（必填） Icon=/path/to/icon.png # 图标的绝对路径（可选，也可使用系统内置图标名） Terminal=false # 是否在终端中运行（true/false） Type=Application # 类型固定为 Application Categories=Utility;Development; # 分类（决定在应用菜单中显示的位置，多个用;分隔） Keywords=关键词1;关键词2; # 搜索时的关键词（可选） 示例：创建一个启动 firefox 浏览器的快捷方式 [Desktop Entry] Name=火狐浏览器 Comment=打开 Mozilla Firefox 浏览器 Exec=firefox Icon=firefox # 系统内置图标，无需路径 Terminal=false Type=Application Categories=Network;WebBrowser; Keywords=浏览器;上网; 3. 赋予执行权限 .desktop 文件需要执行权限才能被识别为应用快捷方式，终端中执行： # 针对桌面快捷方式 chmod +x ~/桌面/自定义名称.desktop # 针对用户目录应用（如 ~/.local/share/applications/ 下） chmod +x ~/.local/share/applications/自定义名称.desktop # 针对系统全局应用（需 sudo） sudo chmod +x /usr/share/applications/自定义名称.desktop 4. 验证与调整 若放在桌面：文件会显示为图标，双击即可运行（若提示“未信任”，参考前文方法标记为可信）。 若放在 ~/.local/share/applications/ 或 /usr/share/applications/：可在应用菜单（左下角九宫格图标）中搜索名称找到。 ","date":"2020-08-02","objectID":"/20200802/:0:3","tags":["Ubuntu","linux 工具/应用"],"title":"Ubuntu 系统与工具","uri":"/20200802/"},{"categories":["linux"],"content":"三、常见问题解决 图标不显示：检查 Icon 路径是否正确，或改用系统内置图标名（如 system-settings、terminal 等，可在 /usr/share/icons/ 目录下查找）。 无法启动：检查 Exec 路径是否正确（终端中单独执行该命令，确认能正常运行）。 权限问题：确保已执行 chmod +x 赋予权限，系统全局目录需用 sudo。 通过以上步骤，即可创建自定义的 .desktop 配置文件，实现应用快捷启动功能。 5. Ubuntu 版本查看命令 ctrl + alt + t快捷键打开终端机 uname -a内核 cat /proc/version具体 cat /etc/lsb-release具体 cat /etc/issue简单 6. Ubuntu 网络基本配置 介绍：在 Ubuntu 系统上安装软件，多数情况下都是使用apt-get指令在线安装。如果网络没有配置好（一般情况下系统默认配置为 DHCP），则造成软件（工具）无法安装，相关工作将无法开展。 1）编辑网络等操作： ctrl + alt + t #快捷键打开终端机 sudo gedit /etc/network/interfaces #编辑网络参数 sudo /etc/init.d/networking restart #重启网络 2）配置静态ip内容： auto lo iface lo inet loopback auto eth0 iface eth0 inet static address 192.168.1.28 netmask 255.255.255.0 gateway 192.168.1.1 dns-nameservers 8.8.8.8 7. Ubuntu 磁盘扩容方法 在 VMware 安装 Ubuntu 时磁盘容量分配过小，或者是用了一段时间后 Ubuntu 的磁盘容量不足时，那我们就需要对 Ubuntu 磁盘进行扩容。备注：在命令窗口输入命令df -h查看硬盘容量使用情况。分两大步：一、在 VMware 设置菜单调整磁盘容量；二、在 Ubuntu 系统里面调整分区大小。 修改磁盘总容量大小：VMware/虚拟机/设置/硬盘/实用工具/扩展。 通过命令安装 Gparted：sudo apt-get install gparted。 打开 Gparted 软件（图示），在可视界面上操作，总体操作为 删除扩展分区（以及交换分区）→ 调整主分区大小 → 创建扩展分区（以及交换分区）。 使用右键 Delete 菜单依次删除 linux-swap 交换分区、extended 扩展分区，若 Delete 选项灰色不可用，则先点击 SwapOff（图示）。 使用右键 Resize/Move 菜单调整 /dev/sda1 主分区大小，在里面调整主分区大小，但必须留大约 2G 给扩展分区使用。 使用右键 New 菜单对 unallocated 未分配空间进行分配，在里面创建为 Extended Partition 扩展分区。 使用右键 New 菜单对 extended 扩展分区进行分配，在里面创建为 linux-swap 交换分区（图示）。 然后点击主界面的打勾按钮确认并执行操作。 使用右键 SwapOn 菜单激活 linux-swap 交换分区。 使用右键 Information 菜单查看 linux-swap 交换分区的 UUID。 将新建的 linux-swap 中的 UUID 值更新到/etc/fstab文件中，打开文件的命令：sudo gedit /etc/fstab 具体请参考网文：《VMware 下对 Ubuntu 进行扩充磁盘大小》、《查看最后一节：更换 UUID》、《fstab 是什么？被谁用？怎么写？》 8. 解决系统之间复制粘贴问题 一、复制粘贴方式： 1）安装工具： sudo apt-get autoremove open-vm-tools #移除系统原工具 sudo apt-get install open-vm-tools #安装开源虚拟机交互工具包 sudo apt-get install open-vm-tools-desktop #安装桌面双向复制粘贴工具 sudo apt-get install open-vm-tools-dkms #安装文件夹共享工具（以上工具安装过程中，一路 yes/y 通过即可） reboot #重启 Ubuntu 即可。 2）补充说明： 复制粘贴方式实现 ubuntu16.04 和 windows 电脑之间灵活的文件(夹)拷贝操作，但是实际使用中会出现速度变慢、卡顿、卡死等一些不稳定问题，所以只建议用来复制文本内容，至于文件(夹)拷贝则使用下面的文件夹共享方式会更好。 二、文件夹共享方式： 1）安装工具： sudo apt-get install open-vm-tools-dkms #安装文件夹共享工具 2）配置工具： 在 VMware 虚拟机菜单依次点击→虚拟机→设置→选项→共享文件夹→总是启用→添加目录即可（如图），在 Unbuntu 系统的访问的共享文件夹在/mnt/hgfs对应目录。 3）配置脚本： 每次重新开机共享文件夹不能自动挂载，要进行先“已禁用”再“总是启用”操作后才能使用，很是麻烦！解决方法如下： sudo gedit /etc/fstab # 打开配置文件，在其最后面增加一行自动挂载语句： # .host:/ /mnt/hgfs fuse.vmhgfs-fuse allow_other,defaults 0 0 三、相关工具简介： 工具 作用 open-vm-tools 虚拟机显示驱动，屏幕可以自适应大小 open-vm-tools-desktop 实现主机和虚拟机之间的文件复制粘贴 open-vm-tools-dkms 实现文件夹共享 9. 解决系统分辨率自适应问题 介绍：相信很多人在装虚拟机的时候，遇到了窗口过小不能自适应的问题。我在网上查了好多资料，有说安装 Vmware Tools 解决，也有说修改分辨率解决。但 Vmware Tools 官方工具已经不建议用，更提倡开源的 open-vm-tools。 1）安装工具： sudo apt-get install open-vm-tools #安装开源工具包； sudo apt-get install open-vm* #安装一些依赖包； shutdown -r now #重启，完美解决窗口自适应问题。 2）配置工具： 在 VMware 勾选：查看/自动调节大小/自动适应客户机 和 自动适应窗口。（如图） 10. 解决打开文本文件乱码问题 介绍：对于我们程序员，几乎的工作就是编译源代码，如果代码中有中文，则在 Unbuntu 中显示往往是乱码。因为在 windows 下编写的源码默认编码为 ANSI，而在 Unbuntu 下面默认是 UTF-8 编码，所以使用 gedit 打开文件是乱码。要正常显示文件，则需要我们修改系统默认编码，方法如下： export LANG=zh_CN.UTF-8 #临时修改默认编码（重启后将失效） locale #查看全部编码配置（参考此列表修改或增加配置） sudo gedit /etc/profile #在环境变量下修改（根据上面列表增加编码机制即可） vi /etc/default/locale #打开配置文件修改（此方法不行,要在环境变量修改） 语法 说明 zh 语言（中文。 en 英文） _CN 国家（中国。_US 美国） .UTF-8 编码方式（UTF-8） LANG= 没设置编码的系统模块，都默认为此全局编码 LANGUAGE= 没设置编码的应用程序，则默认为此全局编码 LC_XXXXX= 系统具体应用模块的编码 上面的方法只能临时修改相关就编码，其中第3、4点更不推荐。缘由：因不知道操作了什么后，gedit 文本编辑软件不能自动识别文件编码（显示乱码），解决方法如下： 1、sudo apt-get install dconf-tools 安装 dconf-tools 工具； 2、Alt + F2 打开搜索，输入 dconf Editor，在搜索结果打开此工具； 3、org → gnome → gedit → preferences → encodings 展开后选择右面窗口的 candidate-encodings, 点击 Set to Default。 11. 安装中文输入法 请阅读：《中文输入工具 wubi》 12. 修改用户名称与密码 因为拷贝给其他小伙伴 Ubuntu20 和虚拟机，Desktop 显示的自己的名字，尝试改用户名和密码，改了 2 次结果都登陆不进去了，最后发现了原因如下： “如果你要修改密码和用户名的话，请先修改密码，重启，再修改用户名，重启。如果你先修改用户名，再修改密码的话，可能会导致你登录不了 Ubuntu。然后重新配置系统，最好再修改重要配置前将设备镜像备份一下！！！” ######################################### # 一、设置root用户密码 sudo passwd root #启动修改root密码 New password: #根据指示初次输入新密码 Retype new password: #根据指示再次输入新密码 passwd: password updated successfully #最后显示设置密码成功 # 二、修改普通用户密码 su root #转为root用户操作 Password: #根据要","date":"2020-08-02","objectID":"/20200802/:0:4","tags":["Ubuntu","linux 工具/应用"],"title":"Ubuntu 系统与工具","uri":"/20200802/"},{"categories":["linux"],"content":"二、工具篇 1. Ubuntu 上安装 JDK 教程 请阅读：《linux JAVA 开发环境 JDK》 2. Ubuntu 上安装 Eclipse 教程 请阅读：《linux 开发工具 Eclipse》 3. Ubuntu 上更新 Firefox 教程 1、下载：直接在官网《下载》 2、更新：请参考官网《在 Linux 中安装 Firefox》 备注：我的系统是 Ubuntu（注：命令操作需要权限时要加sudo），因为只是增加 Firefox-98 新版本，没有删除旧版本，所以做法有少许不一样： ###[不同对照表]### # ln -s /opt/firefox/firefox /usr/local/bin/firefox --命令改为--\u003e sudo ln -s /opt/firefox/firefox /usr/local/bin/firefox98 # /usr/local/share/applications ----------------------路径改为--\u003e /usr/share/applications # firefox.desktop ----------------------名称改为--\u003e firefox98.desktop # Name=Firefox Web Browser ----------------------参数改为--\u003e Name=Firefox98 Web Browser # Exec=firefox %u ----------------------参数改为--\u003e Exec=/opt/firefox/firefox %u ###[具体操作]#### cd ~/Downloads # 进入文件包下载到的目录 tar xjf firefox-98.0.2.tar.bz2 # 解压下载的软件包 sudo mv firefox /opt # 将刚解压的软件包移到/opt目录下 sudo ln -s /opt/firefox/firefox /usr/local/bin/firefox98 # 创建软件快捷启动方式 touch firefox98.desktop # 创建桌面快捷启动方式，使用文本工具编辑其内容（具体请复制[firefox98.desktop文件内容]） sudo chmod 777 firefox98.desktop # 修改桌面快捷启动方式权限 sudo mv firefox98.desktop /usr/share/applications # 将桌面快捷启动方式移到应用启动图标管理文件夹 ######[firefox98.desktop文件内容]###### ######[备注]：凡是脚本,行尾不应有多余的空格 [Desktop Entry] Version=1.0 Name=Firefox98 Web Browser Comment=Browse the World Wide Web GenericName=Web Browser Keywords=Internet;WWW;Browser;Web;Explorer Exec=/opt/firefox/firefox %u Terminal=false X-MultipleArgs=false Type=Application Icon=/opt/firefox/browser/chrome/icons/default/default128.png Categories=GNOME;GTK;Network;WebBrowser; MimeType=text/html;text/xml;application/xhtml+xml;application/xml;application/rss+xml;application/rdf+xml;image/gif;image/jpeg;image/png;x-scheme-handler/http;x-scheme-handler/https;x-scheme-handler/ftp;x-scheme-handler/chrome;video/webm;application/x-xpinstall; StartupNotify=true 3、最后：在可视窗口里进入 /usr/share/applications 文件夹，点右键菜单复制 Firefox98 Web Browser 桌面快捷启动图标，然后到桌面点右键菜单粘贴，最后点击图标即可在桌面启动 Firefox98 浏览器。 4. Ubuntu 上安装 Python-3.7 教程 一、在线版-安装示例： sudo apt-get update #更新软件包列表 sudo apt-get install python3 #安装python3 二、源码版-安装示例： sudo apt-get update #更新软件包列表，下行命令是安装依赖库（询问时自动键入y） sudo apt-get install build-essential libncursesw5-dev libgdbm-dev libc6-dev zlib1g-dev libsqlite3-dev tk-dev libssl-dev openssl libffi-dev libbz2-dev -y wget https://www.python.org/ftp/python/3.7.1/Python-3.7.1.tgz #下载源代码，所有版本都在 https://www.python.org/ftp/python/ tar xzvf Python-3.7.1.tgz #解压源代码 cd Python-3.7.1 #进入目录 ./configure #自动配置参数 sudo make \u0026\u0026 sudo make install #编译并且安装 python3.7 --version #检验是否安装成功 pip3.7 --version #检验是否安装成功 5. Ubuntu 上其它日常软件 名称 网址 linuxqq 官网下载 ","date":"2020-08-02","objectID":"/20200802/:0:5","tags":["Ubuntu","linux 工具/应用"],"title":"Ubuntu 系统与工具","uri":"/20200802/"},{"categories":["software"],"content":"介绍 json 基本语法","date":"2020-03-09","objectID":"/20200309/","tags":["json"],"title":"json 基本语法介绍","uri":"/20200309/"},{"categories":["software"],"content":"一、前言 JSON 指的是 JavaScript 对象表示法（JavaScript Object Notation）。 JSON 是轻量级的文本数据交换格式，目前大部分智能家居系统数据交换都使用了 Json 格式。 ","date":"2020-03-09","objectID":"/20200309/:0:1","tags":["json"],"title":"json 基本语法介绍","uri":"/20200309/"},{"categories":["software"],"content":"二、语法 JSON 数据的书写格式是：key : value，即： 键 : 键值，也就是：名称 : 数值。 数　组：\"名称\" : [ 组员 , 组员 , ……组员], 组员：为 无名数组、无名对象、无名键值对 说明：“无名”表示没有名称的一个对象体/数组体/数值体 对　象：\"名称\" : { 成员 , 成员 , ……成员}, 成员：为 有名数组、有名对象、有名键值对 键值对：\"名称\" : \"数值\", 数值：任意字符；如果 数值 没有双引号，只能数字、ture、false、null 要　点：整个Json数据需要 { } 或 [ ] 括号括住，所有的 } 或 ] 前面不能有逗号。 ","date":"2020-03-09","objectID":"/20200309/:0:2","tags":["json"],"title":"json 基本语法介绍","uri":"/20200309/"},{"categories":["software"],"content":"三、例子 点击展开内容 { \"web-app\": { \"servlet\": [ { \"servlet-name\": \"cofaxCDS\", \"servlet-class\": \"org.cofax.cds.CDSServlet\", \"init-param\": { \"useDataStore\": true, \"useJSP\": false, \"xxx\": null, \"dataStoreMaxConns\": 100, \"maxUrlLength\": 500, \"dataStoreLogLevel\": \"debug\", \"configGlossary:adminEmail\": \"ksm@pobox.com\", \"configGlossary:poweredByIcon\": \"/images/cofax.gif\", \"configGlossary:staticPath\": \"/content/static\", \"jspListTemplate\": \"listTemplate.jsp\", \"searchEngineFileTemplate\": \"forSearchEngines.htm\", \"searchEngineRobotsDb\": \"WEB-INF/robots.db\", \"dataStoreClass\": \"org.cofax.SqlDataStore\" } }, { \"servlet-name\": \"cofaxEmail\", \"servlet-class\": \"org.cofax.cds.EmailServlet\", \"init-param\": { \"mailHost\": \"mail1\", \"mailHostOverride\": \"mail2\" } }, { \"servlet-name\": \"cofaxAdmin\", \"servlet-class\": \"org.cofax.cds.AdminServlet\" }, { \"servlet-name\": \"fileServlet\", \"servlet-class\": \"org.cofax.cds.FileServlet\" }, { \"servlet-name\": \"cofaxTools\", \"servlet-class\": \"org.cofax.cms.CofaxToolsServlet\", \"init-param\": { \"templatePath\": \"toolstemplates/\", \"log\": 1, \"logLocation\": \"/usr/local/tomcat/logs/CofaxTools.log\", \"logMaxSize\": \"\", \"dataLog\": 1, \"betaServer\": true } } ], \"servlet-mapping\": { \"cofaxCDS\": \"/\", \"cofaxEmail\": \"/cofaxutil/aemail/*\", \"cofaxAdmin\": \"/admin/*\", \"fileServlet\": \"/static/*\", \"cofaxTools\": \"/tools/*\" }, \"taglib\": { \"taglib-uri\": \"cofax.tld\", \"taglib-location\": \"/WEB-INF/tlds/cofax.tld\" }, \"oil-price\": { \"status\": \"ok\", \"msg\": \"全国各省份汽柴油价格信息\", \"update\": \"2019-07-21 11:00\", \"data\": [ [\"地区\", \"92号汽油\", \"95号汽油\", \"98号汽油\", \"0号柴油\"], \"直辖市：\", [\"北京\", \"6.78\", \"7.21\", \"8.19\", \"6.45\"], [\"上海\", \"6.74\", \"7.17\", \"7.87\", \"6.39\"], [\"重庆\", \"6.75\", \"7.18\", \"8.06\", \"6.37\"], \"省份：\", [\"广东\", \"6.77\", \"7.15\", \"8.07\", \"6.41\"] ], \"About\": \"xiaomin\", \"Blog\": [\"www.xxxxx1.com\", \"www.xxxxx2.com\"] } } } ","date":"2020-03-09","objectID":"/20200309/:0:3","tags":["json"],"title":"json 基本语法介绍","uri":"/20200309/"},{"categories":["software"],"content":"四、工具 点击展开内容 JSONedit-格式化与语法检测工具下载 JSONEditorOnline-在线格式化与语法检测工具 菜鸟工具JSON在线解析-在线格式化与语法检测工具 ","date":"2020-03-09","objectID":"/20200309/:0:4","tags":["json"],"title":"json 基本语法介绍","uri":"/20200309/"},{"categories":["software"],"content":"五、资料 点击展开内容 官网、Json中国 ","date":"2020-03-09","objectID":"/20200309/:0:5","tags":["json"],"title":"json 基本语法介绍","uri":"/20200309/"},{"categories":["linux"],"content":"linux 学习方向","date":"2020-03-05","objectID":"/20200305/","tags":["linux"],"title":"linux 学习索引","uri":"/20200305/"},{"categories":["linux"],"content":"一、前言 当我们做一件事时，方向很重要，如果方向错了，之前的努力会白白浪费掉，再努力也不会成功！学习 linux 也一样，一、首先需要了解它有哪些知识点，结合自己情况决定向哪个方向发展；二、先学习用到的知识点，以后才深化及补全。 ","date":"2020-03-05","objectID":"/20200305/:0:1","tags":["linux"],"title":"linux 学习索引","uri":"/20200305/"},{"categories":["linux"],"content":"二、认识 linux 1. linux 发行版本 ● deb派系--桌面版系统 Debian（读音：‘debeen 待宾） Ubuntu（读音：u’bʌntu 乌班图） Deepin（读音：diːpin 低评） …… ● rpm派系--服务器系统 RedHat（读音：‘redhæt [红帽]） CentOS（读音：sen’tus 圣斗士） Fedora（读音：fɪ’dɔːrə 费多拉帽） …… 2. linux 基础知识 ● 系统 Ubuntu CentOS …… ● 命令 权限命令 网络命令 文件命令 …… ● 编辑 中文输入法 vi/vim 编辑器 gedit 编辑器 …… ● 编程 进程 线程 管道 …… ● 编译 gcc 编译 Makefile 构建工具 gdb 调试 …… ● 工具 网络终端工具 ssh 网络文件系统 nfs 轻巧脚本语言 lua …… 3. 就业发展方向 ● linux 运维 ● linux 系统应用开发 ● 嵌入式 linux Bootloader Linux 内核 根文件系统 Linux 驱动 Linux 应用 ","date":"2020-03-05","objectID":"/20200305/:0:2","tags":["linux"],"title":"linux 学习索引","uri":"/20200305/"},{"categories":["linux"],"content":"三、嵌入式 linux 1. BootLLoad 2. linux 内核 3. 根文件系统 4. linux 驱动 5. linux 应用 ","date":"2020-03-05","objectID":"/20200305/:0:3","tags":["linux"],"title":"linux 学习索引","uri":"/20200305/"},{"categories":["MCU"],"content":"利用 j-link 的 RTT 也可以实现调试打印的功能","date":"2019-01-19","objectID":"/20190119/","tags":["J-link","RTT"],"title":"J-link 调试器日志打印工具-RTT","uri":"/20190119/"},{"categories":["MCU"],"content":"前言 在线仿真器（J-link）与 MCU 之间实现的是硬件级-即时性的信息交互，平时调试时可直接读取 MCU 内部任何数据，那就意味着可以划一段共享内存用来缓存打印信息，当有信息就读取出来，从而实现 MCU 向仿真器终端软件打印信息的功能。 ","date":"2019-01-19","objectID":"/20190119/:0:1","tags":["J-link","RTT"],"title":"J-link 调试器日志打印工具-RTT","uri":"/20190119/"},{"categories":["MCU"],"content":"简介 点击展开内容 ● RTT（Real Time Terminal）是 SEGGER 公司新出的可以在嵌入式应用中与用户进行交互的实时终端。J-Link 驱动 4.90 之后的版本都支持 RTT。 ● RTT 既可以从 MCU 上输出信息、也可以向应用程序发送信息，由于其高速的特性，所以不影响 MCU 的实时性。实现原理就是 J-link 与 MCU 共享内存。 ● MCU 通过 J-link 与电脑连接并将打印信息输出到电脑上，电脑同时可以通过键盘等向 MCU 发送数据。 ","date":"2019-01-19","objectID":"/20190119/:0:2","tags":["J-link","RTT"],"title":"J-link 调试器日志打印工具-RTT","uri":"/20190119/"},{"categories":["MCU"],"content":"移植 点击展开内容 1、RTT 源代码在 J-link 安装目录下：C:\\Program Files (x86)\\SEGGER\\JLink_V630e\\Samples\\RTT\\SEGGER_RTT_V630e.zip， 2、解压并将文件添加到你的工程中：SEGGER_RTT_printf.c、SEGGER_RTT.c、SEGGER_RTT_Conf.h、SEGGER_RTT.h。 3、先调用初始化函数：SEGGER_RTT_ConfigUpBuffer(0, NULL, NULL, 0, SEGGER_RTT_MODE_NO_BLOCK_SKIP); 4、之后可打印字符串: SEGGER_RTT_WriteString(0, \"txt\\r\\n\"); 5、打印格式化字符串: SEGGER_RTT_printf(0，\"%d_txt\\r\\n\"，2019); 6、打开打印调试窗口，在 SEGGER 安装目录下找到 JLink RTT Viewer.exe 这软件双击运行。 后记： ● 使用 V4.90 版 → 测试 → 不成功； ● 使用 V6.30 版 → 测试 → 成功。 ● 听说 RTT 共有三个输出工具，网友解释如下： RTT Viewer：不支持中文。至少要进入一次 Debugger 才能正常显示输出。建议进入 Debugger 之后再打开，否则经常不能正常显示输出。 RTT Logger：支持中文，并且可以保存为 log 文件。使用具体的正确使用方法不清楚。根据手册说明，log 只接收 RTT 通道 1 的输出，即SEGGER_RTT_printf(1，\"字符串\"，输出格式)。但是实测，只能输出 RTT 通道 0 的信息，并且要求代码中要有使用到通道 1 的语句。否则收不到数据。 RTT Client：必须配合 RTT Logger 或者 keil 的 Debugger 来使用，而 RTT Logger 也必须配合 Debugger 使用。Client、Logger 和 Debugger 三个窗口都打开的时候，Client 和 Logger 只有其中一个能正常显示，另外一个会严重丢失数据。 ","date":"2019-01-19","objectID":"/20190119/:0:3","tags":["J-link","RTT"],"title":"J-link 调试器日志打印工具-RTT","uri":"/20190119/"},{"categories":["software"],"content":"git 应用总结与提高","date":"2019-01-18","objectID":"/20190118/","tags":["工具","git"],"title":"git 应用总结与提高","uri":"/20190118/"},{"categories":["software"],"content":" /* 一键按钮悬浮左下角样式 */ #toggleAll { font-size: 10px; position: fixed; left: 15px; bottom: 15px; z-index: 9999; box-shadow: 0 2px 8px rgba(0,0,0,0.2); transition: background 0.3s ease; } #toggleAll:hover { background: #eee; } 一键展开全部 ","date":"2019-01-18","objectID":"/20190118/:0:0","tags":["工具","git"],"title":"git 应用总结与提高","uri":"/20190118/"},{"categories":["software"],"content":"前言 Git 是一款由 Linus Torvalds（Linux 内核创始人）于 2005 年开发的 分布式版本控制系统（Version Control System，VCS），核心目标是高效管理代码的版本迭代与多人协作开发，现已成为全球最流行的代码管理工具（广泛搭配 GitHub、GitLab、Gitee 等远程仓库平台使用）。 ","date":"2019-01-18","objectID":"/20190118/:0:1","tags":["工具","git"],"title":"git 应用总结与提高","uri":"/20190118/"},{"categories":["software"],"content":"安装 1、安装 Git Git 是一款开源分布式版本控制系统，核心特性为分布式架构与版本全量追踪，支持本地独立完成开发工作，仅需在同步协作时联网。直接访问 Git 官方下载页面，下载对应系统版本的安装包，双击运行一路默认安装即可。 Git 的打开步骤（先右键点击文件区空白处）： 点击展开内容【常见的代码托管网站】 1）国际主流平台 网站名称 网址 核心特点 GitHub https://github.com 全球最大的代码托管与开源协作平台，支持 Git 版本控制，托管了海量开源项目。免费版可创建私有和公有仓库，适合个人开发者、开源社区及企业，仅国内访问偶尔不稳定。 GitLab https://gitlab.com 开源的代码托管平台，支持 DevOps 全生命周期流程。免费版可创建无限个私有和公有仓库，每月提供 400 分钟 CI/CD 构建时长，还支持企业搭建私有部署版本，适配大型团队协作。 SourceForge https://sourceforge.net 老牌开源项目托管平台，历史悠久。除了 Git，也支持 SVN 和 Mercurial。提供文件下载、项目统计等传统功能。 Bitbucket https://bitbucket.org 支持 Git 和 Mercurial 两种版本控制工具。免费版适合小型团队，支持 5 人以内团队创建无限私有仓库，功能上与 GitHub 相近，侧重团队协作中的代码托管和基础协作需求。 Codeberg https://codeberg.org 由欧盟开发者维护，基于 Gitea 搭建，注重隐私保护和开源精神。平台免费且无广告，适合追求数据安全和轻量化代码托管的用户，国内访问速度尚可。 Framagit https://framagit.org 法国公司运营，基于 GitLab 搭建，服务器位于德国。支持代码托管和基础协作功能，适合对欧洲服务器访问需求较高的开发者，整体访问稳定性较好。 2） 国内主流平台 网站名称 网址 核心特点 码云 Gitee https://gitee.com 国内最常用的代码托管平台，服务器在国内，访问速度快、稳定性高。免费版支持无限个私有和公有仓库，单个团队限 5 名成员，适合个人、小团队及国内企业的项目托管，还提供代码迁移、在线编辑等适配国内开发者的功能。 阿里云效 Codeup https://codeup.aliyun.com 阿里云推出的企业级代码管理平台，是阿里老版 Code 的升级版本。免费版不限人数，提供 100GB 托管总容量，支持代码评审、质量检测、CI/CD 等 DevOps 功能，适配企业级研发协作场景。 CODING https://coding.net 侧重研发协作的代码托管平台，免费版提供 100GB 总仓库容量，不限团队人数。除代码托管外，还集成了项目协同、制品库、流水线等功能，能满足中小团队到企业级的研发全流程需求。 腾讯工蜂 https://git.code.tencent.com 腾讯推出的纯代码托管平台，支持 Git 版本控制，不限用户数和组织个数，适合腾讯生态内的开发者及企业，侧重代码的基础托管和团队协同管理。 极狐 JihuLab https://jihulab.com GitLab 的中国版，功能与 GitLab 对齐。免费版支持无限私有和公有仓库，每月 400 分钟 CI/CD 流水线时间，每个项目仓库容量 2GB，适配国内企业的 DevOps 协作需求，访问速度和稳定性更贴合国内网络环境。 2、安装可视化辅助工具 TortoiseGit 是一款开源版本控制客户端，其源代码托管于 GitLab。你可以直接访问 TortoiseGit 官方下载页面，获取对应版本的软件安装包与语言包：例如 64 位系统适配的 TortoiseGit-2.13.0.1-64bit.msi 主程序，以及配套的 TortoiseGit-LanguagePack-2.13.0.0-64bit-zh_CN.msi 中文语言包。安装时请先运行软件包，再安装语言包，以确保语言配置生效。 TortoiseGit 中文界面设置步骤（先右键点击文件区空白处）： TortoiseGit 支持为文件及文件夹配置图标叠加标记，帮助开发者快速识别代码的变更情况： PS：借助 TortoiseGit 可视化工具开展代码对比工作，既能显著提升操作效率与比对准确性，又可直观查看工作区的代码修改情况，大幅降低人工比对的成本与误差。 3、设置邮箱地址和用户名 第一次安装 Git 后，通常需要做的第一件事就是设置邮箱地址和用户名，它们是你在 Git 世界里的 “身份证”。 #-------设置全局邮箱地址和用户名------- git config --global user.email \"o2o@qq.com\" #【重置】全局邮箱地址（--global 表示设置全局参数。当不加此选项时，表示对象是当前所在仓库参数） git config --global user.name \"o2ospring\" #【重置】全局用户名　（--global 表示设置全局参数。当不加此选项时，表示对象是当前所在仓库参数） #git config --global user.email #【查看】全局邮箱地址（--global 表示设置全局参数。当不加此选项时，表示对象是当前所在仓库参数） #git config --global user.name #【查看】全局用户名　（--global 表示设置全局参数。当不加此选项时，表示对象是当前所在仓库参数） #git config --global -l #【查看】全局配置参数（--global 表示设置全局参数。当不加此选项时，表示对象是当前所在仓库参数） #git config --global --edit #【编辑】全局配置参数（--global 表示设置全局参数。当不加此选项时，表示对象是当前所在仓库参数） #git config --global credential.helper cache #【缓存】用户名和密码（当频繁通过 HTTPS 操作远程仓库，可避免每次重复输入凭证，除非凭证过期或终端关闭） #git config --global credential.helper 'cache --timeout=1800' #【修改】缓存有效期为 30 分钟（默认缓存 15 分钟） PS：--global配置的参数存在 Windows 的 C:\\Users\\你的用户名\\.gitconfig 或 macOS/Linux 的 ~/.gitconfig 文件中。 ","date":"2019-01-18","objectID":"/20190118/:0:2","tags":["工具","git"],"title":"git 应用总结与提高","uri":"/20190118/"},{"categories":["software"],"content":"使用 01、假设克隆仓库 若仅需对现有工程进行修改，可直接从远程仓库克隆代码至本地；完成本地环境配置与远程仓库关联后，即可按需开展代码修改、调试、提交及推送更新等操作。 1.1、克隆所有分支 当项目仓库包含发布分支（如 release/*）、开发分支（如 develop）等多分支结构时，需克隆完整仓库以支持全流程开发、分支切换与版本迭代。此方式会同步下载所有分支的历史提交记录，会占用更多本地存储空间。 #-------克隆所有分支------- #【方式一】克隆远程仓库所有分支（SSH 方式）（注意：使用 SSH 克隆之前先要添加 SSH key，具体操作后面再介绍，所以暂不推荐这种方式） git clone git@github.com:espressif/esp-idf.git #【方式二】克隆远程仓库所有分支（http方式）（如果忘记拉取子模块，则可以使用 git submodule update --init --recursive 命令补救） git clone https://github.com/espressif/esp-idf.git #〖情形二〗当远程仓库有嵌套仓库时，克隆所有分支的同时，同步拉取嵌套仓库 git clone --recursive https://github.com/espressif/esp-idf.git #〖情形三〗同上，并且将本地工作区自动切换到`release/v5.1`分支（备注：`release/v5.1`是分支名称，`/`仅作为名称字符的一部分） git clone --recursive -b release/v5.1 https://github.com/espressif/esp-idf.git #git checkout -b aaaa origin/aaaa # 基于【远程跟踪分支】创建并切换到新的本地分支，同时建立跟踪关系（注：不会从远程仓库拉取数据）（貌似 git checkout aaaa 也会自动处理） #【远程跟踪分支】：是已从远程仓库同步到本地的分支。例如：克隆整个远程仓库，除当前分支外，其它分支还处于隐藏状态，需要通过上行命令检出 点击展开内容【SSH 密钥添加】 SSH 密钥分公钥和私钥，公钥是 “锁”，私钥是 “钥匙”。客户端生成这对密钥后，把公钥（锁）装到服务器上，之后客户端用私钥（钥匙）就能直接免密登录服务器了。 1）【生成】SSH 加密密钥 ssh-keygen -t rsa -C \"o2o@qq.com\" #【生成】SSH 加密密钥（过程提示【输入文件名】和【输入两次密码】，全部按回车即表示使用默认文件名和不需要密码） # -t 指定密钥类型，默认是 rsa，可以省略。 # -C 设置注释文字，比如邮箱。 # 生成的密钥（id_rsa 私钥文件、id_rsa.pub 公钥文件）存在 Windows 的 `C:\\Users\\你的用户名\\.ssh\\` 或 macOS/Linux 的 `~/.ssh/` 目录中 2）【添加】SSH key 到托管网站 PS：GitHub 支持添加多个 SSH Key。如果你需要在多台设备（比如公司电脑和家用电脑）上提交代码，只需将每台设备的 SSH Key 都配置到 GitHub 账号中，就能在任意设备上直接向远程仓库推送代码了。 1.2、克隆单个分支 当项目仓库需针对特定功能模块或指定发布版本进行开发，建议直接克隆对应功能分支 / 版本分支，基于该分支迭代开发。此方式可避免拉取全量仓库历史数据，显著降低本地存储占用，同时确保开发环境与目标版本的一致性。 #-------克隆单个分支------- #〖情形一〗仅克隆远程仓库中指定的`release/v5.1`分支，不会下载其他任何分支（备注：`release/v5.1`是分支名称，`/`仅作为名称字符的一部分） git clone --single-branch -b release/v5.1 https://github.com/espressif/esp-idf.git #〖情形二〗同上，当远程仓库有嵌套仓库时，克隆指定分支的同时，同步拉取嵌套仓库 git clone --recursive --single-branch -b release/v5.1 https://github.com/espressif/esp-idf.git PS：关于--recursive与--recurse-submodules的区别： 1）--recursive作用对象是【嵌套仓库】（目录下有 .git 的独立仓库）； 2）--recurse-submodules作用对象是【子模块】（通过 .gitmodules 配置的依赖）。 3）目前掌握到信息，两者应该是一样的，但推荐： --recurse-submodules 用于 git clone, git pull, git fetch 等命令，表示\"在执行此操作时递归处理子模块\"； --recursive 只用于 git submodule 命令本身，表示\"递归执行这个子模块操作\"。 1.3、设置邮箱地址和用户名 #-------设置当前仓库的邮箱地址和用户名------- git config user.email \"xxx@qq.com\"#【设置】当前仓库的邮箱地址（备注：当不单独设置时，将默认使用全局配置的邮箱地址和用户名） git config user.name \"xiaoming\" #【设置】当前仓库的用户名　（备注：当不单独设置时，将默认使用全局配置的邮箱地址和用户名） PS：建议为此仓库单独设置专属邮箱地址及用户名（未单独设置时，将默认使用全局配置的邮箱地址和用户名），为开发工作做好前置准备！ 02、假设新建仓库 若需自行新建工程，需先在远程代码仓库（如 GitHub/GitLab/Gitee）与本地环境分别创建对应仓库，后续再进行代码初始化、分支配置及远程关联操作。 2.1、远程新建 首先在指定平台创建共享远程仓库，为团队成员后续的代码推送、同步及协作开发提供统一的版本管理中心。 2.2、本地新建 当远程仓库尚未创建，或已创建但为空白仓库，可先在本地初始化 Git 仓库并完成项目代码编写 / 提交，随后通过关联远程仓库地址、设置上游分支，最终执行推送操作将本地代码同步至远程仓库。 #-------本地新建仓库------- git init --initial-branch=main #【新建】一个空的全新的本地仓库。（git init 不指定名称时，可能是 master，因其有种族歧视性，所以很多厂家改用 main） git config user.email \"xxx@qq.com\"#【设置】当前仓库的邮箱地址（备注：当不单独设置时，将默认使用全局配置的邮箱地址和用户名） git config user.name \"xiaoming\" #【设置】当前仓库的用户名　（备注：当不单独设置时，将默认使用全局配置的邮箱地址和用户名） touch README.md #【添加】一个读我文件（一般情况下仓库都应有一个\u003cREADME.md\u003e文件作为工程的介绍） git add . #【添加】工作区文件到【暂存区】。（可以重复添加多次，也可以添加一个或多个指定文件，如：git add test.c 添加指定文件） git commit -m \"first commit\" #【提交】暂存区文件到【本地库】。（first commit 是提交的文字说明） 2.3、添加过滤 在实际工程场景中，部分文件无需纳入版本管理（尤其各类中间编辑文件，如编译生成的临时文件、编辑器缓存等），通过配置版本控制工具的忽略规则（.gitignore 等）可自动排除这类文件，既能避免冗余数据占用仓库存储空间、减缓仓库拉取 / 推送速度，也能减少版本控制的无效操作，提升协作效率。 #-------添加过滤规则------- touch .gitignore #【创建】一个忽略规则文件 # 使用文本编辑工作添加需要忽略的文件(夹)，例如： # *.o #忽略 *.o 文件。即 git 不管理当前目录及其下面所有层级的 *.o 文件 # output2/ #忽略 output2 目录。即 git 不管理 output2 这个文件夹，意味着其里面所有内容也被忽略，同时表明它下面文件(夹)不能使用`!`来指定某些文件(夹)解除忽略 # output/* #忽略 output 目录下的所有文件和目录 -----------\\ # !output/abc/ #但是，不要忽略 output/abc/ 这个目录 ----------|--\u003e 配合使用 # !output/abc/**/* #并且，不要忽略 output/abc/ 目录下的所有内容 --/ # #其中，** 表示递归所有子目录，例如包括孙目录。 # 如果不使用文本编辑工具，可以使用命令初始添加忽略规则内容，例如： #echo -e \"*/build/*\\n*JLinkLog.txt\\n*.o\\n*.d\\n*.a\\n*.i\\n*.map\\n*.elf\\n*.bin\\n*.hex\\n*.axf\\n*.crf\\n*.bak\\n*.dep\\n*.rar\\n*.zip\\n*.7z\" \u003e\u003e .gitignore 2.4、工程构建 在构建规范化工程时，通常会包含若干【标准通用模块】。这类模块可独立抽离至单独仓库进行管理，后续可通过仓库关联机制将这些子仓库整合至工程父仓库中，实现模块复用与统一管控。若此类模块已提前部署至远程仓库，可关","date":"2019-01-18","objectID":"/20190118/:0:3","tags":["工具","git"],"title":"git 应用总结与提高","uri":"/20190118/"},{"categories":["software"],"content":"总结 1、操作关系 元素 说明 远程仓库 (Remote Repository) 位于远程服务器上的代码仓库常见的托管平台：GitHub、GitLab、Gitee用于团队协作和代码备份 远程分支 (Remote Branch) 远程仓库中的实际分支团队共享的分支状态 本地仓库 (Local Repository) 位于 .git 目录中的完整版本库包含完整的提交历史、分支、标签等元数据通过 git commit 将暂存区内容保存到本地仓库 远程跟踪分支 (Remote Tracking Branch) 本地仓库中远程分支的引用【副本】命名格式：origin/branch-name通过 git fetch 更新，但不自动合并只读（不能直接提交） 本地分支 (Local Branch) 本地仓库中的分支引用如：main、develop、feature/login指向特定提交的指针 暂存区 (Staging Area/Index) 准备提交的更改的中间区域通过 git add 将工作区的更改添加到暂存区 工作区 (Working Directory) 本地文件系统中实际可见和编辑的文件目录存在尚未被 Git 跟踪或已修改但未暂存的文件 2、命令概览 3、命令选项 一、常用选项表 选项语法 音标 英文释义 中文释义 --all [ɔːl] all 全部，用于推送所有分支、清理所有未跟踪内容 --amend [əˈmend] amend 修改提交，修正最近一次提交的信息或文件 --no-edit — no edit 不更改提交信息，合并/变基时跳过编辑步骤 --no-ff — no fast forward 禁用快速合并，强制生成合并提交记录 --hard [hɑːd] hard 硬重置，覆盖 HEAD、暂存区、工作区的所有修改 --mixed [mɪkst] mixed 混合重置，默认模式，仅重置 HEAD 和暂存区 --soft [sɒft] soft 软重置，仅移动 HEAD 指针，保留暂存区和工作区 --cached [kæʃt] cached 缓存，针对暂存区操作（如移除已暂存文件不删除本地） --recursive [rɪˈkɜːsɪv] recursive 递归，克隆时拉取所有嵌套子模块 --recurse [rɪˈkɜːs] recurse 递归，用于子模块相关的递归操作 --global [ˈɡləʊbl] global 全局，配置 Git 全局参数（如用户名、邮箱） --prefix [ˈpriːfɪks] prefix 前缀，为克隆/操作添加路径前缀 --squash [ˈskwɒʃ] squash 挤塞，整合时压缩成一个提交 -m [ˈmesɪdʒ] message 注释信息，指定提交或标签的说明文本 -n [nəʊ] no 不执行操作，仅预览命令执行效果 -b [brɑːntʃ] branch 分支，创建并切换新分支 -d [dɪˈliːt] delete 删除，删除本地分支或标签 -v [vjuː] view/verbose 查看/详细输出，显示命令执行的详细信息 -f [fɔːs] force 强制操作，强制推送、覆盖标签等 HEAD [hed] head 当前指针，指向当前所在的分支或提交 二、常用单词表 单词语法 音标 英文释义 中文释义 init [ɪˈnɪt] initialization 初始化本地仓库，创建 Git 管理目录 add [æd] add 添加文件到暂存区，标记待提交的修改 rm [rɪˈmuːv] remove 移除文件，删除跟踪或暂存的文件 commit [kəˈmɪt] commit 提交暂存区到本地仓库，生成版本记录 status [ˈsteɪtəs] status 查看工作区/暂存区状态，确认文件变更情况 reset [riːˈset] reset 重置版本指针，回退到指定历史版本 revert [rɪˈvɜːt] revert 回滚指定提交，生成反向提交抵消变更 branch [brɑːntʃ] branch 分支管理，创建、查看、删除分支 checkout [ˈtʃekaʊt] checkout 检出分支/恢复文件，切换分支或还原文件 merge [mɜːdʒ] merge 合并分支，将目标分支代码合并到当前分支 tag [tæɡ] tag 标记版本标签，为重要提交打版本快照 remote [rɪˈməʊt] remote 远程仓库管理，添加、查看、修改远程地址 push [pʊʃ] push 推送本地内容到远程，同步本地提交到服务器 pull [pʊl] pull 拉取并合并远程更新，等价于 fetch+merge fetch [fetʃ] fetch 拉取远程更新，仅同步远程跟踪分支不合并 clone [kləʊn] clone 克隆远程仓库到本地，下载完整代码和历史 ignore [ɪɡˈnɔː(r)] ignore 忽略指定文件，配置不被 Git 跟踪的文件 submodule [ˌsʌbˈmɒdjuːl] submodule 子模块管理，嵌套管理其他 Git 仓库 foreach [fəˈriːtʃ] foreach 遍历执行命令，对所有分支/子模块批量操作 origin [ˈɒrɪdʒɪn] origin 默认远程仓库别名，指代克隆的源仓库地址 // 获取按钮和所有折叠段落 const toggleBtn = document.getElementById('toggleAll'); const collapsibles = document.querySelectorAll('.collapsible'); let isAllOpen = false; // 初始状态：全部展开 // 一键切换逻辑 toggleBtn.addEventListener('click', () = { isAllOpen = !isAllOpen; collapsibles.forEach(detail = { detail.open = isAllOpen; // 控制所有details的open属性 }); // 更新按钮文字 toggleBtn.textContent = isAllOpen ? '一键折叠全部' : '一键展开全部'; }); ","date":"2019-01-18","objectID":"/20190118/:0:4","tags":["工具","git"],"title":"git 应用总结与提高","uri":"/20190118/"},{"categories":["software"],"content":"C 语言总结与提高","date":"2018-12-10","objectID":"/20181210/","tags":["语法","C"],"title":"C 语言总结与提高","uri":"/20181210/"},{"categories":["software"],"content":" /* 一键按钮悬浮左下角样式 */ #toggleAll { font-size: 10px; position: fixed; left: 15px; bottom: 15px; z-index: 9999; box-shadow: 0 2px 8px rgba(0,0,0,0.2); transition: background 0.3s ease; } #toggleAll:hover { background: #eee; } 一键展开全部 ","date":"2018-12-10","objectID":"/20181210/:0:0","tags":["语法","C"],"title":"C 语言总结与提高","uri":"/20181210/"},{"categories":["software"],"content":"前言 C 语言是兼具高效与灵活的结构化编程语言，诞生于 1972 年，兼具低级语言的硬件操控能力和高级语言的抽象特性，能直接操作内存、寄存器，适配操作系统、嵌入式等底层开发场景。其长久不衰的核心原因：语法简洁通用，跨平台性强，编译器生态成熟；贴近硬件的高效性无可替代，是操作系统、驱动、嵌入式固件的核心开发语言；同时作为编程入门经典，衍生出 C++、Java 等语言，奠定了编程基础，至今仍是底层开发与系统编程的首选。 ","date":"2018-12-10","objectID":"/20181210/:0:1","tags":["语法","C"],"title":"C 语言总结与提高","uri":"/20181210/"},{"categories":["software"],"content":"基本语法 1、数据类型关键字 //A.基本数据类型(5个) int :整型数据,通常为默认类型； float :单精度浮点型； double :双精度浮点型； char :字符型类型数据,属于整型数据的一种； void :空类型，声明函数无返回值或无参数,声明无类型指针,显式丢弃运算结果； //B.类型修饰关键字(4个) short :修饰int,短整型数据,可省略被修饰的int； long :修饰int,长整形数据,可省略被修饰的int； signed :修饰整型数据,有符号数据类型； unsigned :修饰整型数据,无符号数据类型； //C.复杂类型关键字(5个) struct :结构体声明； union :共用体声明； enum :枚举声明； typedef :声明类型别名； sizeof :得到特定类型或特定类型变量的大小； //D.存储级别关键字(6个) auto :指定为自动变量,由编译器自动分配及释放。通常在栈上分配 static :指定为静态变量,分配在静态变量区; 修饰函数时,指定函数作用域为文件内部 register :指定为寄存器变量,建议编译器将变量存储到寄存器中使用,也可以修饰函数形参,建议编译器通过寄存器而不是堆栈传递参数 extern :指定对应变量为外部变量,即标示变量或者函数的定义在别的文件中,表示编译器遇到此变量和函数时在其他模块中寻找其定义。 const :指定变量不可被当前线程/进程改变(但有可能被系统或其他线程/进程改变) volatile :指定变量的值有可能会被系统或其他进程/线程改变, 强制编译器每次从内存中取得该变量的值 2、流程控制关键字 //A.跳转结构(4个) return :用在函数体中,返回特定值(或者是void值,即不返回值) continue :结束当前循环,开始下一轮循环 break :跳出当前循环或switch结构 goto :无条件跳转语句 //B.分支结构(5个) if :条件语句,后面不需要放分号 else :条件语句否定分支(与if连用) switch :开关语句(多重分支语句) case :开关语句中的分支标记 default :开关语句中的“其他”分支,可选。 //C.循环结构(3个) for :循环结构,for(1;2;3)4;的执行顺序为1-\u003e2-\u003e4-\u003e3-\u003e2...循环,其中2为循环条件; do :do循环结构,do 1 while(2); 的执行顺序是1-\u003e2-\u003e1...循环,2为循环条件; while :while循环结构,while(1) 2; 的执行顺序是1-\u003e2-\u003e1...循环,1为循环条件; 3、预编译宏命令 #define :定义一个预处理宏 #undef :取消宏的定义 #include :包含文件命令 #include_next :与#include相似, 但它有着特殊的用途 #if :编译预处理中的条件命令, 相当于C语法中的if语句 #ifdef :判断某个宏是否被定义, 若已定义, 执行随后的语句 #ifndef :与#ifdef相反, 判断某个宏是否未被定义 #elif :若#if, #ifdef, #ifndef或前面的#elif条件不满足, 则执行#elif之后的语句, 相当于C语法中的else-if #else :与#if, #ifdef, #ifndef对应, 若这些条件不满足, 则执行#else之后的语句, 相当于C语法中的else #endif :#if, #ifdef, #ifndef这些条件命令的结束标志. defined :与#if, #elif配合使用, 判断某个宏是否被定义 #line :标志该语句所在的行号 # :将宏参数替代为以参数值为内容的字符串常量(包括\"\"号) ## :将两个相邻的标记(token)连接为一个单独的标记 #pragma :说明编译器信息 #warning :显示编译警告信息 #error :显示编译错误信息 4、操作符优先级 表达式 优先级 ()(小括号) [](数组下标) .(结构成员) -\u003e(指针型结构成员) 最高 !(逻辑非) ~(位取反) -(负号) ++(加1) --(减1) \u0026(变量地址) ↑ *(指针所指内容) (type)(类型转换) sizeof(长度计算) │ *(乘) /(除) %(取模) │ +(加) -(减) │ \u003c\u003c(位左移) \u003e\u003e(位右移) │ \u003c(小于) \u003c=(小于等于) \u003e(大于) \u003e=(大于等于) │ ==(等于) !=(不等于) │ \u0026(位与) │ ^(位异或) │ |(位或) │ \u0026\u0026(逻辑与) │ ||(逻辑或) │ ?:(?表达式) │ = += -=(联合操作) │ ,(逗号运算符) 最低 PS：什么是一元操作符、二元操作符、三元操作符？ 一元操作符：如 \u0026 ，p = \u0026x; 二元操作符：如 + ，c = a + b; 三元操作符：如 ?:，x = a ? b : c; 5、数据类型值域范围 5.1、数据类型值域范围： 数据类型 长度/bit 长度/Byte 值域范围 bit 1 … 0,1 unsigned char 8 1 0~255 signed char 8 1 -128~127 unsigned int 16 2 0~65536 singned int 16 2 -32768~32767 unsigned long 32 4 0~4294967295 singned long 32 4 -2147483648~2147483647 float 32 4 -3.40E+38~3.40E+38 (有效小数位为6-7) double 64 8 -1.79E+308~1.79E+308 (有效小数位为15-16) 5.2、科学计数法： 科学计数法 说明 1.23456789e+8 = 123456789，小数点需要往【右】移动【8】位 1.2345e-3 = 0.0012345，小数点需要往【左】移动【4】位 5.3、浮点数的数据类型： 数据类型 符号位 （位数与正负） 指数位 （位数与范围） 尾数位 （位数与范围） float 1bit 0: 正数，1: 负数 8bits -128~127 23bits 0~(2^23) double 1bit 0: 正数，1: 负数 11bits -1024~1023 52bits 0~(2^52) 5.4、浮点数的数学法则： 类别 算式案例 数学法则 符号位 ±（正负号） 由“浮点数符号位”决定，0: 正数，1: 负数 指数位 1.111……1（二进制数） 【算式整数】固定为“1”，【算式小数】为“浮点数指数的二制数值” 尾数位 2^12356（十进制数） 【算式底数】固定为“2”，【算式指数】为“浮点数尾数的转换后十进制数” 5.5、浮点数的公式： 数值 = (±符号位)((2^指数)(1+(尾数/尾数最大值))) floatL：数值 = (±符号位)((2^指数)(1+(尾数/(2^23)))) double：数值 = (±符号位)((2^指数)*(1+(尾数/(2^25)))) 浮点数19.625用float是如何存储的： 将浮点数转换成二进制：10011.101（将 19.625 整数部分采用除 2 取余，小数部分采用乘 2 取整法）； 用科学计数法表示二进制浮点数：1.0011101*2^4； 计算指数偏移后的值：127 + 4 = 131 （10000011）； 拼接综上所述，float 类型的 19.625 在内存中的值为：0 – 10000011 – 001 1101 0000 0000 0000 0000。 C语言浮点数float类型的秘密 \u003e 补注： \u003e E-38就是小数点需要往左移动38位 \u003e E+38就是小数点需要往右移动38位 \u003e float : 1bit（符号位） 8bits（指数位,最高位为符号位,即数值是7bits） 23bits（尾数位） \u003e double: 1bit（符号位）11bits（指数位,最高位为符号位,即数值是10bits）52bits（尾数位） \u003e float : 【指数数值】: 最大值:(2^7)-1=127, 最小值:-(2^7)=-128, 即【指数数值】范围:-128~127, 精度:1 \u003e float : 【尾数数值】: 最大值:(2-(1/(2^23)))≈2, 最小值:(2-(1/(2^0)))=1, 即【尾数数值】范围:1.0~2.0, 精度:(0~(2^23))/(2^23) \u003e double: 【指数数值】: 最大值:(2^10)-1=1023, 最小值:-(2^10)=-1024, 即【指数数值】范围:-1024~1023, 精度:1 \u003e double: 【尾数数值】: 最大值:(2-(1/(2^52)))≈2, 最小值:(2-(1/(2^0)))=1, 即【尾数数值】范围:1.0~2.0, 精度:(0~(2^23))/(2^52) \u003e 数值 = (±符号位)((2^指数数值) * 1.尾数数值) \u003e 数值 = (±符号位)((2^指数数值) * 1.尾数二进制数值) \u003e 备注-1：“1.尾数二进制数值”的“1”是带小数点二进制数的整数部分 \u003e 备注-2：“1.尾数二进制数值”的“尾数二进制数值”是带小数点二进制数的小数部分 \u003e 数值 = (±符号位)((2^指数)*(1+(尾数/尾数最大值))) \u003e 参考 [网文1](https://blog.csdn.net/black_kyatu/article/details/7925734","date":"2018-12-10","objectID":"/20181210/:0:2","tags":["语法","C"],"title":"C 语言总结与提高","uri":"/20181210/"},{"categories":["software"],"content":"宏定义应用 1、位操作 //生成第n位为1的立即数(n=0表示bit0) #define XT_1BIT_GEN(n) (1UL\u003c\u003c(n)) //生成第n位为0的立即数(n=0表示bit0) #define XT_0BIT_GEN(n) (~(1UL\u003c\u003c(n))) //生成第n~m位为1的立即数((n=0表示bit0) #define XT_1BITS_GEN(n,m) (((~0UL)\u003e\u003e(32-((m)-(n)+1)))\u003c\u003c(n)) //生成第n~m位为0的立即数(n=0表示bit0) #define XT_0BITS_GEN(n,m) (~(((~0UL)\u003e\u003e(32-((m)-(n)+1)))\u003c\u003c(n))) //将变量数x的第n位置位(n=0表示bit0) #define XT_BIT_SET(x,n) ((x) | (1UL\u003c\u003c(n))) //将变量x的第n位清零(n=0表示bit0) #define XT_BIT_CLR(x,n) ((x) \u0026 (~(1UL\u003c\u003c(n)))) //将变量x的第n~m位置位(n=0表示bit0) #define XT_BITS_SET(x,n,m) ((x) | (((~0UL)\u003e\u003e(32-((m)-(n)+1)))\u003c\u003c(n))) //将变量x的第n~m位清零(n=0表示bit0) #define XT_BITS_CLR(x,n,m) ((x) \u0026 (~(((~0UL)\u003e\u003e(32-((m)-(n)+1)))\u003c\u003c(n)))) //获取变量x的第n~m位数(n=0表示bit0) #define XT_BITS_GET(x,n,m) ((x) \u0026 (((~0UL)\u003e\u003e(32-((m)-(n)+1)))\u003c\u003c(n))) //获取变量x的第n~m位并转成低位数(n=0表示bit0) #define XT_BITS_GET2(x,n,m) (((x) \u0026 (((~0UL)\u003e\u003e(32-((m)-(n)+1)))\u003c\u003c(n))) \u003e\u003e (n)) 2、结构体运算 //算出结构体某个成员占的空间大小 (使用例子: XT_STRUCT_MB_SZ(dev_obj_t, name/*不能有[0]*/)) #define XT_STRUCT_MB_SZ(s,m) (((uint32_t)(sizeof(((s *)0)-\u003em)))) //算出结构体某个成员的前面成员占的空间大小 (使用例子: XT_STRUCT_100PART_SZ(dev_obj_t, name)) #define XT_STRUCT_100PART_SZ(s,m) (((uint32_t)(\u0026(((s *)0)-\u003em)))) //算出结构体某个成员和前面成员占的空间大小 (使用例子: XT_STRUCT_110PART_SZ(dev_obj_t, name/*不能有[0]*/)) #define XT_STRUCT_110PART_SZ(s,m) (((uint32_t)(\u0026(((s *)0)-\u003em))) + ((uint32_t)(sizeof(((s *)0)-\u003em)))) //算出结构体某个成员的后面成员占的空间大小 (使用例子: XT_STRUCT_001PART_SZ(dev_obj_t, name/*不能有[0]*/)) #define XT_STRUCT_001PART_SZ(s,m) (((uint32_t)(sizeof(s))) - ((uint32_t)(\u0026(((s *)0)-\u003em))) - ((uint32_t)(sizeof(((s *)0)-\u003em)))) //算出结构体某个成员和后面成员占的空间大小 (使用例子: XT_STRUCT_011PART_SZ(dev_obj_t, name)) #define XT_STRUCT_011PART_SZ(s,m) (((uint32_t)(sizeof(s))) - ((uint32_t)(\u0026(((s *)0)-\u003em)))) //算出结构体某个成员在结构体中的位置偏移量 (使用例子: XT_STRUCT_MB_OFFSET(dev_obj_t, name)) #define XT_STRUCT_MB_OFFSET(s,m) (((uint32_t)(\u0026(((s *)0)-\u003em)))) //算出结构体某个成员后一个成员的位置偏移量 (使用例子: XT_STRUCT_NX_OFFSET(dev_obj_t, name/*不能有[0]*/)) #define XT_STRUCT_NX_OFFSET(s,m) (((uint32_t)(\u0026(((s *)0)-\u003em))) + ((uint32_t)(sizeof(((s *)0)-\u003em)))) 3、数据合成 //将[uint8_t]合并成[uint16_t] (d2作最高位, d1最低位) #define XT_U8_TO_U16(d2,d1) ((((uint16_t)(d2) \u0026 0xFF) \u003c\u003c 8) | ((uint16_t)(d1) \u0026 0xFF)) //将[uint16_t]合并成[uint32_t] (d2作最高位, d1最低位) #define XT_U16_TO_U32(d2,d1) ((((uint32_t)(d2) \u0026 0xFFFF) \u003c\u003c 16) | ((uint32_t)(d1) \u0026 0xFFFF)) //将[uint8_t]合并成[uint32_t] (d4作最高位, d1最低位) #define XT_U8_TO_U32(d4,d3,d2,d1) ((((uint32_t)(d4) \u0026 0xFF) \u003c\u003c 24)\\ |(((uint32_t)(d3) \u0026 0xFF) \u003c\u003c 16)\\ |(((uint32_t)(d2) \u0026 0xFF) \u003c\u003c 8)\\ |(((uint32_t)(d1) \u0026 0xFF) )) 4、数据转换 //二进制书写格式数据转换 (使用例子: XT_0XBIN_TO_HEX16(0x00001111,0x11110000)) #define XT_0XBIN_TO_HEX8(n) (((n\u003e\u003e(28-7))\u00260x80)|((n\u003e\u003e(24-6))\u00260x40)|((n\u003e\u003e(20-5))\u00260x20)|((n\u003e\u003e(16-4))\u00260x10)|\\ ((n\u003e\u003e(12-3))\u00260x08)|((n\u003e\u003e( 8-2))\u00260x04)|((n\u003e\u003e( 4-1))\u00260x02)|((n) \u00260x01)) #define XT_0XBIN_TO_HEX16(n1,n0) (((uint16_t)(XT_0XBIN_TO_HEX8(n1))\u003c\u003c8)|(XT_0XBIN_TO_HEX8(n0)\u00260xFF)) #define XT_0XBIN_TO_HEX32(n3,n2,n1,n0) (((uint32_t)(XT_0XBIN_TO_HEX8(n3))\u003c\u003c24)|((uint32_t)(XT_0XBIN_TO_HEX8(n2))\u003c\u003c16)\\ |((uint32_t)(XT_0XBIN_TO_HEX8(n1))\u003c\u003c8)|(XT_0XBIN_TO_HEX8(n0)\u00260xFF)) //二进制书写格式数据转换 (使用例子: XT_8BIN_TO_HEX16(00001111,11110000)) #define _XT_8BIN_TO_HEX8(n) XT_0XBIN_TO_HEX8(0x##n##UL) //应用程序不能调用本宏,请调用下行宏定义 #define XT_8BIN_TO_HEX8(n) _XT_8BIN_TO_HEX8(n) #define XT_8BIN_TO_HEX16(n1,n0) (((uint16_t)(_XT_8BIN_TO_HEX8(n1))\u003c\u003c8)|(_XT_8BIN_TO_HEX8(n0)\u00260xFF)) #define XT_8BIN_TO_HEX32(n3,n2,n1,n0) (((uint32_t)(_XT_8BIN_TO_HEX8(n3))\u003c\u003c24)|((uint32_t)(_XT_8BIN_TO_HEX8(n2))\u003c\u003c16)\\ |((uint32_t)(_XT_8BIN_TO_HEX8(n1))\u003c\u003c8)|(_XT_8BIN_TO_HEX8(n0)\u00260xFF)) 5、序列化提取 X-MACRO（X-宏）是一种用于维护代码或数据并行列表的可靠技术，核心优势在于确保多个关联列表始终保持顺序一致（匹配）。其应用场景广泛，可覆盖数组、枚举、结构体、普通列表及代码段生成等场景；本质是通过定义「汇总集合表」，实现使用时对某类或多类元素的批量提取与复用。 // 事先编排的宏与组员关系表（注：DEF_X() 还没有定义，后面使用时才定义） #define XCMD_PFUNC \\ DEF_X(PLAY , func_play ) \\ DEF_X(PAUSE , func_pause ) \\ DEF_X(STOP , func_stop ) \\ DEF_X(PLAY_NEXT, func_play_next) \\ DEF_X(PLAY_PREV, func_play_prev) // 利用预编译生成有序枚举(表)：enum {PLAY, PAUSE, STOP, PLAY_NEXT, PLAY_PREV} typedef enum { #define DEF_X(n,p) n, XCMD_PFUNC #undef DEF_X XCMD_MAX }tXCMD; // 利用预编译生成指针数组(表)：pfunc[] = {func_play, ","date":"2018-12-10","objectID":"/20181210/:0:3","tags":["语法","C"],"title":"C 语言总结与提高","uri":"/20181210/"},{"categories":["software"],"content":"预处理应用 1、条件判断 主要包括 #if、#elif、#else、#ifdef、#ifndef 和 #endif，其使用需以 #define（定义宏）和 #undef（取消宏定义）为前提，用于实现宏条件编译相关逻辑。 #include \u003cstdio.h\u003e ///////////////////////// \u003c- 使用标准输入输出，如：sprintf(p,...) 等 int main(int argc, char *argv[]) { #define XXXX 11 #ifdef XXXX printf(\"01. #ifdef XXXX\\n\"); #endif #ifndef YYYY printf(\"02. #ifndef YYYY\\n\"); #endif #if (defined XXXX) \u0026\u0026 !(defined YYYY) printf(\"03. #if (defined XXXX) \u0026\u0026 !(defined YYYY)\\n\"); #endif #undef XXXX #define XXXX 22 printf(\"04. #undef XXXX\\n\"); printf(\"05. #define XXXX 22\\n\"); #if (XXXX == 22) printf(\"06. #if (XXXX == 22)\\n\"); #endif #if (XXXX == 11) printf(\"07. #if (XXXX == 11)\\n\"); #elif (XXXX == 22) printf(\"08. #elif (XXXX == 22)\\n\"); #endif #if (XXXX == 33) printf(\"09. #if (XXXX == 33)\\n\"); #else printf(\"10. #else\\n\"); #endif // etchar(); //等待键盘输入， return 0; //有输入就退出。 } // 输出结果：（由gcc编译） // 01. #ifdef XXXX // 02. #ifndef YYYY // 03. #if (defined XXXX) \u0026\u0026 !(defined YYYY) // 04. #undef XXXX // 05. #define XXXX 22 // 06. #if (XXXX == 22) // 08. #elif (XXXX == 22) // 10. #else 2、错误警告 主要包括 #error 和 #warning，二者用于在编译器编译阶段主动输出错误或警告信息，帮助开发者快速定位代码问题。 #include \u003cstdio.h\u003e ///////////////////////// \u003c- 使用标准输入输出，如：sprintf(p,...) 等 int main(int argc, char *argv[]) { #define XXXX 11 #if (XXXX != 22) #warning 警告：XXXX != 22 #endif printf(\"run 22\\n\"); #if (XXXX != 33) #error 错误：XXXX != 33 #endif printf(\"run 33\\n\"); // #if (XXXX != 44) // #warning 警告：XXXX != 44 // #endif // printf(\"run 44\\n\"); // etchar(); //等待键盘输入， return 0; //有输入就退出。 } // 编译结果：（由gcc编译） // test.c: In function ‘main’: // test.c:8:3: warning: #warning 警告：XXXX != 22 [-Wcpp] // 8 | #warning 警告：XXXX != 22 // | ^~~~~~~ // test.c:13:3: error: #error 错误：XXXX != 33 // 13 | #error 错误：XXXX != 33 // | ^~~~~ 3、文件名/行号 主要包括 #line 指令，标准语法为 #line 行号 \"文件名\"（行号必填），用于重定义当前文件的行号与文件名。 #include \u003cstdio.h\u003e ///////////////////////// \u003c- 使用标准输入输出，如：sprintf(p,...) 等 int main(int argc, char *argv[]) { // 打印原始信息（验证） printf(\"原始文件行号：行号=%-3d, 文件=%s\\n\", __LINE__, __FILE__); // 输出 6, test.c // 第一步：修改行号和文件名（模拟代码生成场景） #line 100 \"code.txt\" printf(\"修改后当前行：行号=%-3d, 文件=%s\\n\", __LINE__, __FILE__); // 输出 100, code.txt printf(\"修改后下一行：行号=%-3d\\n\", __LINE__); // 输出 101 // 第二步：手动还原原始行号和文件名 #line 15 \"test.c\" printf(\"恢复后当前行：行号=%-3d, 文件=%s\\n\", __LINE__, __FILE__); // 输出 15, test.c（注：实际是还原后的逻辑行号） printf(\"恢复后下一行：行号=%-3d\\n\", __LINE__); // 输出 16 （按原始规则递增） // etchar(); //等待键盘输入， return 0; //有输入就退出。 } // 输出结果：（由gcc编译） // 原始文件行号：行号=6 , 文件=test.c // 修改后当前行：行号=100, 文件=code.txt // 修改后下一行：行号=101 // 恢复后当前行：行号=15 , 文件=test.c // 恢复后下一行：行号=16 4、字符拼接 在 C 语言预处理阶段，#（字符串化运算符）与 ##（连接运算符）是两类特殊的预处理操作符，其核心特性会阻止参数在预处理阶段的递归扩展—— 这一特性要求开发者在实际应用时需重点关注参数传递规则，避免因未预期的宏替换行为导致语法错误或逻辑异常。 #include \u003cstdio.h\u003e ///////////////////////// \u003c- 使用标准输入输出，如：sprintf(p,...) 等 int main(int argc, char *argv[]) { // # 使用++++++++++++++++++++++++++ #define S abcd #define _STR(s) #s // 例如：_STR(hello) 代表 \"hello\"，即多了双引号，变为字符串 #define STR(s) _STR(s) printf(\"1. %s\\n\", _STR(S)); //【错误】预想展开为：abcd, 但实际为：S（即 # 会阻参数展开） printf(\"2. %s\\n\", STR(S)); //【正确】正常展开为：abcd // # ## 使用+++++++++++++++++++++++ #define A 2 #define _CONS(a,b) 0x##a##e##b #define CONS(a,b) _CONS(a,b) printf(\"3. %s\\n\", STR(_CONS(A,A))); //【错误】预想展开为：0x2e2, 但实际为：0xAeA（即 ## 会阻参数展开） printf(\"4. %s\\n\", STR( CONS(A,A))); //【正确】正常展开为：0x2e2 printf(\"5. %d\\n\", CONS(A,A) ); } // 输出结果：（由gcc编译） // 1. S // 2. abcd // 3. 0xAeA // 4. 0x2e2 // 5. 738 __ANONYMOUS0(static int, __LINE__); 第二层： - ___ANONYMOUS1(static int, _anonymous, 70); 第三层： - static int _anonymous70; -- 5、头文件应用技巧 5.1、头文件一般格式 /** * @file xt_key.h * @brief 按键头文件 * COPYRIGHT (C) 2022, XT 技术联合小组 * Change Logs: * Date Author Notes * 2022-11-08 o2ospring 原始版本 */ #ifndef XT_KEY_H__ #define XT_KEY_H__ #include \u003cstdint.h\u003e //////////////////////// \u003c- 使用的数据定义，如: int8_t, uint32_t 等 #ifdef __cplusplus extern \"C\" { #endif ......略 #ifdef __cplusplus } #endif #endif //#ifndef XT_KEY_H__ 5.2、头文件里声明变量技巧 // 1、在 c 文件最前面 #define XT_KEY_C__ #include \"xt_key.h\" // 2、在 h 头文件中声明 #ifdef XT_KEY_C__ KEY_EXT #else KEY_EXT extern #endif KEY_EXT uint8_t key; //声明一个变量","date":"2018-12-10","objectID":"/20181210/:0:4","tags":["语法","C"],"title":"C 语言总结与提高","uri":"/20181210/"},{"categories":["software"],"content":"指针与地址 1、数组及其地址 #include \u003cstdio.h\u003e ///////////////////////// \u003c- 使用标准输入输出，如：sprintf(p,...) 等#include \u003cstdint.h\u003e //////////////////////// \u003c- 使用的数据定义，如: int8_t, uint32_t 等 int main(int argc, char *argv[]) { uint32_t a[10]; printf(\" a:%p\\n\", a); //a -\u003e a 只是首个元素a[0]的地址 -\u003e 0x7fff88892960 printf(\" \u0026a:%p\\n\", \u0026a); //\u0026a -\u003e \u0026a 整个数组a[10]的首地址 -\u003e 0x7fff88892960 printf(\" a+1:%p\\n\", a+1); //a+1 -\u003e \u0026a[0] + sizeof(a[0]) -\u003e 0x7fff88892964 printf(\"\u0026a+1:%p\\n\", \u0026a+1); //\u0026a+1 -\u003e \u0026a + sizeof(a) -\u003e 0x7fff88892988 } // 输出结果：（由gcc编译） // a:0x7fff88892960 // \u0026a:0x7fff88892960 // a+1:0x7fff88892964 // \u0026a+1:0x7fff88892988 2、结构体指针 struct obj_stu_ { char name[20]; long num; }; struct obj_stu_ student_1; //p = \u0026student_1; （注：*p 代表结构体 student_1） struct obj_stu_ students[4]; //p = students;（注：*(p+i) 代表结构体 students[i]）（students 与 \u0026students[0] 等价） struct obj_stu_ *p = students; // 1、指针方式访问　（students 代表 \u0026students[0]，即 p 与 students 等价） (p+i)-\u003ename; (p+i)-\u003ename[0]; (p+i)-\u003enum; (students+i)-\u003ename; (students+i)-\u003ename[0]; (students+i)-\u003enum; // 2、结构体方式访问（students 代表 \u0026students[0]，即 p 与 students 等价） students[i].name; students[i].name[0]; students[i].num; p[i].name; p[i].name[0]; p[i].num; (*(p+i)).name; (*(p+i)).name[0]; (*(p+i)).num; //（注：*(p+i) 代表结构体 students[i]） 3、函数指针 // 1、【函数指针】的定义（变量） int (*p_max_fn)(int a, int b); //函数指针定义（p_max_fn：变量） int max(int a, int b) //函数 { return (a \u003e b ? a : b); } p_max_fn = \u0026max; //也可以写成: p_max_fn = max; (*p_max_fn)(a, b); //利用函数指针调用函数（注：*p_max_fn 代表函数 max） // 2、【函数指针类型】的定义（类型） typedef int (*p_max_fn_t)(int a, int b); p_max_fn_t ff(int n); //ff 是返回函数指针的函数（ff：函数） p_max_fn_t p_fn; //定义函数指针: p_fn 为指针变量（p_fn：变量） //3、【函数类型】的定义（类型） typedef int max_fn_t(int a, int b); max_fn_t fn; //fn 用于文件的函数声明（fn：函数） max_fn_t *p_fn; //p_fn 是一个函数指针变量（p_fn：变量） 函数指针高级应用，利用函数指针实现命令行调试工具 // 调试命令表项 #include \u003cstdio.h\u003e ///////////////////////// \u003c- 使用标准输入输出，如：sprintf(p,...) 等#include \u003cstring.h\u003e //////////////////////// \u003c- 使用的字符处理，如: strcpy(), memcpy() 等#include \u003cstdlib.h\u003e //////////////////////// \u003c- 使用到字符转换，如：atoi(s) 等 // 1. 定义函数指针类型 typedef int (*debug_cmd_func_t)(int argc, char *argv[]); // 2. 定义命令表类型 typedef struct { const char *cmd_name; // 命令名（如 \"read_mem\"、\"write_reg\"） const char *cmd_help; // 命令说明（如 \"read_mem \u003caddr\u003e - 读取指定地址的内存\"） debug_cmd_func_t handler; // 命令处理函数指针（空指针=未实现） } debug_cmd_table_t; // 3. 命令表（新增命令只需加表项） static const debug_cmd_table_t debug_cmd_table[] = { {\"read_mem\" , \"read_mem \u003caddr\u003e [len] - 读取指定地址的内存\", read_mem_handler }, {\"write_reg\", \"write_reg \u003creg\u003e \u003cval\u003e - 写入寄存器值\" , write_reg_handler}, {\"help\" , \"help - 显示所有命令\" , help_handler }, {\"exit\" , \"exit - 退出调试\" , exit_handler }, {NULL , NULL , null_cmd_handler } // 表尾哨兵（默认处理） }; // 4. 分割命令行参数（简化版，按空格分割） static int split_cmd(char *input, char *argv[], int max_argc) { int argc = 0; char *p_token = strtok(input, \" \\t\\n\"); //找出一个命令行分割(字符串)的起始地址 while ((p_token != NULL) \u0026\u0026 (argc \u003c max_argc-1)) { argv[argc++] = p_token; p_token = strtok(NULL, \" \\t\\n\"); //找出一个命令行分割(字符串)的起始地址 } argv[argc] = NULL; // 终止符 return argc; // 命令行分割的段数（即有几个 token）（每个命令行分割(字符串)的起始地址为 argv[?]） } // 5. 查找命令对应的处理函数 static debug_cmd_func_t find_cmd_handler(const char *cmd) { for (int i=0; debug_cmd_table[i].cmd_name!=NULL; i++) { if (strcmp(cmd, debug_cmd_table[i].cmd_name) == 0) { // 找出命令对应的函数（若函数指针为空，返回默认空处理） return debug_cmd_table[i].handler ? debug_cmd_table[i].handler : null_cmd_handler; } } // 未知命令，返回默认空处理 return null_cmd_handler; } // 6. 调试主循环 void debug_shell(void) { char input[256]; char *argv[16]; // 最多16个参数 int argc; printf(\"===== 命令行调试工具 =====\\n\"); printf(\"输入 help 查看命令，exit 退出\\n\"); while (1) { // 读取输入 …… 以换行或回车作为一行命令的结束标志 // 分割参数 argc = split_cmd(input, argv, sizeof(argv)/sizeof(argv[0])); if (argc == 0) continue; // 空输入，跳过并进入重新等待输入 // 查找处理函数并调用 debug_cmd_func_t handler = find_cmd_handler(argv[0]); handler(argc, argv); // 核心：调用函数指针 } } PS：针对单片机等轻量级嵌入式应用场景，可先将 debug_cmd_func_t 函数类型定义改为空指针（如：typedef void* debug_cmd_func_t）；在定位到具体函数调用处时，通过 switch-case 分支结构调用参数个数不同的函数，参数传递直接使用原始数据即可（例如统一以 uint32_t 类型传递）。 4、少字节数据向多字节数据赋值 总原则： 『少字节:负数","date":"2018-12-10","objectID":"/20181210/:0:5","tags":["语法","C"],"title":"C 语言总结与提高","uri":"/20181210/"},{"categories":["software"],"content":"打印与格式 1、打印函数 1.1、打印函数与头文件： #include \u003cstdio.h\u003eint printf(const char *format, ...); //输出到标准输出 int fprintf(FILE *stream, const char *format, ...); //输出到文件 int sprintf(char *str, const char *format, ...); //输出到字符串str中 int snprintf(char *str, size_t size, const char *format, ...); //按size大小输出到字符串str中 #include \u003cstdarg.h\u003evoid va_start(va_list ap, last); //\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e int vprintf(const char *format, va_list ap); //输出到标准输出 int vfprintf(FILE *stream, const char *format, va_list ap); //输出到文件 int vsprintf(char *str, const char *format, va_list ap); //输出到字符串str中 int vsnprintf(char *str, size_t size, const char *format, va_list ap); //按size大小输出到字符串str中 void va_end(va_list ap); //\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c 1.2、自定义打印函数： #include \u003cstdio.h\u003e#include \u003cstdlib.h\u003e#include \u003cstdarg.h\u003e void my_printf(const char *fmt, ...) { va_list valist; unsigned int length; #define PRINTFBUF_SIZE 1024 static char printf_buf[PRINTFBUF_SIZE]; va_start(valist, fmt); //\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e /* 方式一：*/ length = vsnprintf(printf_buf, sizeof(printf_buf) - 1, fmt, valist); /* 方式二: *//* switch(*fmt++) { char *p = NULL; int i = 0; char c = 0; case 'd': i = va_arg(valist, int ); break; //d% 类型 case 's': p = va_arg(valist, char *); break; //s% 类型 case 'c': c = (char)va_arg(valist, int ); break; //c% 类型 …… }*/ if (length \u003e PRINTFBUF_SIZE - 1) { length = PRINTFBUF_SIZE - 1; } uart_send(printf_buf, length); //通过串口把格式化后的数据发送出去 va_end(valist); //\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c } 2、调试信息 主要包括 __FILE__、__LINE__、__FUNCTION__、__DATE__、__TIME__、__VER__ 这些预定义宏；其中 __VER__ 用于标识 IDE 版本信息，数据类型为整型。需注意：部分编译器可能会将上述预定义宏以小写形式定义（例如 __file__）。 #include \u003cstdio.h\u003e ///////////////////////// \u003c- 使用标准输入输出，如：sprintf(p,...) 等 void test_func(void) { printf(\"File = %s\\nLine = %d\\nFunc = %s\\nDate = %s\\nTime = %s\\n\", __FILE__, __LINE__, __FUNCTION__, __DATE__, __TIME__); //在第6行 } int main(int argc, char *argv[]) { test_func(); getchar(); //等待键盘输入， return 0; //有输入就退出。 } // 输出结果：（由VC2010编译） // File = c:\\test\\test__func__.cpp // Line = 6 // Func = test_func // Date = Sep 7 2012 // Time = 00:15:42 3、变参数宏 主要由 C99 规范提供的__VA_ARGS__宏来实现，注意 C89 不支持！ #include \u003cstdio.h\u003e ///////////////////////// \u003c- 使用标准输入输出，如：sprintf(p,...) 等#include \u003cstdint.h\u003e //////////////////////// \u003c- 使用的数据定义，如: int8_t, uint32_t 等 int main(int argc, char *argv[]) { #define sensor_printf(...) printf(\"sensor: \" __VA_ARGS__) //由C99规范提供支持（C89不支持） #define sensor_printf2(...) printf(__VA_ARGS__) //由C99规范提供支持（C89不支持） int32_t temp_val = 25; sensor_printf(\"temp = %d℃\\n\", temp_val); sensor_printf2(\"temp = %d℃\\n\", temp_val); } // 输出结果：（由gcc编译） // sensor: temp = 25℃ // temp = 25℃ 4、字符编码 // 语法： \"ABC\" //以ANSI编码或文件编码决定（即：实际是根据文件编码及系统语言决定，并非一定是ANSI编码） L\"ABC\" //以小端Unicode编码（引号前面的大写字母L） // 案例： printf(\"ABC\"); printf(L\"ABC\"); 5、数值格式 %d //输出有符号十进整数。 %u //输出无符号十进整数。 %o //输出八进制数整数。 %x //输出十六进制整数(小写)。 %X //输出十六进制整数(大写)。 %c //输出一个字符。 %s //输出一个字符串。 %f //输出浮点型。 %e //输出指数形式实数。 %g //根据大小自动选f格式或e格式，且不输出无意义的零。 %p //指针(以十六进制整数打印(包括0x字符)，32位机制则打印4字节数值，64位机制则打印8字节数值) %ld //输出有符号十进长整数。 %lu //输出无符号十进长整数。 %lf //输出双精度浮点型。 %5.3f //输出宽度为5(包含小数点)，小数点后面是三位。比如[3.1415926]在[%5.3f]的情况下会自动转换成3.141。 %2x //输出2位十六进制整数(小写).... %2X //输出2位十六进制整数(大写).... %2d //输出2位有符号十进整数, 不足2位时[前面]补空格(即:右对齐) ....其它数据格式类同 %-2d //输出2位有符号十进整数, 不足2位时[后面]补空格(即:左对齐) ....其它数据格式类同 %02d //输出2位有符号十进整数, 不足2位时[自动]补0 .................其它数据格式类同 %8.3f //输出宽度为8(包含小数点)，小数点后面是三位。 12.34-\u003e\" 12.340\" %08.03f //输出宽度为8(包含小数点)，小数点后面是三位。 12.34-\u003e\"0012.340\" %% //输出\"%\"符号 \\\\ //输出\"\\\"符号 \\x //直接填16进制数。比如 \\xFF \\r //回车 \\n //换行 6、断言打印 // 断言判断语句 #define O2O_ASSERT(expression) ((expression) ? (void)0U : assert_failed((uint8_t *)__FILE__, __LINE__)) // 断言打印函数 extern void assert_failed(uint8_t *file, uint32_t line); void assert_failed(uint8_t *file, uint32_t line) { printf(\"assert_failed: File = %s, Line = %d\\n\", file, line); } ","date":"2018-12-10","objectID":"/20181210/:0:6","tags":["语法","C"],"title":"C 语言总结与提高","uri":"/20181210/"},{"categories":["software"],"content":"缩写字典 1、常用编程单词缩写字典 字母 英文描述 标准缩写 备注（使用场景/说明） A Average Avg 平均值计算（如传感器数据均值） Addition Add 加法运算、数据新增 Accumulator Acc 累加器（硬件/算法场景） Address Addr 地址（内存地址、网络地址） Action Act 动作、操作（接口/函数命名） Active Actv 激活状态（修正原重复缩写，与Action区分） Amplitude Amp 振幅（传感器、信号处理） Analog Input AI 模拟输入（硬件I/O） Analog I/O AIO 模拟输入输出（嵌入式硬件） All All 全部、所有（参数/变量命名） Alarm Alm 报警（设备状态提示） Allocate Alloc 分配（内存、资源分配） Analog Output AO 模拟输出（硬件I/O） Apparent App 表观的（如表观功率） Argument Arg 参数（函数参数） Arrange Arrng 排列、配置（数据/硬件布局） Array Arr 数组（简化原全称，代码命名常用） Assemble Asm 汇编（汇编语言、编译过程） Attribute Attr 属性（简化原Attrib，更通用） B Back Bk 后退、背面（如备份、回退功能） Background Bg 后台（进程、任务） Break Brk 中断、跳出（循环/程序流程） Bar Bar 条、棒（图表、硬件组件） Bit Bit 位（二进制单位） Block Blk 块（数据块、内存块） Buffer Buf 缓冲区（数据缓存） Button Btn 按钮（硬件按键、UI组件） Bypass Bypass 旁路（硬件电路、流程跳过） C Calibration Cal 校准（传感器、设备校准） Calculate Calc 计算（算法、数据处理） Configuration Cfg 配置（设备、程序配置） Channel Ch 通道（通信、信号通道） Change Chg 改变、修改（状态/数据变更） Check Chk 检查（校验、状态检测） Clock Clk 时钟（硬件时钟、定时器） Clear Clr 清除（数据、状态清零） Clear Screen Cls 清屏（控制台操作） Command Cmd 命令（指令、控制命令） Compare Cmp 比较（数据比较、条件判断） Complete Comp 完成（任务、流程结束） Count Cnt 计数（数量统计） Counter Ctr 计数器（硬件/软件计数器） Column Col 列（表格、数组列） Communication Comm 通信（设备间通信） Connect Conn 连接（简化原Con，更规范） Construct Cons 构造（对象构造、结构创建） Control Ctrl 控制（控制逻辑、硬件控制） Context Ctx 上下文（程序上下文、环境变量） Convert Conv 转换（数据格式、单位转换） Copy Cp 复制（文件、数据拷贝） Current Cur 当前（当前值、当前状态） Cursor Csr 光标（控制台、UI光标） Control Word CW 控制字（硬件控制寄存器） Color Clr 颜色（统一缩写，去除歧义） D Data Data 数据（全称更通用，保留缩写Dat备用） Date Date 日期（时间相关） Day Day 日（时间单位） Day-of-week DOW 星期（时间格式） Delay Dly 延迟（定时延迟、等待时间） Debounce Deb 消抖（简化原全称，硬件按键消抖常用） Decrease Dec 递减（数值减少） Decimal Dec 十进制（数值格式，与Decrease根据上下文区分） Decode Decode 解码（数据、信号解码） Define Def 定义（宏定义、常量定义） Degree Deg 度（角度、温度单位） Delete Del 删除（数据、文件删除） Destination Dst 目标（目标地址、目标设备） Descriptor Desc 描述符（数据描述、设备描述符） Device Dev 设备（硬件设备） Discrete Input DI 离散输入（硬件I/O） Digit Dig 数字（位、数字量） Discrete I/O DIO 离散输入输出（嵌入式硬件） Discrete Output DO 离散输出（硬件I/O） Disable Dis 禁用（功能、设备禁用） Display Disp 显示（屏幕、显示模块） Discovery Disc 发现（设备发现、服务发现） Division Div 除法、除数（运算相关） Document Doc 文档（文件、说明文档） Down Down 向下、关闭（状态、方向） Dummy Dummy 占位、虚拟（测试数据、虚拟设备） Dynamic Dyn 动态（动态配置、动态内存） E Edge Edge 边沿（信号边沿、触发边沿） Edit Edt 编辑（数据、文件编辑） Effective Eff 有效（有效值、有效状态） Electric Elec 电气（电气设备、电路） Empty Empty 空（状态判断） Enable En 启用（功能、设备启用） Engine Eng 引擎（核心逻辑、驱动引擎） Enter Enter 进入、输入（操作指令） Entries Entries 条目（数据条目） Equivalent Equiv 等效（等效电路、等效值） Error Err 错误（错误码、异常状态） Ethernet Eth 以太网（网络接口） Engineering Units EU 工程单位（传感器测量单位） Event Event 事件（触发事件、中断事件） Extension Ext 扩展（功能扩展、文件扩展名） Exit Exit 退出（程序、函数退出） Exception Exc 异常（程序异常、异常处理） Expiration Exp 过期（时间过期） Exponent Exp 指数（数学运算，与Expiration根据上下文区分） F Field Fld 字段（数据字段、寄存器字段） Flag Flg 标志位（状态标志、标志位） Flush Flush 刷新（缓冲区刷新） Function Func 函数（简化原Fnct，更通用） Format Frm 格式（数据格式、文件格式） Fraction Fract 分数、小数（数值类型） Free Free 空闲（内存空闲、资源空闲） Frequency Freq 频率（信号频率、采样频率） Full Full 满（状态判断） G Gain Gain 增益（放大器增益、信号增益） Get Get 获取（数据获取、接口调用） Generate Gen 生成（数据生成、信号生成） Grid Grd 网格（布局、数据网格） Group Grp 组（设备组、数据组） H Handler Handler 处理器（中断处理、事件处理） Harmonic Harm 谐波（电力、信号谐波） Hexadecimal Hex 十六进制（数值格式） High Hi 高（电平、优先级） History Hist 历史（历史数据、日志） Hit Hit 命中（缓存命中、触发命中） High Priority Task HPT 高优先级任务（实时系统） Hour Hr 小时（时间单位） I Identification Id 标识（设备ID、用户ID） Idle Idle 空闲（设备空闲、线程空闲） Impulse Imp 脉冲（脉冲信号） Image Img 图像（图像数据、显示图像） Increment Inc 递增（数值增加） Information Info 信息（状态信息、提示信息） Initialization Init 初始化（程序、设备初始化） Insert Ins 插入（数据插入、文件插入） Input In 输入（数据输入、硬件输入） Instruction Instr 指令（CPU指令、控制指令） Interrupt Int 中断（硬件中断、软件中断） Invert Inv 反转（信号反转、状态反转） Interrupt Service Routine ISR 中断服务程序（嵌入式开发核心） Index Idx 索引（数组索引、数据索引，修正原Ix更通用） J Jump Jmp 跳转（程序跳转、指令跳转） Join Join 连接（线程连接、数据合并） K Key Key 键（键盘按键、密钥） Keyboard Kbd 键盘（输入设备，修正原Kdb更规范） Kilo K 千（单位前缀，如Kb、KHz） L Label Lab 标签（变量标签、设备标签） Length Len 长度（数据长度、数组长度） List Lst 列表（数据列表，统一缩写去除歧义） Library Lib 库（函数库、静态库） Limit Lim 限制（上限、下限） Low Lo 低（电平、优先级） Lower Lower 小写、下方（状态转换，与Lo区分） Lock Lock 锁定（资源锁定、互斥锁） Low Priority Task LTP 低优先级任务（实时系统） M Manager Mgr 管理器（设备管理器、资源管理器，统一缩写） Magnitude Mag 幅值（信号幅值、数值大小） Ma","date":"2018-12-10","objectID":"/20181210/:0:7","tags":["语法","C"],"title":"C 语言总结与提高","uri":"/20181210/"},{"categories":["software"],"content":"Markdown 语法与工具的介绍","date":"2018-11-01","objectID":"/20181101/","tags":["Markdown"],"title":"Markdown 语法与工具","uri":"/20181101/"},{"categories":["software"],"content":" /* 一键按钮悬浮左下角样式 */ #toggleAll { font-size: 10px; position: fixed; left: 15px; bottom: 15px; z-index: 9999; box-shadow: 0 2px 8px rgba(0,0,0,0.2); transition: background 0.3s ease; } #toggleAll:hover { background: #eee; } 一键展开全部 ","date":"2018-11-01","objectID":"/20181101/:0:0","tags":["Markdown"],"title":"Markdown 语法与工具","uri":"/20181101/"},{"categories":["software"],"content":"一、前言 Markdown 是一种轻量级标记语言，创始人为约翰·格鲁伯（John Gruber）。它允许人们使用易读易写的纯文本格式编写文档，然后转换成有效的 HTML 文档。这种语言吸收了很多在电子邮件中已有的纯文本标记的特性。由于 Markdown 的轻量化、易读易写特性，并且对于图片、图表、数学式都有支持，所以许多网站都广泛使用 Markdown 来撰写帮助文档或是用于论坛上发表消息。 如 GitHub、Reddit、Diaspora、Stack Exchange、OpenStreetMap、SourceForge、简书等，甚至还能被使用来撰写电子书。本人所有博文都是使用 Markdown 语法编写，通过对应工具制作或转换后发表到各类平台上。 ","date":"2018-11-01","objectID":"/20181101/:0:1","tags":["Markdown"],"title":"Markdown 语法与工具","uri":"/20181101/"},{"categories":["software"],"content":"二、语法 1、Markdwon 基本语法： 写一篇文章，主要包括：目录、标题、文本、表格、图片 这几项内容，通过 Markdwon 语法以统一版式为我们格式化文章，让我们专注写作上，而不是排版上。下表已列出 Markdwon 基本语法及作用说明，直接打开一个排版器（如：aclickall）复制下面 Markdwon 语法把效果展示出来（备注：如果本文使用详细文字说明 Markdwon 语法反而把它说的复杂化）。 语法 功能 说明 \\ 转义符 用来可显示语法特殊符号。 *** --- ___ 分割线 前行空行+单独一行及至少三个其符号+空格，特别是 --- 前面必须要加一行空行。三种语句一样的！ # text1 ### text3 ###### text6 标题 1…6 行首加其符号及空格，下行加 === 或 --- 也可表示标题 1 和 2，其中 ### 常用作分类标题。 \u003e text \u003e text 区块 行首加其符号及空格，后面加多一行空行表示结束，\u003e\u003e text 可嵌套 1 层、…。 ``` text ``` 代码区 前个 ``` 不要带空格，后个 ``` 要带有空格。第一个可指出代码语言 (如: ```c)。 每行行首加4个空格或1个Tab符 代码区 全部字符默认颜色显示，关健字不会上色。 1. text1 2. text2 等同： \u003col\u003e \u003cli\u003etext1\u003c/li\u003e \u003cli\u003etext2\u003c/li\u003e \u003c/ol\u003e 有序列表 行首加其数字和点及空格。 \u003col\u003e 是有序列表容器 \u003cli\u003e 是列表子项 + text1 + text2 等同： \u003cul\u003e \u003cli\u003etext1\u003c/li\u003e \u003cli\u003etext2\u003c/li\u003e \u003c/ul\u003e 无序列表 行首加其符号及空格。 \u003cul\u003e 是无序列表容器 \u003cli\u003e 是列表子项 * text1 * text2 无序列表 同上。 - text1 - text2 无序列表 同上。 - [ ] text1 - [x] text2 选项列表 行首加其符号及空格 (注意空格)。 *text* 斜体 文字两侧加其符号 (可嵌套到一些语法中)。 **text** 粗体 文字两侧加其符号 (可嵌套到一些语法中)。 ***text*** 粗斜体 文字两侧加其符号 (可嵌套到一些语法中)。 ~~text~~ 删除线 文字两侧加其符号 (可嵌套到一些语法中)。 `text` 代码段 文字两侧加其符号 (可嵌套到一些语法中)。 [TOC] 文章目录 单独一行，前后多一行空行，文章索引及跳转。 \u003clink或Email\u003e 网址或 Email 直接显示网址或 Email 链接，例如：\u003c99770525@qq.com\u003e 。 [text](https://link \"title\") 文字链接 可链接网址，也可链接本地文件(./01.html)，\"title\"气泡文字，可不写。 ![text](link) 图片导入 可网络图片，也可本地图片(./01.png)。 [![text](link)](https://link2) 图片链接 可网络图片，也可本地图片(./01.png)。 [text][XXX] [XXX]: https://link 链接引用 前行的 XXX 引用后行的 XXX（相当于宏定义），最终结果为 [text](https://link)。 \u003c!-- text --\u003e 有用扩展： 隐藏内容 隐藏内容，可隐藏多行内容 (gitHub支持)。 \u0026nbsp; 有用扩展： 强加空格 强加空格，支持单元格内加空格 (gitHub支持)。 \u003cbr\u003e 有用扩展： 强制换行 强制换行，支持单元格内换行 (gitHub支持)。 \u003cu\u003e下划线文字\u003c/u\u003e 有用扩展： 加下划线 加下划线，可包含Markdwon语法存在 (gitHub支持)。 \u003cs\u003e删除线文字\u003c/s\u003e 有用扩展： 加删除线 加删除线，可包含Markdwon语法存在 (gitHub支持)。 \u003ci\u003e斜体文字\u003c/i\u003e 有用扩展： 斜体文字 斜体文字，可包含Markdwon语法存在 (gitHub支持)。 \u003cstrong\u003e文字加粗\u003c/strong\u003e 有用扩展： 文字加粗 文字加粗，可包含Markdwon语法存在 (gitHub支持)。 \u003ccenter\u003e居中内容\u003c/center\u003e 有用扩展： 文字居中 文字居中，html 语法实现的文字居中 (gitHub支持)。 \u003cdetails close=\"\"\u003e\u003csummary\u003e折叠标题\u003c/summary\u003e 折叠内容 \u003c/details\u003e 有用扩展： 折叠内容 折叠内容，可包含Markdwon语法存在 (gitHub支持)。 \u003ca href=\"https://link\" title=\"提示文字\"\u003e文字链接\u003c/a\u003e 有用扩展： 强加链接 强加链接，如折叠标题中强加文字链接 (gitHub支持)。 \u003ca href=\"https://link\" target=\"_blank\" title=\"提示文字\"\u003e文字链接\u003c/a\u003e 有用扩展： 强加新页面链接 强加新页面链接，如折叠标题中强加文字链接 (gitHub支持)。 \u003cspan id=\"jump\"\u003e跳转到的位置\u003c/span\u003e [点击跳转](#jump) 有用扩展： 页内跳转 页内跳转，Markdwon＋html 语法实现 (gitHub支持)。 \u003cspan style=\"color: #AE87FA;\"\u003e彩色文字\u003c/span\u003e 有用扩展： 彩色文字 彩色文字，html语法实现文字加颜色 (gitHub支持)。 \u003cdiv style=\"width:16px\"\u003e单元格宽度\u003c/div\u003e 有用扩展： 单元格宽 单元格宽，保证单元格至少宽度 16px (gitHub支持)。 备注： 1.1、关于【行首语法符号】的使用，与后面内容必须使用【一个空格】分隔开，这样有效避免一些兼容问题； 1.2、关于【集合性质符号】的使用，在整体前后面各加【一行空行】表示集合，这样有效避免一些兼容问题； 1.3、关于【常规段落换行】的问题，在段落结尾加多【两个空格】再回车换行，这样有效避免一些兼容问题； 1.4、关于【分割线的语法】，前面最好加多【一行空行】，防止【===】和【---】与上行内容组合为【标题1】和【标题2】等问题； 1.5、关于【列表嵌套语法】，要求子列表前加多【4个空格】或【1个TAB格】； 1.6、关于【引用嵌套语法】，增多一个【\u003e】表示嵌套多一层，减少至 n 个【\u003e】且后面只有两个空格时表示退回到第 n 层嵌套； 1.7、关于【单元宽度单位】，分为 pt:点数或磅、px:像素、cm:厘米，常用中文字大小为 14px 或 16px； PS：以页面嵌入播放视频（MP4） \u003c!-- 嵌入播放 --\u003e \u003cvideo controls width=\"600\"\u003e \u003csource src=\"./my_video/my_video2.mp4\" type=\"video/mp4\"\u003e 您的浏览器不支持视频播放 \u003c/video\u003e PS：通过新页面播放视频（MP4） 1、修改原链接，在 HTML 中将链接指向一个播放器页面（如 player.html），并通过 URL 参数传递视频路径： \u003c!-- 某页面链接 --\u003e \u003ca href=\".img/player.html?video=../my_video/my_video2.mp4\"\u003e播放视频\u003c/a\u003e 2、创建播放器页面 (player.html)，新建一个 HTML 文件，内容如下： \u003c!DOCTYPE html\u003e \u003chtml\u003e \u003chead\u003e \u003ctitle\u003e视频播放器\u003c/title\u003e \u003cstyle\u003e body { margin: 0; background: #000; } video { width: 100%; height: 100vh; } \u003c/style\u003e \u003c/head\u003e \u003cbody\u003e \u003cvideo controls autoplay\u003e \u003csource id=\"videoSource\" type=\"video/mp4\"\u003e \u003c/video\u003e \u003cscript\u003e // 从URL参数获取视频路径 const urlParams = new URLSearchParams(window.location.search); const videoFile = urlParams.get('video'); if (videoFile) { document.getElementById('videoSource').src = videoFile; } \u003c/script\u003e \u003c/body\u003e \u003c/html\u003e PS：一键折叠 / 展开 \u003c!-- ----------------------------------------------------------------------------------------------------------------- 【核心说明】： 1、单段折叠：用 HTML 原生 \u003cdetails\u003e + \u003csummary\u003e 标签，无需 JS 即可实现单独折叠 / 展开，兼容性极佳（支持所有现代浏览器）。 2、一键控制：通过 JavaScript 批量修改 \u003cdetails\u003e 的 open 属性（原生属性，控制展开 / 折叠状态），逻辑简单。 3、保留独立操作：单段点击 \u003csummary\u003e 仍可单独控制，一键操作不会影响独立功能。 【关键语法点】： 1、\u003cdetails class=\"collapsible\"\u003e：给所有折叠段添加统一类名，方便 JS 批量选择。 2、detail.open","date":"2018-11-01","objectID":"/20181101/:0:2","tags":["Markdown"],"title":"Markdown 语法与工具","uri":"/20181101/"},{"categories":["software"],"content":"三、工具 1、Markdwon 编辑工具： 1.1、Typora 目前免费，可导出包括 HTML 和 PDF 等多种文件，编辑与预览同一个窗口，使用上可能不太习惯； 1.2、MarkdownPad2 要收费，只能导出 HTML 和 PDF 两种文件，编辑与预览分开两窗口，不支持列表也不支持其它扩展功能； 1.3、Cmd Markdown 作业部落出品，要收费，有网页版和离线版，主要导出 HTML 和 PDF 两种文件，编辑与预览分开两窗口； 1.4、Editor.md 是一款开源的、可嵌入的 Markdown 在线编辑器，支持语法很完整，编辑与预览分开两窗口，可以对标 Cmd Markdown 作业部落编辑器； 2、Markdwon 排版工具： 2.1、aclickall（服务器2、aclickall-github）在线版，自带很多排版样式并且用户可自行定制，支持复制至微信公众号，可生成 HTML 保存到本地。 2.2、Markdown Nice（开源网址）在线版，自带很多排版样式并且用户可自行定制，支持复制至微信公众号、知乎和稀土掘金。 2.3、Dooc 在线版，只自带一种排版样式（有 3 种简单配色），支持复制至微信公众号，可生成 HTML 保存到本地。 2.4、MPEditor 在线版，只自带一种排版样式，支持复制至微信公众号。 2.5、Markdown Here 为安装在浏览器插件，好像只能在 Email 里一键转换，具体没怎样用过。 ● 关于使用 aclickall 生成的 html 网页, 建议手工改如下几处内容： 调整网页相关信息: \u003cmeta name=\"author\" content=\"作者相关信息\"\u003e \u003cmeta name=\"email\" content=\"99770525@qq.com\"\u003e \u003cmeta name=\"description\" content=\"描述内容\"\u003e \u003ctitle\u003e网页标题\u003c/title\u003e 改前: #export_content { margin: 40px 20%; //上下空出40px板边, 左右空出20%板边 改后: #export_content { max-width: 900px; margin: 40px auto; //上下空出40px板边, 左右自动伸展并最大限制为900px（同时适配手机和电脑显示） 3、Markdwon 图标素材： 3.1、96微信编辑器，有图标素材，有模板(要收费)，还有一些小工具(二维码工具也不错)。 ","date":"2018-11-01","objectID":"/20181101/:0:3","tags":["Markdown"],"title":"Markdown 语法与工具","uri":"/20181101/"},{"categories":["software"],"content":"三、参考 https://www.runoob.com/markdown/md-tutorial.html https://cloud.tencent.com/developer/article/1748874 // 获取按钮和所有折叠段落 const toggleBtn = document.getElementById('toggleAll'); const collapsibles = document.querySelectorAll('.collapsible'); let isAllOpen = false; // 初始状态：全部展开 // 一键切换逻辑 toggleBtn.addEventListener('click', () = { isAllOpen = !isAllOpen; collapsibles.forEach(detail = { detail.open = isAllOpen; // 控制所有details的open属性 }); // 更新按钮文字 toggleBtn.textContent = isAllOpen ? '一键折叠全部' : '一键展开全部'; }); ","date":"2018-11-01","objectID":"/20181101/:0:4","tags":["Markdown"],"title":"Markdown 语法与工具","uri":"/20181101/"},{"categories":["other"],"content":"记录工作、生活点滴","date":"2018-08-01","objectID":"/other/","tags":["其它"],"title":"【other 其它杂谈索引】","uri":"/other/"},{"categories":["other"],"content":"前言 工作、生活上必定经历一些事情，有好的、有坏的、有一次的、有多次的，有的过眼云烟、有的印象深刻，没经验的记录下来，有经验总结下来，或许这就是人生。 ","date":"2018-08-01","objectID":"/other/:0:1","tags":["其它"],"title":"【other 其它杂谈索引】","uri":"/other/"},{"categories":["other"],"content":"索引 👉 法律-人生无常之继承法 👉 职业-竞业限制协议 👉 职业-我的社保缴纳情况 👉 职业-对技术型创业团队的看法 👉 职场-曾经希望永远不用发出去的感言 👉 技术-对集控系统优缺点的分析 👉 生活-无产权公寓 👉 生活-冬季皮肤干痒的解决之道 👉 团队-关于软硬兼修二人组电控团队的看法 ","date":"2018-08-01","objectID":"/other/:0:2","tags":["其它"],"title":"【other 其它杂谈索引】","uri":"/other/"},{"categories":null,"content":"我的博客 ","date":"2019-08-02","objectID":"/about/:0:1","tags":null,"title":"关于 o2ospring's blog","uri":"/about/"},{"categories":null,"content":"我的技术平台 ","date":"2019-08-02","objectID":"/about/:0:2","tags":null,"title":"关于 o2ospring's blog","uri":"/about/"},{"categories":null,"content":"我的公众号 。 -- ","date":"2019-08-02","objectID":"/about/:0:3","tags":null,"title":"关于 o2ospring's blog","uri":"/about/"},{"categories":null,"content":"为什么有了微信公众号，还需要个人博客？ 在内容创作领域，微信公众号与个人博客并非“非此即彼”的替代关系，而是能形成互补的“搭档”。许多创作者同时运营两者，核心原因在于两者的定位、功能差异，恰好能满足不同场景下的内容需求——尤其是对技术类创作者而言，这种互补性更为关键。 ","date":"2019-08-02","objectID":"/about/:1:0","tags":null,"title":"关于 o2ospring's blog","uri":"/about/"},{"categories":null,"content":"一、先看微信公众号的“局限”：并非全能 不可否认，微信公众号是个人或组织的“官方发声窗口”，依托微信生态拥有极强的传播力，但它的设计逻辑更偏向“即时推送”，在内容长期管理和灵活创作上存在明显短板： 内容修改受限：作为官方媒体属性的平台，公众号文章发布后灵活性极低——仅支持修改个别错别字（通常不超过20字），无法大幅调整结构、补充信息或修正技术细节，若想彻底优化，只能删除重发（但会丢失原有阅读数据和传播链路）。 推送节奏单一：公众号采用“一篇一推”的模式，多数账号（尤其是个人账号）受限于平台规则或用户接受度，最多一天推送1次、聚焦1个话题，很难连续发布“系列专题内容”（比如一套完整的技术教程、分步骤的实操指南），容易导致内容碎片化，用户难以系统性阅读。 管理功能缺失：公众号没有自带的“自动分类、归档”功能，历史文章只能按发布时间倒序排列。若用户想回顾某一领域的旧文（比如“Python基础”“前端部署教程”），只能靠关键词搜索，效率低；创作者也无法自主梳理内容体系，长期积累后内容库会显得杂乱。 当然，说这些并非否定公众号的价值——它的核心优势“强传播力”无可替代，只是我们需要找到工具来弥补它的上述不足。 ","date":"2019-08-02","objectID":"/about/:1:1","tags":null,"title":"关于 o2ospring's blog","uri":"/about/"},{"categories":null,"content":"二、个人博客的“不可替代性”：为长期内容而生 个人博客恰好能承接公众号的短板，它的核心价值在于“创作者主导”和“长期内容管理”，尤其适合技术类内容创作： 绝对创作自由：博客完全由创作者掌控，文章可随时修改（小到措辞、大到逻辑重构）、补充（新增案例、更新技术版本）、删除，无需受平台规则限制——对技术文章而言，“可迭代更新”至关重要（比如某技术框架升级后，旧文需同步补充新用法）。 完善的内容管理体系：博客自带“主页、分类、标签、归档”功能，创作者可按主题（如“前端开发”“后端架构”）给文章分类，用关键词（如“Vue3”“SpringBoot”）打标签，用户既能按分类系统性阅读系列文章，也能通过标签快速定位细分内容，彻底解决“内容碎片化”问题。 更适配技术创作的附加功能：多数博客支持“代码高亮”（技术文章必备）、“全文搜索”（用户找旧文更高效）、“评论系统”（方便与读者深度讨论技术细节），这些功能都是公众号难以满足的。 ","date":"2019-08-02","objectID":"/about/:1:2","tags":null,"title":"关于 o2ospring's blog","uri":"/about/"},{"categories":null,"content":"三、两者结合的最优解：传播与沉淀兼顾 既然公众号强在“传播”，博客强在“内容沉淀与迭代”，两者结合就能实现“1+1\u003e2”的效果，具体做法可参考： 创作流程：博客先行，公众号跟进 先在个人博客上完成技术文章的初稿创作、结构梳理，反复打磨至无明显错误（甚至可先在博客开放评论，收集读者意见优化）；待内容成熟后，再将定稿同步至微信公众号，借助公众号的传播力触达更多潜在读者。 引导闭环：公众号指向博客最新版 在公众号文章的末尾，明确标注“本文最新版本及后续更新，可访问个人博客链接：XXX”。若后续发现文章需补充（如技术更新、新增案例），只需在博客上修改，无需动公众号的旧文——既保证了读者能获取最新内容，也避免了公众号删改文章的麻烦。 对我而言，这样的搭配还有一个更实际的原因：作为技术创作者，我常因疏忽出现细节错误（比如代码笔误、步骤遗漏），而博客的“可修改性”能让我及时修正，再通过公众号的传播力，把“准确且最新”的技术内容传递给大家。 ","date":"2019-08-02","objectID":"/about/:1:3","tags":null,"title":"关于 o2ospring's blog","uri":"/about/"}]