[{"categories":["MCU"],"content":"涉及 MCU 相关知识","date":"2018-08-06","objectID":"/mcu/","tags":["MCU"],"title":"【MCU 专题文章索引】","uri":"/mcu/"},{"categories":["MCU"],"content":"前言 记录我使用 MCU 软硬件一些经验，涉及 STM8、STM32F103、STM32F429 等单片机，以及单片机内部资源的应用，Keil MDK、IAR、STM32CubeMX 等工具基本使用！ ","date":"2018-08-06","objectID":"/mcu/:0:1","tags":["MCU"],"title":"【MCU 专题文章索引】","uri":"/mcu/"},{"categories":["MCU"],"content":"索引 👉 STM32CubeMX 基本使用 👉 linux-STM32F开发㈠-makefile 构建与使用 👉 linux-STM32F开发㈡-调试器的安装与使用 👉 linux-STM32F开发㈢-在线调试工具CGDB 👉 J-link 调试器日志打印工具-RTT 👉 ARM-Cortex-M 系列 MCU 错误追踪库-CmBacktrace 👉 Keil MDK-获取编译后的 ROM, RAM 大小 👉 Keil MDK-在已运行 MCU 上中途插入调试 👉 ACM32F403RE 国产 MCU 试用笔记 👉 Keil 4 与 Keil 5 的兼容性 ","date":"2018-08-06","objectID":"/mcu/:0:2","tags":["MCU"],"title":"【MCU 专题文章索引】","uri":"/mcu/"},{"categories":["linux"],"content":"涉及 linux/Ubuntu 相关知识","date":"2018-08-05","objectID":"/linux/","tags":["linux"],"title":"【linux 专题文章索引】","uri":"/linux/"},{"categories":["linux"],"content":"前言 记录我学习 linux 基础知识、终端命令的使用、编程编译环境的应用，以及在 linux（Ubuntu）操作系统环境下各类工具软件的安装、配置、使用！ ","date":"2018-08-05","objectID":"/linux/:0:1","tags":["linux"],"title":"【linux 专题文章索引】","uri":"/linux/"},{"categories":["linux"],"content":"索引 👉 linux 学习索引 👉 linux-系统-Ubuntu 系统与工具 👉 linux-命令-linux 基本命令使用 👉 linux-编译-linux 编译构建工具 👉 linux-语法-正则表达式 regex 👉 linux-脚本-轻巧的脚本语言 lua 👉 linux-工具-linux 模拟环境 cygwin 👉 linux-工具-纯文本编辑器 vi 👉 linux-工具-中文输入工具 wubi 👉 linux-工具-网络终端工具 ssh 👉 linux-工具-网络文件系统 nfs 👉 linux-工具-开发环境 JDK 👉 linux-工具-开发工具 Eclipse 👉 linux-工具-博客生成工具 Hugo 👉 linux-工具-博客生成工具 Hexo 👉 linux-工具-网站 PPT 生成工具 Slidev 👉 linux-工具-电子书制作工具 gitbook 👉 linux-工具-网站 node 包管理器 npm 👉 linux-STM32F开发㈠-makefile 构建与使用 👉 linux-STM32F开发㈡-调试器的安装与使用 👉 linux-STM32F开发㈢-在线调试工具CGDB ","date":"2018-08-05","objectID":"/linux/:0:2","tags":["linux"],"title":"【linux 专题文章索引】","uri":"/linux/"},{"categories":["software"],"content":"各种软件技术的介绍","date":"2018-08-04","objectID":"/software/","tags":["软件"],"title":"【software 软件技术索引】","uri":"/software/"},{"categories":["software"],"content":"前言 软件技术包括：编程语言、编程算法、编程思维、数据处理、开源应用模块的使用、实时操作系统的使用等，涉及 C、Lua、RT-thread、FreeRTOS、ucOS、json、MD5、GUI 等等相关技术！ ","date":"2018-08-04","objectID":"/software/:0:1","tags":["软件"],"title":"【software 软件技术索引】","uri":"/software/"},{"categories":["software"],"content":"索引 👉 Markdown 语法与工具 👉 本人 C 语言编程规范 👉 面向对象的 C 语言实现方法 👉 X-MACRO 数据与代码序列化 👉 MD5 对数据加密与校验 👉 CRC 数据校验原理和应用 👉 json 基本语法介绍 👉 regex 正则表达式语法 👉 lua 脚本基本语法 👉 cygwin 之 unix 模拟环境 👉 MinGW-w64 编译套件(GNU 工具集) 👉 attribute-section 编译属性-数据拼接 👉 attribute-aligned 编译属性-地址对齐 👉 attribute-packed 编译属性-字节对齐 👉 attribute-weak 编译属性-弱符号 👉 attribute-un/used 编译属性-未用警告 👉 attribute-at 编译属性-地址指定 👉 FreeRTOS 实时操作系统应用笔记 👉 Serial Studio 数据可视化工具 👉 Visual Scope 串口虚拟示波器工具 ","date":"2018-08-04","objectID":"/software/:0:2","tags":["软件"],"title":"【software 软件技术索引】","uri":"/software/"},{"categories":["hardware"],"content":"各种硬件技术的介绍","date":"2018-08-03","objectID":"/hardware/","tags":["硬件"],"title":"【hardware 硬件技术索引】","uri":"/hardware/"},{"categories":["hardware"],"content":"前言 硬件技术包括：电路设计、PCB 设计、硬件总线、模块方案、强弱电、实验室测试、产品认证，以及 EDA 等相关工具的使用，涉及 Altium Designer、PADS、WIFI、bluetooth、CAN、RS-485 等等相关技术！ ","date":"2018-08-03","objectID":"/hardware/:0:1","tags":["硬件"],"title":"【hardware 硬件技术索引】","uri":"/hardware/"},{"categories":["hardware"],"content":"索引 👉 RGB 屏与 MIPI 屏基本知识 👉 小电路多学问 ","date":"2018-08-03","objectID":"/hardware/:0:2","tags":["硬件"],"title":"【hardware 硬件技术索引】","uri":"/hardware/"},{"categories":["blog"],"content":"记录使用相关工具搭建个人博客的过程","date":"2018-08-02","objectID":"/blog/","tags":["博客"],"title":"【blog 搭建知识索引】","uri":"/blog/"},{"categories":["blog"],"content":"前言 本人不是搞网站开发的，对建站一窍不通，本专题只是记录我搭建个人博客过程的笔记，希望这些笔记能帮助那些像我一样的小白们！本专题的内容包含了 GitBook 电子书、网页 PPT、Hexo、Hugo 博客构建，其中 Hugo 是由 Go 语言实现简单而高效的静态网页构造工具，安装时不需要安装任何依赖软件，很适合我们这些小白搭建免费的个人博客。 ","date":"2018-08-02","objectID":"/blog/:0:1","tags":["博客"],"title":"【blog 搭建知识索引】","uri":"/blog/"},{"categories":["blog"],"content":"索引 👉 博客生成工具 Hugo 👉 博客生成工具 Hexo 👉 网站 PPT 生成工具 Slidev 👉 电子书制作工具 gitbook 👉 网站 node 包管理器 npm ","date":"2018-08-02","objectID":"/blog/:0:2","tags":["博客"],"title":"【blog 搭建知识索引】","uri":"/blog/"},{"categories":["MCU","linux"],"content":"linux-STM32F开发㈢-在线调试工具CGDB","date":"2022-09-16","objectID":"/20220916/","tags":["GDB","ARM Cortex-M"],"title":"linux-STM32F开发㈢-在线调试工具CGDB","uri":"/20220916/"},{"categories":["MCU","linux"],"content":"一、前言 GDB（GNU symbolic debugger）是 Linux 平台下使用最多的一款调试器，常用命令虽不多，但操作起来真心不方便。操作不方便、代码不能高亮、不能边看代码边调试，这几点应该是造成很多人不愿意长期使用的原因（后来集成 TUI 模式有所改善，在调试窗口按Ctrl+X+A进入/退出 TUI 模式）。CGDB 可以看作 GDB 的界面增强版，用来替代 GDB 的 gdb-tui。CGDB 主要功能是在调试时进行代码的同步显示，这无疑增加了调试的方便性，提高了调试效率。界面类似 vi，符合 unix/linux 下开发人员习惯，所以如果熟悉 gdb 和 vi，几乎可以立即使用 CGDB。 ","date":"2022-09-16","objectID":"/20220916/:0:1","tags":["GDB","ARM Cortex-M"],"title":"linux-STM32F开发㈢-在线调试工具CGDB","uri":"/20220916/"},{"categories":["MCU","linux"],"content":"二、安装 1、arm-none-eabi-gdb 的安装 arm-none-eabi-gcc（包含 arm-none-eabi-gdb）为 ARM 框架、无供应商、无系统、嵌入式二进制接口，一般适合 ARM7、Cortex-M、Cortex-R 内核的芯片使用，它使用的是 newlib 这个专用于嵌入式系统的 C 库，用于编译裸机程序（u-boot、kernel、单片机程序），但是不能编译 Linux 应用程序。注意：交叉编译器目前都是 32 位执行程序，依赖 32 位库，事前需要安装 ia32-libs（网文）或 lsb-core。进入网页选择你需要的版本下载：官网最新版、官网 2021 版、Ubuntu-launchpad 软件开发者平台 及依赖 lsb-core。补充：关于 Windows 版本，为直接安装文件，双击安装即可，还有安装后需要手工加入环境变量【如图】。 wget https://developer.arm.com/-/media/Files/downloads/gnu-rm/10.3-2021.10/gcc-arm-none-eabi-10.3-2021.10-x86_64-linux.tar.bz2 #下载交叉编译器压缩包 sudo tar -xjvf gcc-arm-none-eabi-10.3-2021.10-x86_64-linux.tar.bz2 -C /usr/lib/gcc #将交叉编译器压缩包解压到：/usr/lib/gcc sudo gedit /etc/profile #打开环境变量,在文件最后添加内容：export PATH=$PATH:/usr/lib/gcc/gcc-arm-none-eabi-10.3-2021.10/bin source /etc/profile #使能环境变量。 sudo apt-get install lsb-core #64位操作系统需要安装32位依赖库：lsb-core （arm-none-eabi-gcc 用到） sudo apt-get install lib32ncurses5 #64位操作系统需要安装32位依赖库：lib32ncurses5（arm-none-eabi-gdb 用到） arm-none-eabi-gcc -v #查看版本(验证是否安装成功) arm-none-eabi-gdb --version #查看版本(验证是否安装成功) 2、CGDB 的安装 CGDB 可以看作 GDB 的界面增强版（其参考了 GDB TUI 设计和实现），分上下两屏，【上屏】代码区的界面模仿了 Unix 经典的文本编辑器界面：vi，【下屏】还是 GDB 的命令窗口，所以如果熟悉 vi 和 gdb，几乎可以立即使用 CGDB。官方提供源码编译安装方式，用户到 官网 或 github 下载源码，然后自己编译并安装程序。资料：CGDB 中文手册。 ###################################### # 一、安装相关依赖软件 ###################################### sudo apt install autoconf # 安装 autotools 系列工具，包括：autoconf,automake,aclocal,autoheader,autoscan sudo apt install libtool-bin # 安装 libtool 工具 sudo apt install bison # 安装 bison 工具 sudo apt install flex # 安装 flex 工具 sudo apt install texinfo # 安装依赖 sudo apt install libreadline6 # 安装依赖 sudo apt install libreadline6-dev # 安装依赖 sudo apt install libreadline-dev # 安装依赖 sudo apt install libncurses5-dev # 安装依赖 sudo apt install libncursesw5-dev # 安装依赖 ###################################### # 二、下载、编译、安装 ###################################### git clone https://github.com/cgdb/cgdb.git # 下载（使用 git 工具克隆仓库） cd cgdb # 进入文件夹 ./autogen.sh # 生成配置文件 ./configure --prefix=/usr/local/cgdb # 配置，并设置安装目录 sudo gedit /etc/profile # 打开环境变量,在文件最后添加内容：export PATH=$PATH:/usr/local/cgdb/bin source /etc/profile # 使能环境变量。 make # 编译CGDB软件 sudo make install # 安装CGDB软件 cgdb --version # 查看CGDB版本（验证是否安装成功） ","date":"2022-09-16","objectID":"/20220916/:0:2","tags":["GDB","ARM Cortex-M"],"title":"linux-STM32F开发㈢-在线调试工具CGDB","uri":"/20220916/"},{"categories":["MCU","linux"],"content":"三、使用 本案例为基于【5_rt-thread】演示工程（工程路径：5_rt-thread/bsp/stm32/stm32f103-atk-warshipv3），烧录/调试前要对工程进行编译，最终生成固件及调试文件！ 1、arm-none-eabi-gdb 的基本使用 1.1、第一步：在命令窗口启动 OpenOCD 服务 前提条件： 输入命令： sudo openocd -f interface/jlink_swd.cfg -f target/stm32f1x.cfg # 配置文件完整路径：/usr/local/share/openocd/scripts/ 下的 interface/stlink-v2.cfg 和 target/stm32f1x.cfg 结果如下： 备注-1：启动 gdb 对 C/C++ 程序的调试，必须要在编译前就加上 -g 选项！ 备注-2：在 Windows 系统下，j-link 的原厂应用驱动软件，也提供 GDB 对接服务，直接打开【J-Link GDB Server】可视界面操作即可！ 1.2、第二步：在另一命令窗口运行 GDB 调试 ############################################## # ①、在 shell 命令窗口运行 ############################################## # 1.1、运行 gdb arm-none-eabi-gdb ./build/gcc/rt-thread.elf ############################################## # ②、在 gdb 命令窗口运行（输入命令后回车） ############################################## # 2.1、连接 openocd target remote localhost:3333 # 2.2、复位并暂停处理器 monitor reset halt # 2.3、下载固件（实测无需复位暂停处理器直接load也可以） load # 2.4、设置临时断点（main函数） tb main # 2.5、运行程序 c 运行结果： 2、CGDB 的基本使用 2.1、第一步：查看 arm-none-eabi-gdb 版本 # 查看版本，用于验证其是否可正常工作 arm-none-eabi-gdb --version # 版本要求≥7.12 ############################################## # 出现问题：提示信息显示找不到 libncurses.so.5 ############################################## arm-none-eabi-gdb: error while loading shared libraries: libncurses.so.5: cannot open shared object file: No such file or directory ############################################## # 解决方法：安装所需32位依赖库 lib32ncurses5 ！ ############################################## sudo apt-get install lib32ncurses5 备注-1：启动 gdb 对 C/C++ 程序的调试，必须要在编译前就加上 -g 选项！ 备注-2：CGDB（v0.8.0）要调用 arm-none-eabi-gdb，要求 gdb 的版本必须大于等于 7.12 2.2、第二步：在命令窗口启动 OpenOCD 服务 输入命令： sudo openocd -f interface/jlink_swd.cfg -f target/stm32f1x.cfg # 配置文件完整路径：/usr/local/share/openocd/scripts/ 下的 interface/jlink_swd.cfg 和 target/stm32f1x.cfg 结果如下： 2.3、第三步：在另一命令窗口运行 CGDB 调试 ############################################## # ①、在 shell 命令窗口运行 ############################################## # 1.1、运行 cgdb cgdb -d arm-none-eabi-gdb ./build/gcc/rt-thread.elf ############################################## # ②、在 cgdb 命令窗口运行（输入命令后回车） ############################################## # 2.1、连接 openocd target remote localhost:3333 # 2.2、复位并暂停处理器 monitor reset halt # 2.3、下载固件（实测无需复位暂停处理器直接load也可以） load # 2.4、设置临时断点（main函数） tb main # 2.5、运行程序 c 运行结果： 备注：CGDB（v0.8.0）要调用 arm-none-eabi-gdb，要求 gdb 的版本必须大于等于 7.12 3、CGDB/OpenOCD 使用总结 ########连接USB ######## 虚拟机/可移动设备/SEGGER J-Link/连接 ########下载固件######## sudo openocd -f interface/jlink_swd.cfg -f target/stm32f1x.cfg -c init -c \"reset halt; wait_halt; flash write_image erase out/project.hex\" -c reset -c shutdown ########调试程序######## sudo openocd -f interface/jlink_swd.cfg -f target/stm32f1x.cfg # /usr/local/share/openocd/scripts/ 下的 interface/jlink_swd.cfg 和 target/stm32f1x.cfg # 编译加[-g]选项 #【在一个命令窗口启动openocd服务】 cgdb -d arm-none-eabi-gdb ./build/gcc/rt-thread.elf #【在另一命令窗口启动cgdb+gdb服务】 target remote localhost:3333 # 在cgdb里:连接openocd服务 monitor reset halt # 在cgdb里:复位并暂停处理器 load # 在cgdb里:装载调试固件（实测无需复位暂停处理器直接load也可以） tb main # 在cgdb里:在main函数设置临时断点 c # 在cgdb里:运行程序 ","date":"2022-09-16","objectID":"/20220916/:0:3","tags":["GDB","ARM Cortex-M"],"title":"linux-STM32F开发㈢-在线调试工具CGDB","uri":"/20220916/"},{"categories":["MCU","linux"],"content":"三、扩展 1、IDE 集成开发环境的组成 组件 说明 代码编辑工具 IDE 直接使用 QScitinal 这类的编辑器库 代码智能提示 IDE 后台调用 clang 工具 代码语法错误动态检测 IDE 后台调用 gcc 或者 clang 工具 工程源码文件组织 IDE 使用的是 makefile，后台调用 make 工具 编译 IDE 后台调用 gcc 编译器 连接硬件调试器 IDE 后台调用 OpenOCD 连接调试器和板子 下载 IDE 后台调用 OpenOCD 命令下载固件 调试 IDE 后台调用 gdb，给 gdb 发命令，gdb 再给 OpenOCD 发命令，OpenOCD 再指挥调试器控制板子。实现单步执行，查看变量值，寄存器等 ","date":"2022-09-16","objectID":"/20220916/:0:4","tags":["GDB","ARM Cortex-M"],"title":"linux-STM32F开发㈢-在线调试工具CGDB","uri":"/20220916/"},{"categories":["other"],"content":"对技术型创业团队的看法","date":"2022-08-28","objectID":"/20220828/","tags":["其它"],"title":"对技术型创业团队的看法","uri":"/20220828/"},{"categories":["other"],"content":"一、内容 对技术型创业团队，有两个重要组成部分，一个前端，另一个是后端。前端主要是负责制定产品需求和开拓市场，后端主要是产品开发（可能还会包括生产等）。前方需要勇往直前地向前冲锋陷阵，后方需要为前方战士提供足够强大的枪支弹药。枪支弹药犹如基石，只有稳固基石，才能保证战士用力向前蹬。如果基石不稳，战士很容易倒下！当前方为我们找到了切入点，后方需要提供锋利坚硬的刀并用力劈下去。如果刀不锋利，劈不进；如果刀不坚硬，很容易碎掉；如果不用力，无法劈石头。从技术来说，如何做到提供“足够强大的枪支弹药”和“锋利坚硬的刀”？做开发的同学都知道，全新开发一款设备/产品，必定是存在或多或少的问题。就算是启用资深工程师来开发，也不能保证百分百无错误！本人刚做设计时，软硬件都做，后来专注软件方面设计，所以本文主要从软件技术的角度去分析如何保证设计尽可能不出问题…… 待续…… ","date":"2022-08-28","objectID":"/20220828/:0:1","tags":["其它"],"title":"对技术型创业团队的看法","uri":"/20220828/"},{"categories":["MCU","linux"],"content":"linux-STM32F开发㈡-调试器的安装与使用","date":"2022-08-08","objectID":"/20220808/","tags":["Makefile","ARM Cortex-M"],"title":"linux-STM32F开发㈡-调试器的安装与使用","uri":"/20220808/"},{"categories":["MCU","linux"],"content":"一、前言 对于单片机的开发，我们离不开仿真器（烧录器）的使用，平常我们都是图形界面下操作，而本文主要介绍命令窗口下的仿真器驱动安装与使用。目前的 DSP、FPGA、ARM、部分单片机等主流芯片均支持 JTAG 协议，也就是说绝大部分仿真器都是 JTAG 接口。JTAG（Joint Test Action Group 联合测试行动小组）作为一项国际标准测试协议（IEEE 1149.1 兼容），主要用于芯片内部测试和调试。SWD（Serial Wire Debug 串行线调试）是 ARM 设计的协议，用于对其微控制器进行编程和调试。支持 JTAG 接口必定支持 SWD，而且 SWD 使用引脚更少、速度更快、稳定性更好、且支持打印调试信息！ ","date":"2022-08-08","objectID":"/20220808/:0:1","tags":["Makefile","ARM Cortex-M"],"title":"linux-STM32F开发㈡-调试器的安装与使用","uri":"/20220808/"},{"categories":["MCU","linux"],"content":"二、安装 1、j-link 应用驱动安装 待续…… 2、st-link 应用驱动安装 待续…… 3、OpenOCD 应用驱动安装 OpenOCD（Open On-Chip Debugger）是一个开源的 JTAG 上位机调试程序，支持驱动 st-link、j-link 等多种主流的调试器，支持 ARM7、ARM9、ARM10、ARM11 和 Cortex（如：STM32F103） 等多种内核处理器。听说它是一位国外研究生在上学时构思与完成的软件，更多介绍可到【开源中国】看看。OpenOCD 以提供源码方式来编译及安装，所以事先需要安装 make、gcc 工具！关于 OpenOCD 下载，进入【代码仓库站点】，点击里面的 Download 按钮下载 【openocd-0.11.0.zip】 压缩包。如果你没编译条件，也可直接【下载】第三方编译好的软件，解压后配置环境变量即可（加入路径到环境变量，如：D:\\openOCD\\xpack-openocd-0.11.0-5\\bin）。特别说明：由于 OpenOCD 是上位机软件（是仿真器与调试软件之间的连接器），所以压根不能驱动仿真器，所以事先需要安装 USB 硬件驱动程序 【libusb】！资料：官网、官方手册。扩展：【openOCD RISC-V 版】，具体参考【网文】！ 3.1、linux 系统下安装： unzip -q openocd-0.11.0.zip # 解压zip压缩包 cd openocd-0.11.0/ # 进入刚才解压出的文件夹 sudo apt-get install libusb-1.0-0-dev # 安装依赖Libusb库（./configure时会检查libusb组件，找不到会显示：- USB .... no） ./configure # 进行自动默认配置（在最后可以看到支持的调试器类型以及是否已打开） # ./configure --enable-jlink # 如果你使用调试器是J-Link，但默认配置里它没被打开，运行本行命令！ # ./configure -h # 当你的是其它调试器，运行帮助命令查看具体是哪条选项来打开调试器。 make # 编译OpenOCD软件（OpenOCD可以使用gcc和clang两个编译器进行编译） sudo make install # 安装OpenOCD软件（默认安装到 /usr/local/share/openocd/） openocd -v # 查看OpenOCD版本（用于验证是否安装成功，当前版本为：0.11.0） 3.2、安装不正确出现的问题： 3.2.1、libusb 组件的安装问题 3.2.2、烧录固件提示找不到驱动 4、libusb USB 低层硬件驱动介绍 libusb 是一个由 C 语言开发的开源库，可帮助开发者在应用层面上直接与 USB 硬件进行通讯，它属于通用的 USB 硬件驱动库，可跨平台移植。安装 libusb 的目的，其实就是因为 OpenOCD 只把 J-link 等仿真器当作普通的 USB 设备来使用，不使用 J-link 自带的仿真器驱动程序。资料：libusb 新官网、libusb 旧官网、libusb Windows 版、libusb sourceforge 下载、libusb github 下载。 4.1、linux 系统下的编译安装： tar -xjvf libusb-1.0.26.tar.bz2 # 解压压缩包 cd libusb-1.0.26 # 进入刚才解压出的文件夹 ./configure --build=x86_64-linux --disable-udev # 进行基本配置（Windows系统选项参数貌似为：--build=mingw32） # ./configure -h # 可查看一些选项参数内容 make # 编译libusb软件 sudo make install # 安装libusb软件（默认安装到 /usr/local/lib/） 4.2、Windows 系统下的安装工具： 在 Windows 系统下，我们把 j-link 原厂驱动转换成 openocd 可以识别的 Libusb-WinUSB 驱动之后，j-flash、j-Men 等软件就无法使用了，也无法在 Keil 中使用 j-link 烧录和调试程序。如果想使用这些工具，就必须把驱动还原回去，这时候 USBDriverTool 软件就派上用场了。在 USBDriverTool 软件界面上操作如下： a）先插好 j-link 然后在 j-link 设备上单击右键； b）转换：选择Install Libusb-WinUSB即可完成驱动的转换。 c）恢复：选择Restore default driver即可恢复原驱动。 补充：关于【USBDriverTool】与【Zadig】两款驱动工具，可以阅读【解决 openocd 无法识别 jlink 问题】的博文介绍。 ","date":"2022-08-08","objectID":"/20220808/:0:2","tags":["Makefile","ARM Cortex-M"],"title":"linux-STM32F开发㈡-调试器的安装与使用","uri":"/20220808/"},{"categories":["MCU","linux"],"content":"三、使用 1、使用 OpenOCD 软件下载固件 1.1、介绍：openocd 命令行 # openocd命令行格式： openocd -f \u003c下载器配置文件\u003e -f \u003c目标芯片配置文件\u003e -c \u003c执行命令\u003e # 下载固件实用指令： openocd -f interface/stlink-v2.cfg -f target/stm32f1x.cfg -c init -c \"reset halt; wait_halt; flash write_image erase out/project.hex\" -c reset -c shutdown # 相关参数补充说明： -f interface/stlink-v2.cfg #下载器配置文件，表示使用stlink-v2烧录器 （配置文件完整路径：/usr/local/share/openocd/scripts/interface/stlink-v2.cfg） -f target/stm32f1x.cfg #目标芯片配置文件，表示烧录stm32f1x单片机（配置文件完整路径：/usr/local/share/openocd/scripts/target/stm32f1x.cfg） -c init #表示烧录前初始处理器（补充说明：-c init -c halt 是很多博文给出的参数，但应用中出现第一次成功第二次失败的现象，估计 -c halt 有时失效，改为下一行加相关参数） -c \"reset halt; wait_halt; flash write_image erase out/project.hex\" #表示烧录前先复位并暂停处理器，再对flash擦除并写入十六进制文件。如果是二进制文件，其后面空格后加入地址，如: 0x08000000 -c reset #表示烧录后复位处理器 -c shutdown #表示烧录后退出openocd 1.2、准备：烧录器配置文件 ####################################################### # 由于我使用的是 jlink 仿真器，并且接口为 SWD，所以要将 # /usr/share/openocd/scripts/interface/jlink.cfg # 配置脚本另存为：jlink_swd.cfg，并在其里面增加两项参数： # 1、接口改为：SWD # 2、速度改为：20000KHz ####################################################### # # SEGGER J-Link # # http://www.segger.com/jlink.html # adapter driver jlink # add swd config （1、接口改为：SWD） transport select swd # add speed(KHz) config（2、速度改为：20000KHz） adapter speed 20000 # The serial number can be used to select a specific device in case more than # one is connected to the host. # # Example: Select J-Link with serial number 123456789 # # jlink serial 123456789 1.3、烧录：固件烧录操作 1.3.1、第一步： 1.3.2、第二步： ####################################################### # 由于我使用的是 jlink 仿真器，并且接口为 SWD，单片机为 # STM32F103RC，烧录文件为十六进制文件，文件所在相对路径 # 为 out/project.hex，则直接运行下面命令烧录固件： ####################################################### sudo openocd -f interface/jlink_swd.cfg -f target/stm32f1x.cfg -c init -c \"reset halt; wait_halt; flash write_image erase out/project.hex\" -c reset -c shutdown 1.3.3、最终结果： 2、使用 OpenOCD 软件仿真程序 2.1、第一步：查看 arm-none-eabi-gdb 版本 # 查看版本，用于验证其是否可正常工作 arm-none-eabi-gdb --version # 版本要求≥7.12 ############################################## # 出现问题：提示信息显示找不到 libncurses.so.5 ############################################## arm-none-eabi-gdb: error while loading shared libraries: libncurses.so.5: cannot open shared object file: No such file or directory ############################################## # 解决方法：安装所需32位依赖库 lib32ncurses5 ！ ############################################## sudo apt-get install lib32ncurses5 备注-1：启动 gdb 对 C/C++ 程序的调试，必须要在编译前就加上 -g 选项！ 备注-2：CGDB（v0.8.0）要调用 arm-none-eabi-gdb，要求 gdb 的版本必须大于等于 7.12 2.2、第二步：在命令窗口启动 OpenOCD 服务 前提条件： 输入命令： sudo openocd -f interface/jlink_swd.cfg -f target/stm32f1x.cfg # 配置文件完整路径：/usr/local/share/openocd/scripts/ 下的 interface/jlink_swd.cfg 和 target/stm32f1x.cfg 结果如下： 备注：在 Windows 系统下，j-link 的原厂应用驱动软件，也提供 GDB 对接服务，直接打开【J-Link GDB Server】可视界面操作即可！ 2.3、第三步：在另一命令窗口运行 GDB 调试 ############################################## # ①、在 shell 命令窗口运行 ############################################## # 1.1、运行 gdb arm-none-eabi-gdb ./build/gcc/rt-thread.elf ############################################## # ②、在 gdb 命令窗口运行 ############################################## # 2.1、连接 openocd target remote localhost:3333 # 2.2、复位并暂停处理器 monitor reset halt # 2.3、下载固件（实测无需复位暂停处理器直接load也可以） load # 2.4、GDB 相关操作，下面列出常用命令： # r --------run-------\u003e run //运行程序 (指定运行程序文件: run app.exe argv1 argv2) # l --------list------\u003e list //查看文件 (当前运行文件行号: l 100) (指定文件行号: l max.c:5) (接续查看: l ) # b --------break-----\u003e breakpoint //设置断点 (当前运行文件行号: b 100) (指定文件行号: b max.c:5) (指定函数: b main) # tb--------tbreak----\u003e temporarily //临时断点 (当前运行文件行号: tb 100) (指定文件行号: tb max.c:5) (指定函数: tb main)【备注：断点执行后自动取消!】 # clear ----clear-----\u003e clear //清除断点 (当前运行文件行号: clear 100) (指定文件行号: clear max.c:5) (指定函数: clear main) # d --------delete----\u003e delete //删除断点 (删除指定编号断点: d 2)【备注：需要 i b 查看断点编号来配合使用!】 # i b ------info b----\u003e information //查看断点编号与信息 # p --------print-----\u003e print //查看变量 (空格后加变量名称) # s --------step------\u003e step //单步运行 (会进入子函数) # n --------next------\u003e next //单步运行 (不进入子函数) # c -----","date":"2022-08-08","objectID":"/20220808/:0:3","tags":["Makefile","ARM Cortex-M"],"title":"linux-STM32F开发㈡-调试器的安装与使用","uri":"/20220808/"},{"categories":["MCU","linux"],"content":"三、扩展 1、IDE 集成开发环境的组成 组件 说明 代码编辑工具 IDE 直接使用 QScitinal 这类的编辑器库 代码智能提示 IDE 后台调用 clang 工具 代码语法错误动态检测 IDE 后台调用 gcc 或者 clang 工具 工程源码文件组织 IDE 使用的是 makefile，后台调用 make 工具 编译 IDE 后台调用 gcc 编译器 连接硬件调试器 IDE 后台调用 OpenOCD 连接调试器和板子 下载 IDE 后台调用 OpenOCD 命令下载固件 调试 IDE 后台调用 gdb，给 gdb 发命令，gdb 再给 OpenOCD 发命令，OpenOCD 再指挥调试器控制板子。实现单步执行，查看变量值，寄存器等 ","date":"2022-08-08","objectID":"/20220808/:0:4","tags":["Makefile","ARM Cortex-M"],"title":"linux-STM32F开发㈡-调试器的安装与使用","uri":"/20220808/"},{"categories":["MCU","linux"],"content":"linux-STM32F开发㈠-makefile 构建与使用","date":"2022-08-04","objectID":"/20220804/","tags":["Makefile","ARM Cortex-M","STM32CubeMX"],"title":"linux-STM32F开发㈠-makefile 构建与使用","uri":"/20220804/"},{"categories":["MCU","linux"],"content":"一、前言 在 Windows 下有完善的 IDE（集成开发环境）开发工具，开发单片机程序变得简单和傻瓜化，图形界面上所见所得操作，基本不需要我们了解一些专业知识。正是 IDE 太过完善了，导致我们忽略一些技术知识，限制我们技术的提升。如果想进一步提升专业知识，必须要学会在 linux 下开发，本篇文章主要介绍 STM32F 项目工程使用 Makefile 构建、配置、编译。 如果你不熟悉 linux 和 Makefile，建议认真学习下面文章： 《linux-系统-Ubuntu 系统与工具》 《linux-命令-linux 基本命令使用》 《linux-编译-linux 编译构建工具》 ","date":"2022-08-04","objectID":"/20220804/:0:1","tags":["Makefile","ARM Cortex-M","STM32CubeMX"],"title":"linux-STM32F开发㈠-makefile 构建与使用","uri":"/20220804/"},{"categories":["MCU","linux"],"content":"二、构建 1、使用【STM32CubeMX】构建操作 ● 使用【STM32CubeMX】构建一个 demo 工程，在《STM32CubeMX 基本使用》中的第三节【STM32CubeMX 使用】已非常详细介绍了，这里不再赘述！不同的是最后一步设置生成工程时选择【Makefile】选项，如图： 2、使用自己的【Makefile】构建操作 ● 使用自己的 Makefile 构建（本人有自己风格的 Makefile 模板，并且可以对特定模块定制编译参数）。首先参照《STM32CubeMX 基本使用》中的第三节【STM32CubeMX 使用】方法构建一个基本工程，然后使用本人风格 Makefile 模板嵌入工程。至于具体如何编写 Makefile 请参考《linux-编译-linux 编译构建工具》中的【三、make+Makefile 脚本】章节。本节 demo 工程请到仓库中的【4_stm32f1xx】直接下载。将 Makefile 模板几个文件嵌入到软件工程操作方法，如图： 补充：嵌入式处理器需要专用的交叉编译器和编译参数，会多一个启动文件（汇编）和 一个链接器文件（脚本），生成依赖信息的方法也不同，这些主要涉及 [envi.rule] 和 [make.rule] 两个文件，具体请查阅仓库里的【4_stm32f1xx】demo 工程。至于具体参数表示何意，以及如何加入源文件、如何修改编译参数，下面章节将会详细介绍。同时建议你使用代码比较工具比较【4_stm32f1xx】与【3_large】这两个工程中的envi.rule make.rule及三个Makefile文件的差异，直观了解 PC 纯软件 Makefile 与 嵌入式 Makefile 的差异！ 3、关于【STM32F】嵌入式构建特点 一、相比 PC 纯软件工程构建，嵌入式工程构建会多一个启动文件（汇编）和 一个链接器文件（脚本），并且不同处理器需要使用不同启动文件及链接脚本文件（一般都是厂家提供的）。 文件 说明 startup_stm32f103xb.s 处理器启动文件（汇编） STM32F103XB_FLASH.ld 链接器链接文件（脚本） 备注：这两个文件来源: HAL库\\CMSIS\\Device\\ST\\STM32F1xx\\Source\\Templates\\gcc\\。关于【HAL 库】请到【STM32CubeMX】库文件管理目录里提取，一般路径为：C:\\Users\\Administrator\\STM32Cube\\Repository\\。 二、嵌入式编译器主要生成的文件： 文件 说明 .elf 可执行与可链接格式文件（★业界标准文件★），包含了全部的编译链接信息和程序执行数据 .lst 是使用 objdump 反汇编 elf 文件得到的输出文件，它拥有比 map 文件更详细的信息 .map 源代码被工具链构建之后的详细信息，包括固件大小、函数符号、内存映射等 .hex 基于文本描述的 Intel 标准的十六进制数据，用于烧录固件 .bin 纯二进制数据，用于烧录固件 备注：从存储数据的信息量上看：ELF\u003eAXF\u003eHEX\u003eBIN，所以可以将大信息量的文件格式向小信息量的文件格式转换。如：ELF 可以转换为 AXF、HEX、BIN。其中 HEX 文件可转换为 BIN 文件；如果指定了数据起始地址，也可以将 BIN 转换为 HEX 文件。 三、嵌入式编译器有自己独特的选项参数： 选项 说明 -mcpu=cortex-m3 编译/链接：处理器内核架构 -mthumb 编译/链接：指令集架构 -mfpu=fpv4-sp-d16 编译/链接：浮点运算单元（F4系列才有） -Wa,-a,-ad,-alms=xxx.lst 编译：生成 lst 文件，它拥有比 map 文件更详细的信息 -MMD -MP -MF\"xxx.d\" 编译：生成 d 文件，它是源文件包含文件的依赖信息 -Dxxx 编译：加入工程全局宏定义，可多个 -Dxxx 全局宏定义 -g -gdwarf-2 编译：生成 gdb 调试信息 格式为[dward-2] -fdata-sections 编译：对每个数据创建一个 section（section 是 GCC 的最小链接单元） -ffunction-sections 编译：对每个函数创建一个 section（section 是 GCC 的最小链接单元） -Wl,--gc-sections 链接：特别不链接未使用的 section（函数/数据），从而减小执行文件大小（-Wl,表示将编译器参数传给链接器） -Wl,-Map=zzz.map,--cref 链接：打印链接表信息到[zzz.map]文件，--cref 表示输出一个交叉引用表（-Wl,表示将编译器参数传给链接器） -Txxx.ld 链接：使用[xxx.ld]脚本文件作为链接器脚本 -specs=nano.specs 链接：替换精简 C 库以缩小代码大小 -lc -lm -lnosys 链接：标准C库（C lib）、数学库（math）、nosys 库 参数示范如下： # 链接 build/zzz.elf: build/xxx.o build/yyy.o build/bbb.a arm-none-eabi-gcc -mcpu=cortex-m3 -mthumb \\ -T./STM32F103CBTx_FLASH.ld \\ -specs=nano.specs \\ -Wl,--gc-sections \\ -Wl,-Map=build/zzz.map,--cref \\ -o build/zzz.elf \\ build/xxx.o build/yyy.o build/bbb.a -lc -lm -lnosys # 编译-源文件（多了 lst 生成） %.o: %.c arm-none-eabi-gcc -c -mcpu=cortex-m3 -mthumb \\ -g -gdwarf-2 -Wall -Og -fdata-sections -ffunction-sections \\ -DUSE_HAL_DRIVER -DSTM32F103xB -I./inc/ \\ -MMD -MP -MF\"build/xxx.d\" \\ -Wa,-a,-ad,-alms=build/xxx.lst \\ xxxx/xxx.c -o build/xxx.o # 编译-汇编文件（少了 lst 生成） %.o: %.s arm-none-eabi-gcc -x assembler-with-cpp \\ -c -mcpu=cortex-m3 -mthumb \\ -g -gdwarf-2 -Wall -Og -fdata-sections -ffunction-sections \\ -DUSE_HAL_DRIVER -DSTM32F103xB -I./inc/ \\ -MMD -MP -MF\"build/yyy.d\" \\ ./yyy.s -o build/yyy.o 备注：这些参数主要涉及 [envi.rule] 和 [make.rule] 两个文件，具体请查看【4_stm32f1xx】demo 工程。 ","date":"2022-08-04","objectID":"/20220804/:0:2","tags":["Makefile","ARM Cortex-M","STM32CubeMX"],"title":"linux-STM32F开发㈠-makefile 构建与使用","uri":"/20220804/"},{"categories":["MCU","linux"],"content":"三、使用 1、基于【STM32CubeMX】构建的使用 一、在实际的工程应用中，必定要加入自己的源代码文件和配置相关参数。下面为通过与 Keil MDK 的比较，让你快速了解 Makefile 的相关配置，如图： 二、使用 Makefile 编译工程： #################################################### # 在[shell]中进入[Makefile]所在的目录，输入命令执行： #################################################### cd stm32f1xx # 进入操作目录 make all # 执行编译操作（如果想重新全编译，先执行下面命令） make clean # 执行清除操作（清除所有编译出的文件，包括 hex 等） 2、基于自己的【Makefile】构建的使用 一、在实际的工程应用中，必定要加入自己的源代码文件和配置相关参数。下面为通过与 Keil MDK 的比较，让你快速了解 Makefile 的相关配置，如图： 备注：以上主要涉及一个父 Makefile（配置工程及子 Makefile 文件所在目录），一个子 Makefile（统一设置编译文件、包含路径等），n 个子 Makefile（定制模块编译文件、编译参数等）。 二、使用 Makefile 编译工程： #################################################### # 在[shell]中进入[make.rule]所在的目录，输入命令执行： #################################################### cd 4_stm32f1xx # 进入操作目录 make clean # 执行清除操作（同时创建所需文件夹） make all # 执行编译操作（清除操作之后会重新全编译） ","date":"2022-08-04","objectID":"/20220804/:0:3","tags":["Makefile","ARM Cortex-M","STM32CubeMX"],"title":"linux-STM32F开发㈠-makefile 构建与使用","uri":"/20220804/"},{"categories":["MCU","linux"],"content":"四、提升 1、各种编译器的识别宏 1.1、用于在程序里识别不同编译器，通过这些宏可以使用编译器各自特性来编译相关代码： // 1、MDK-ARM 使用编译器的宏名称（ARM RealView） #if defined(__CC_ARM) || defined(__CLANG_ARM) // 2、IAR-ARM 使用编译器的宏名称（IAR EWARM） #elif defined(__ICCARM__) // 3、GNU-gcc 使用编译器的宏名称（GNU Compiler Collection） #elif defined(__GNUC__) #endif 2、gcc 链接脚本基本知识 2.1、默认链接脚本的导出： gcc 编译器都会有默认的链接脚本，当你需要定制链接脚本时（编译时指定链接脚本的选项参数为-T，用法如：-Txxx.ld。在嵌入式应用领域，厂家一般会提供针对其处理器定制的链接脚本，无需我们自己重新编写！），通过命令可以直接导出默认链接脚本： # 1、PC 的 gcc 默认链接脚本导出方法： ld --verbose \u003e my_pc.ld # 2、ARM 的 gcc 默认链接脚本导出方法： arm-none-eabi-ld --verbose \u003e my_arm.ld # 特别备注： # 1）导出的默认链接脚本中，“=====”及前面的文字只是说明信息，首先要把它们删除！ # 2）如果你想保留这些说明信息，可以使用 /**/ 注释符把它们注释掉。 2.2、链接脚本常见关键字： gcc 编译器的链接脚本常用关键字及语法需要我们有所了解，特别是在嵌入式应用领域，需要配置 ROM（FLASH）、RAM 的大小，上电运行第一段代码（函数）等，这些都是通过链接脚本来实现的。 ############################################ # 1、`ENTRY`定义上电运行的第一段代码（函数） ############################################ ENTRY(Reset_Handler) /* 表示上电运行的第一段代码（函数）: Reset_Handler */ ############################################ # 2、`MEMORY`定义储存空间（起始地址及大小） ############################################ MEMORY { RAM (xrw) : ORIGIN = 0x20000000, LENGTH = 20K /* x:执行，r:可读，w:可写 */ FLASH (rx) : ORIGIN = 0x8000000, LENGTH = 128K /* ORIGIN:起始地址，LENGTH:大小 */ } ############################################ # 3、`SECTIONS`定义一些段的链接分布，例如： # text、data、bss 等段。 ############################################ SECTIONS { .text : { . = ALIGN(4); *(.text) *(.text*) } \u003eFLASH .data : { …… } \u003eRAM AT\u003e FLASH .bss : { _sbss = .; /* bss 段开始地址 */ …… _ebss = .; /* bss 段结束地址 */ } \u003eRAM …… } ############################################ # 4、`.`表示当前地址值 ############################################ . = ALIGN(4); /* 表示将当前开始地址强制 4 字节对齐 */ _sdata = .; /* 表示将当前地址值传给[_sdata]变量 */ ############################################ # 5、`KEEP`防止段(sections)的内容不被优化掉， # 因为 -Wl,--gc-sections 链接参数可能会强制 # 优化掉__attribute__((section(\"xxx\")) 定义 # 的 xxx 数据段！ ############################################ __fsymtab_start = .; KEEP(*(FSymTab)) /* 国产 rt-thread 实时操作系统中为其 shell 定义一段专用只读数据段 */ __fsymtab_end = .; __hard_init_fn_start = .; KEEP(*(SORT(.hard_init_fn.*))) /* 本人做的专用硬件初始化的分段列表，SORT()表示对小分段进行递增排序 */ __hard_init_fn_end = .; ############################################################################## # 6、LMA (load memory address)： 载入地址，也就是所有程序和数据储存空间位置。 # VMA (vortual memory address)：执行地址，如将 Flash 数据加载至 RAM 上运行。 # 对于单片机应用，一般不用设置 VMA，也就是说“载入地址”与“运行地址”是同一地址上！ ############################################################################## 3、关于 text、data、bss、heap、stack 的分布 3.1、数据段大小含义： 类型 说明 text 代码（Code）和常量（RO-Data）的大小（ROM） data 已初始化的全局变量（global）和静态变量（static）的大小（RAM/ROM） bss 未初始化的全局变量（global）和静态变量（static）的大小（RAM)。 其初始值一般默认默认为零！从 STM32F103 官方的 .ld 链接文件生成的 .map 文件查到，其包括：heap（堆）和 stack （栈）的大小！ dec text + data + bss 的总和值（十进制表示） hex text + data + bss 的总和值（十六进制表示） 补充 1、程序固件大小（ROM）：text + data 2、程序已用内存（RAM）：data + bss（包括：heap 和 stack 的大小） RAM 堆栈 地址分布 说明 （1）堆区（heap） 在中地址 一般由程序员分配和释放，若程序员不释放，程序结束时可能由操作系统回收。分配方式类似于数据结构中的链表。通过malloc函数申请，通过free函数释放！堆：向高地址扩展！ （2）栈区（stack） 在高地址 由编译器自动分配和释放，存放函数的参数值、局部变量的值等，其操作方式类似于数据结构中的栈。函数调用及函数退出时自动处理！栈：向低地址扩展！ 3.2、各段数据段分布： 3.3、数据段大小获取： // 在 C 语言中，通过如下方式获取某个分段 // 的起始与结束地址，再由计算可得出大小。 // 具体变量名称在链接脚本中找出！！！！！ extern int _sbss; extern int _ebss; #define LINKER_VAR_ZI_START ((void *)\u0026_sbss) #define LINKER_VAR_ZI_LIMIT ((void *)\u0026_ebss) #define LINKER_VAR_ZI_SIZE (((void *)\u0026_ebss) - ((void *)\u0026_sbss)) 3.4、数据段空间不足： # 当数据段空间不足时，编译时一般有如下错误信息： xxxx.elf section '.xxx' will not fit in region 'FLASH' # 表示'FLASH'空间不足，装不下'.xxx'分段数据！ 4、关于 Keil 获取 ROM、RAM 编译大小的方法 《获取 ARM 编译后的 ROM 及 RAM 大小方法及原理》 5、使用自己的【Makefile】构建 rt-thread 工程 5.1、基本构建与使用： 从【4_stm32f1xx】提取 envi.rule、make.rule、Makefile、startup_stm32f103xe.s、STM32F103XE_FLASH.ld 文件，按照上面两章节教程，完成构建、加入编译文件等操作（备注：最终搭建并整理的完整工程请到仓库中【5_rt-thread】直接下载）。同时在父 Makefile 文件根据【STM32F103 正点原子战舰V3开发板】keil MDK 工程配置参数加入 rt-thread 定义的全局宏__RTTHREAD__等： ################################ # 因 rt-thread 使用了几个全局宏， # 需要将它加入变量中： ################################ # 添加全局宏定义,作用于整个项目工程【多个用空格分隔】 # STM32F103芯片选择: STM32F103x6,STM32F103xB,STM32F103xE,","date":"2022-08-04","objectID":"/20220804/:0:4","tags":["Makefile","ARM Cortex-M","STM32CubeMX"],"title":"linux-STM32F开发㈠-makefile 构建与使用","uri":"/20220804/"},{"categories":["MCU","linux"],"content":"五、插曲 1、Windows 系统下编译出错 ● 差异表现： 在 linux 编译成功，但在 Windows 编译出错！ ● 运行环境： 在 Windows 系统 +【TDM-GCC】的 make 工具（注：make 命令名为mingw32-make）+【arm-none-eabi-gcc】交叉编译器 +【git】命令窗口（其集成 linux 基本命令工具）运行 Makefile。 ● 出现问题： ■ 问题一： opening dependency file D:D:/Program Files (x86)/Git/Downloads/tmp/4_stm32f1xx/build/delay.d: Invalid argument错误，一个很奇怪的问题，从提示信息中可以看到 git 的路径硬生生插入到依赖文件的路径中！经过查找，发现是由-MMD -MP -MF\"$(@:%.o=%.d)\"参数引起。这组参数是我参考【STM32CubeMX】生成的 Makefile 加入的，它是指在编译过程中同时生成依赖信息文件。我写的 Makefile 操作路径都使用了【绝对路径】，当我把这个参数强行改为【相对路径】-MMD -MP -MF\"../../build/$(notdir $(@:%.o=%.d))\"进行测试，竟然编译成功了。在 Windows 下-MF为什么不支持【绝对路径】，本人还没找出原因！ ◆ 解决方法一： 按老方法使用-MM参数生成依赖信息文件，避开使用-MF引发问题！但因每编译一个文件会多运行一次 gcc 和调用一次 sed 处理文本，效率会低很多！ ◆ 解决方法二： 调整 Makefile 机制，全部改为使用【相对路径】，于 2022-08-10 已更新全部 demo 工程！ ■ 问题二： ../user/key/key.c:12:99: fatal error: app_cfg.h: No such file or directory错误。其实在此子 Makefile 的编译指令已加-I ./指出包含头文件所在目录，但gcc编译还是找不到头文件，不明白原因！ ◆ 解决方法： 在此子 Makefile 所在目录-I ./基础上再增加指出上级目录名称，例如上级目录名为《applications》，则增加-I ../applications ","date":"2022-08-04","objectID":"/20220804/:0:5","tags":["Makefile","ARM Cortex-M","STM32CubeMX"],"title":"linux-STM32F开发㈠-makefile 构建与使用","uri":"/20220804/"},{"categories":["other"],"content":"我的社保缴纳情况","date":"2022-07-07","objectID":"/20220707/","tags":["其它"],"title":"我的社保缴纳情况","uri":"/20220707/"},{"categories":["other"],"content":"内容 前段时间公司收集员工的社保缴纳累计年/月情况，并把研发中心所有员工的社保缴纳情况汇总下发到群里，让员工自行校对。打开 Execl 文档，排序列表，看到交社保累计最多的一位同事有 265 个月。嗯嗯，老同志，应该是专家级的工程师。再往下看了一下，我竟然排到第 5 位（缴纳累计接近 200 个月），是整个研发中心的第五！惊奇，原来我交了这么多年了！惊讶，原来我这么“老”了！失望，工作了这么多年还是碌碌无为！突然想起了抖音经常听到的那首背景音乐“我还是曾经那个少年，没有一丝丝改变，时间只不过是考验，种在心中信念丝毫未减”，虽然这两年来工作上的不顺利，或许能力不及你，但永不言败！借用小学生都爱唱的神曲《孤勇者》歌词来表达我此刻的心情：“战吗？战啊！以最卑微的梦，以最孤高的梦，致那黑夜中的呜咽与怒吼！谁说站在光里的才算英雄！” ","date":"2022-07-07","objectID":"/20220707/:0:1","tags":["其它"],"title":"我的社保缴纳情况","uri":"/20220707/"},{"categories":["software","linux"],"content":"正则表达式语法的基本介绍","date":"2022-05-27","objectID":"/20220527/","tags":["正则表达式"],"title":"正则表达式","uri":"/20220527/"},{"categories":["software","linux"],"content":"一、简介 正则表达式（Regular Expression /'reɡjələr/ɪk'spreʃn/）是一种文本匹配模式，其使用一组由字母和符号组成的特殊文本来描述用户自定义规则的字符串，用于查找或替换满足你想要格式的文本。许多程序设计语言和脚本语言都支持利用正则表达式进行字符串操作（例如：C# 编程语言、python 脚本语言），以及很多专业文本编辑软件都支持利用正则表达式进行文本查找替换操作（例如：Notepad++ 代码编辑软件、Meld 代码比较工具）。注意：因为正则表达式并不仅限于某一种语言/软件，所以在每种语言中都会有细微的差别。 ","date":"2022-05-27","objectID":"/20220527/:0:1","tags":["正则表达式"],"title":"正则表达式","uri":"/20220527/"},{"categories":["software","linux"],"content":"二、语法 1、额外标记 标记也称为修饰符，正则表达式的标记用于指定额外的匹配策略，可以理解为微调全局匹配规则。 例如：i表示将匹配更改为不区分大小写。 语法：/相关匹配表达式/额外标记 实例：/[a-z]+/ig 额外标记 描述 i ignore —— 忽略大小写，将匹配更改为不区分大小写。 g global —— 全局匹配，表示查找所有匹配项。 m multi line – 多行匹配，使边界字符 ^ 和 $ 匹配更改为每一行的开头和结尾，而不是整段字符串的开头和结尾。 s 将.的匹配更改为包含换行符（\\n）。 2、语法特殊符 2.1、在普通的字符中，存在隐性的控制符，例如 Tab 符和回车符等，这些字符需要转义才能表达出来。 控制类-特殊字符 描述 \\cX 表达一个由 X 指明的控制字符。例如：\\cM 表达一个回车符。X 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的 ‘c’ 字符。 \\t 表示一个　制表符。等价于 \\x09 或 \\cI。 \\n 表示一个　换行符。等价于 \\x0a 或 \\cJ。 \\v 表示一个垂直制表符。等价于 \\x0b 或 \\cK。 \\f 表示一个　换页符。等价于 \\x0c 或 \\cL。 \\r 表示一个　回车符。等价于 \\x0d 或 \\cM。 2.2、匹配语法中，使用了十几个特殊符号来表达匹配规则。当需要显示符号本身时需要转义来呈现。 匹配类-特殊字符 描述 \\\\ \\/ \\| \\( \\) \\[ \\] \\{ \\} \\* \\+ \\? \\. \\^ \\$ 字符转义：匹配中一些特殊字符需要用\\转义来显示符号本身，主要包括 15 个特殊字符：\\ | / ( ) [ ] { } * + ? . ^ $ ，其中 ] } 两个符号可以不用\\转义。 \\ 转义字符：将字符转义为特殊字符、或八进制转义符等等。 | 匹配或项：为或运算符，两项表达式中只要有一项匹配即表示符合规则。 ( ) 匹配捕获：在匹配获得的字符串中，捕获 ( ) 内规则内容放到缓存，简称捕获物，可以有多个捕获物，最多 99 个，\\1 表示访问第一个捕获物（如：(([0-9])\\2) 其中 \\1 表示第一个捕获物为整体，\\2 表示为第二个捕获物的克隆）。注：(?xxx) 语句不是捕获物。 [ ] 匹配字集：与自定义字符集其中一个字符匹配。例如 [0-9] 表示与数字匹配，[^0-9] 表示与非数字匹配。 { } 匹配次数：限制其左边一个字符或一个捕获物的匹配次数为用户指定。例如 [0-9]{3}、[0-9]{3,}、[0-9]{3,5} 分别表示匹配 3 个、n～3 个、5～3 个数字，如果后面加一个?修饰则 [0-9]{3,5}? 表示匹配 3～5 个数字。 * 匹配次数：限制其左边一个字符或一个捕获物的匹配次数为n～0，如果后加多一个?修饰则表示匹配次数为0～n。 + 匹配次数：限制其左边一个字符或一个捕获物的匹配次数为n～1，如果后加多一个?修饰则表示匹配次数为1～n。 ? 匹配次数：限制其左边一个字符或一个捕获物的匹配次数为1～0，如果后加多一个?修饰则表示匹配次数为0～1。 . 匹配字集：与除换行符 ‘\\n’ 之外的任何单字符匹配。备注：个人认为应该是只包括空格、Tab格、及可见字符的任一单字符！ ^ 匹配位置：匹配输入字符串的开始位置。例如 ^[0-9]+ 表示整体以数字开始。如果在 [ ] 里面使用，则表示在 ^ 右边的字符集除外的其它字符集。 $ 匹配位置：匹配输入字符串的结尾位置。例如 [0-9]+$ 表示整体以数字结束。如果设置了 RegExp 对象的 Multiline 属性，则 $ 也匹配 ‘\\n’ 或 ‘\\r’。要匹配 $。 (?:X) 匹配集合：由于规则有优先级，特别是匹配或项 “|” 的使用，使用匹配集合有效解决组合问题。例如 Version_(?:Alpha|Beta) 表示匹配 Version_Alpha 或 Version_Beta 两个字段。 (?\u003c=X)　(?=X) 匹配位置：匹配符合 X 表达式(真条件)的相对开始位置、相对结尾位置，类同 ^ 和 $。例如 (?\u003c=[0-9]+)[a-z]+、[a-z]+(?=[0-9]+) 分别表示匹配以数字开始、以数字结束的文本位置上。 (?\u003c!X)　(?!X) 匹配位置：匹配符合 非X 表达式(假条件)的相对开始位置、相对结尾位置，类同 ^ 和 $。例如 (?\u003c![0-9]+)[a-z]+、[a-z]+(?![0-9]+) 分别匹配表示以非数字开始、以非数字结束的文本位置上。 \\b 匹配位置：匹配一个单词边界位置，即字与空格间的位置。而大写 \\B 表示“非”。 \\d 匹配字集：与数字匹配，即 [0-9]。而大写 \\D 表示“非”，即 [^0-9]。 \\w 匹配字集：与任何的字母、数字、下划线匹配，即 [a-zA-Z0-9_]。而大写 \\W 表示“非”，即 [^a-zA-Z0-9_]。 \\s 匹配字集：与任何的空白字符匹配，即 [ \\t\\n\\v\\f\\r]。而大写 \\S 表示“非”，即 [^ \\t\\n\\v\\f\\r]。注意：包括空格。注意 Unicode 正则表达式会匹配全角空格符。 3、语法优先级 运算符 描述 \\ 转义符 ()、(?:)、(?=)、(?!)、[] 括号符 *、+、?、{n}、{n,}、{n,m} 限定符 ^、$ 定位符 | 或项符 4、语法的图解 在【菜鸟教程-正则表达式】网页中嵌入的【测试工具】非常形象展示正则表达式的语法匹配，利用它加快我们理解正则表达式的语法。 匹配符 展示 ( ) ◆①【n~1 位相邻相同数字】匹配： [ ] ◆①【1 位数字 + 1 位字母】匹配： { } ◆①【3 位数字 + 3 位字母】匹配： ◆②【n~3 位数字 + n~3 位字母】匹配： ◆③【3~n 位数字 + 3~n 位字母】匹配： ◆④【4~3 位数字 + 4~3 位字母】匹配： * ◆①【n~0 位数字 + n~0 位字母】匹配： ◆②【0~n 位数字 + 0~n 位字母】匹配： ◆③【0~n 位数字 + n~0 位字母】匹配： ◆④【0~n 位数字 + “abc\"字母】匹配： + ◆①【n~1 位数字 + n~1 位字母】匹配： ◆②【1~n 位数字 + 1~n 位字母】匹配： ? ◆①【1~0 位数字 + 1~0 位字母】匹配： ◆②【0~1 位数字 + 0~1 位字母】匹配： ◆③【1~0 位数字 + “hi\"字母】匹配： . ◆①【1 位字符 + “hi\"字母】匹配： ◆②【n~1 位字符 + “hi\"字母】匹配： ^ ◆①【整段字符前 10 个字符】匹配： ◆②【每行字符前 10 个字符】匹配： ◆③【整行为大写字符】匹配： $ ◆①【整段字符后 10 个字符】匹配： ◆②【每行字符后 10 个字符】匹配： ◆③【整行为日期字符】匹配： (?:X) ◆①【“23\"或\"78\"数字 + n~1 位字母】匹配： (?\u003c=X)　(?=X) ◆①【在\"23\"数字后面的 n~1 位字母】匹配： ◆②【在\"55\"数字前面的 n~1 位字母】匹配： (?\u003c!X)　(?!X) ◆①【在非\"78\"后面的 n~1 位字母】匹配： ◆②【在非\"55\"前面的 n~1 位字母】匹配： \\b ◆①【在单词边界后面的 n~1 位字母】匹配： ◆②【在非单词边界后面的 n~1 位字母】匹配： \\d ◆①【n~1 位数字】匹配： ◆②【n~1 位非数字】匹配： ","date":"2022-05-27","objectID":"/20220527/:0:2","tags":["正则表达式"],"title":"正则表达式","uri":"/20220527/"},{"categories":["software","linux"],"content":"三、应用 1、应用软件 只要有文本查找、替换操作，都有可能使用到正则表达式，它们包括文本编辑软件、脚本、编程语言。下面列出相关应用者对正则表达式的支持度： 软件/语言 . [ ] ^ $ \\( \\) \\{ \\} ? + | ( ) vi √ √ √ √ √ sed √ √ √ √ √ √ awk √ √ √ √ √ √ √ √ √ perl √ √ √ √ √ √ √ √ √ python √ √ √ √ √ √ √ √ √ √ javascript √ √ √ √ √ √ √ √ √ Visual C++ √ √ √ √ √ C# √ √ √ √ √ √ √ √ delphi √ √ √ √ √ √ √ √ √ java √ √ √ √ √ √ √ √ √ √ php √ √ √ √ √ 备注： 正则表达式的( )和{ }匹配字符，为何上表为何写成\\( \\)和\\{ \\}呢？那是因为相关软件所在工作环境影响，例如：在 shell 命令窗口执行时，大部分符号为 shell 的普通字符，所以只能反过来使用\\转义表示！同时，也不排除其它符号也是如此！正则表达式并不仅限于某一种语言/软件，在每种语言中会都有细微的差别。 2、应用实例 网上早已收集一些常用正则表达式，这就无需我们重复编写了，劳烦你动一下左手的两根手指Ctrl+C和Ctrl+V。^0^ 。 一、校验数字的表达式 数字：^[0-9]*$ n位的数字：^\\d{n}$ 至少n位的数字：^\\d{n,}$ m-n位的数字：^\\d{m,n}$ 零和非零开头的数字：^(0|[1-9][0-9]*)$ 非零开头的最多带两位小数的数字：^([1-9][0-9]*)+(\\.[0-9]{1,2})?$ 带1-2位小数的正数或负数：^(\\-)?\\d+(\\.\\d{1,2})$ 正数、负数、和小数：^(\\-|\\+)?\\d+(\\.\\d+)?$ 有两位小数的正实数：^[0-9]+(\\.[0-9]{2})?$ 有1~3位小数的正实数：^[0-9]+(\\.[0-9]{1,3})?$ 非零的正整数：^[1-9]\\d*$ 或 ^([1-9][0-9]*){1,3}$ 或 ^\\+?[1-9][0-9]*$ 非零的负整数：^\\-[1-9][]0-9”*$ 或 ^-[1-9]\\d*$ 非负整数：^\\d+$ 或 ^[1-9]\\d*|0$ 非正整数：^-[1-9]\\d*|0$ 或 ^((-\\d+)|(0+))$ 非负浮点数：^\\d+(\\.\\d+)?$ 或 ^[1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*|0?\\.0+|0$ 非正浮点数：^((-\\d+(\\.\\d+)?)|(0+(\\.0+)?))$ 或 ^(-([1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*))|0?\\.0+|0$ 正浮点数：^[1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*$ 或 ^(([0-9]+\\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\\.[0-9]+)|([0-9]*[1-9][0-9]*))$ 负浮点数：^-([1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*)$ 或 ^(-(([0-9]+\\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\\.[0-9]+)|([0-9]*[1-9][0-9]*)))$ 浮点数：^(-?\\d+)(\\.\\d+)?$ 或 ^-?([1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*|0?\\.0+|0)$ 二、校验字符的表达式 汉字：^[\\u4e00-\\u9fa5]{0,}$ 英文和数字：^[A-Za-z0-9]+$ 或 ^[A-Za-z0-9]{4,40}$ 长度为3-20的所有字符：^.{3,20}$ 由26个英文字母组成的字符串：^[A-Za-z]+$ 由26个大写英文字母组成的字符串：^[A-Z]+$ 由26个小写英文字母组成的字符串：^[a-z]+$ 由数字和26个英文字母组成的字符串：^[A-Za-z0-9]+$ 由数字、26个英文字母或者下划线组成的字符串：^\\w+$ 或 ^\\w{3,20}$ 中文、英文、数字包括下划线：^[\\u4E00-\\u9FA5A-Za-z0-9_]+$ 中文、英文、数字但不包括下划线等符号：^[\\u4E00-\\u9FA5A-Za-z0-9]+$ 或 ^[\\u4E00-\\u9FA5A-Za-z0-9]{2,20}$ 可以输入含有^%\u0026',;=?$\\“等字符：[^%\u0026',;=?$\\x22]+ 禁止输入含有~的字符：[^~]+ 三、特殊需求表达式 Email地址：^\\w+([-+.]\\w+)*@\\w+([-.]\\w+)*\\.\\w+([-.]\\w+)*$ 域名：[a-zA-Z0-9][-a-zA-Z0-9]{0,62}(\\.[a-zA-Z0-9][-a-zA-Z0-9]{0,62})+\\.? InternetURL：[a-zA-z]+://[^\\s]* 或 ^http://([\\w-]+\\.)+[\\w-]+(/[\\w-./?%\u0026=]*)?$ 手机号码：^(13[0-9]|14[01456879]|15[0-35-9]|16[2567]|17[0-8]|18[0-9]|19[0-35-9])\\d{8}$ 电话号码(“XXX-XXXXXXX”、“XXXX-XXXXXXXX”、“XXX-XXXXXXX”、“XXX-XXXXXXXX”、“XXXXXXX\"和\"XXXXXXXX)：^(\\(\\d{3,4}-)|\\d{3.4}-)?\\d{7,8}$ 国内电话号码(0511-4405222、021-87888822)：\\d{3}-\\d{8}|\\d{4}-\\d{7} 电话号码正则表达式（支持手机号码，3-4位区号，7-8位直播号码，1－4位分机号）: ((\\d{11})|^((\\d{7,8})|(\\d{4}|\\d{3})-(\\d{7,8})|(\\d{4}|\\d{3})-(\\d{7,8})-(\\d{4}|\\d{3}|\\d{2}|\\d{1})|(\\d{7,8})-(\\d{4}|\\d{3}|\\d{2}|\\d{1}))$) 身份证号(15位、18位数字)，最后一位是校验位，可能为数字或字符X：(^\\d{15}$)|(^\\d{18}$)|(^\\d{17}(\\d|X|x)$) 帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9_]{4,15}$ 密码(以字母开头，长度在6~18之间，只能包含字母、数字和下划线)：^[a-zA-Z]\\w{5,17}$ 强密码(必须包含大小写字母和数字的组合，不能使用特殊字符，长度在 8-10 之间)：^(?=.*\\d)(?=.*[a-z])(?=.*[A-Z])[a-zA-Z0-9]{8,10}$ 强密码(必须包含大小写字母和数字的组合，可以使用特殊字符，长度在8-10之间)：^(?=.*\\d)(?=.*[a-z])(?=.*[A-Z]).{8,10}$ 日期格式：^\\d{4}-\\d{1,2}-\\d{1,2} 一年的12个月(01～09和1～12)：^(0?[1-9]|1[0-2])$ 一个月的31天(01～09和1～31)：^((0?[1-9])|((1|2)[0-9])|30|31)$ 钱的输入格式： 有四种钱的表示形式我们可以接受:“10000.00” 和 “10,000.00”, 和没有 “分” 的 “10000” 和 “10,000”：^[1-9][0-9]*$ 这表示任意一个不以0开头的数字,但是,这也意味着一个字符\"0\"不通过,所以我们采用下面的形式：^(0|[1-9][0-9]*)$ 一个0或者一个不以0开头的数字.我们还可以允许开头有一个负号：^(0|-?[1-9][0-9]*)$ 这表示一个0或者一个可能为负的开头不为0的数字.让用户以0开头好了.把负号的也去掉,因为钱总不能是负的吧。下面我们要加的是说明可能的小数部分：^[0-9]+(.[0-9]+)?$ 必须说明的是,小数点后面至少应该有1位数,所以\"10.“是不通过的,但是 “10” 和 “10.2” 是通过的：^[0-9]+(.[0-9]{2})?$ 这样我们规定小数点后面必须有两位,如果你认为太苛刻了,可以这样：^[0-9]+(.[0-9]{1,2})?$ 这样就允许用户只写一位小数.下面我们该考虑数字中的逗号了,我们可以这样：^[0-9]{1,3}(,[0-9]{3})*(.[0-9]{1,2})?$ 1到3个数字,后面跟着任意个 逗号+3个数字,逗号成为可选,而不是必须：^([0-9]+|[0-9]{1,3}(,[0-9]{3})*)(.[0-9]{1,2})?$ 备注：这就是最终结果了,别忘了”+“可以用”*“替代如果你觉得空字符串也可以接受的话(奇怪,为什么?)最后,别忘了在用函数时去掉去掉那个反斜杠,一般的错误都在这里 xml文件：^([a-zA-Z]+-?)+[a-zA-Z0-9]+\\\\.[x|X][m|M][l|L]$ 中文字符的正则表达式：[\\u4e00-\\u9fa5] 双字节字符：[^\\x00-\\xff] (包括汉字在内，可以用来计算字符串的长度(一个双字节字符长度计2，ASCII字符计1)) 空白行的正则表达式：\\n\\s*\\r (可以用来删除空白行) HTML标记的正则表达式：\u003c(\\S*?)[^\u003e]*\u003e.*?|\u003c.*? /\u003e ( 首尾空白字符的正则表达式：^\\s*|\\s*$或(^\\s*)|(\\s*$) (可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等","date":"2022-05-27","objectID":"/20220527/:0:3","tags":["正则表达式"],"title":"正则表达式","uri":"/20220527/"},{"categories":["other"],"content":"无产权公寓值得购买吗","date":"2022-05-26","objectID":"/20220526/","tags":["其它"],"title":"无产权公寓","uri":"/20220526/"},{"categories":["other"],"content":"前言 今天走进了某公寓的售楼部（实质是公寓招商部），话说 38 万就可以购买一套 32 平米 40 年产权的公寓，相比均价 5 万上下一手楼楼价非常吸引人，让人有立刻购买的冲动。冲动是魔鬼，不想清楚就做一件事，很可能后悔一生。好在到了饭点时间，先去吃个饭，聊一聊天，看一看抖音。抖音真是好东西，搜索功能非常不错，可以让我们快速了解一些信息。原来公寓分为有产权和无产权，无产权租期一般 40 年以内，国家规定租赁合同最长 20 年，超过 20 年可能不受法律保护（例如：补充协议约定 20 年后承租人有权继续使用租赁物业）。此刻应该知道这公寓为什么这么便宜了吧！它其实就是长租给你，不是卖给你，没有房产证，签的是租赁合同！市面上还有很多房企“卖”公寓给你，再返租你的公寓，每月打钱给你。这种情况有可能是房企流动资金紧张，通过这种操作可以快速获得巨额资金，而你要等十来二十年才能拿回本钱…… ","date":"2022-05-26","objectID":"/20220526/:0:1","tags":["其它"],"title":"无产权公寓","uri":"/20220526/"},{"categories":["other"],"content":"无产权公寓值得购买吗？ 一、从我现有的条件和角度去分析： 1、产权问题：无产权证，不能买卖，转手麻烦……，无学位，无户口…… 2、合同问题：只有租赁合同，最长 20 年，20 年后不受律保护，风险大，继承复杂等等。 3、地段问题：本区不是商业区，偏向生活区，房子很多，拉下租金，目前评估只能是 1500 元左右，升值空间可能没想像那么好。 4、收益问题：假设 1500 元月租 30 年 7 成入住率，1500 * 12 * 30 = 378000 元，刚好回本，但 30 年后我已经六七十岁了，那时早已领养老金，孩子都已成年，此后的收益不是刚需！ 5、资金问题：由于无产权证，不能买卖，不能抵押，不能变现，无资金流动性。还不如买储蓄型保险，每年交几千元，到十来二十年可取出，期间还附带其它保险。 6、生活问题：由于商业性质，水电费、管理费贵，人员复杂，环境吵杂，没煤气，不利于长期居住。 7、风险问题：房企往往是为解决资金紧张才推出公寓“销售”，涉及一系列问题：是否有预售许可证、是否有销售备案证、是否存在抵押、是否被查封、是否一房多“售”等等。 二、那到底公寓适合什么人购买？ 1、特别有钱的人（专注投资人士） 2、没有房票的人（偏向单身人士） 3、买公寓的用途不是拿来居住的人（例如作为公司室） ","date":"2022-05-26","objectID":"/20220526/:0:2","tags":["其它"],"title":"无产权公寓","uri":"/20220526/"},{"categories":["hardware"],"content":"小电路的一些小知识介绍","date":"2022-05-18","objectID":"/20220518/","tags":["电路"],"title":"小电路多学问","uri":"/20220518/"},{"categories":["hardware"],"content":"前言 一些小电路对于硬件工程师来说实在太简单了，闭着眼睛都可以把它画出来。正是因为简单而不过脑子，往往忽略了细节设计，造成一些隐患，严重时会烧坏电路！ ","date":"2022-05-18","objectID":"/20220518/:0:1","tags":["电路"],"title":"小电路多学问","uri":"/20220518/"},{"categories":["hardware"],"content":"电路 1、常用电路保护元件 ESD 二极管：静电放电、电压箝位、寄生电容很低、保护响应很快、超低漏电流、偏向信号接口保护，常用室内的板级接口。 TSS 二极管：防雷放电、电压开关、寄生电容稍低、保护响应较快、少许漏电流、偏向信号接口保护，常用户外设备级接口。 TVS 二极管：防雷抑制、电压箝位、寄生电容稍高、保护响应极快、少许漏电流、偏向电源接口保护，常用户外设备级接口。 更多，待续…… 2、IO 口外接信号输入 主要包括：减小信号抖动及高频信号干扰，提供确定的默认电平信号，保护 IO 口。 R1 上拉电阻： 上拉电阻的作用为了使信号有一个确定的默认高电平信号（如果需要低平，则改为下拉电阻）。当外部没有接线或外设重新上电时能确保有一默认的确定信号，防止不确定信号产生误动作。上拉电阻大小一般为 10K 或 20K 不等，根据实际应用场景决定。如果处理器内部有上拉电阻，则外部上拉电阻可以省去。 R2 限流电阻： 保护 IO 口，防止过流烧坏 IO 口（特别热拔热插时对 IO 保护尤其重要，例如在某宝购买的 D 版 jlink 烧录器，经常会烧坏，就是因为 IO 口没加限流电阻【备注：加入限流电阻会对速度有少许影响】），对静电或者一些高压脉冲有吸收作用。限流电阻大小一般为 100Ω 或 200Ω 不等，其取值与上下拉电阻及对地电容有关，否则影响输入信号的大小及速度。 C1 滤波电容： 减小信号抖动及高频信号干扰。滤波电容大小要根据实际应用选择，其取值与上下拉电阻和限流电阻有关，会影响输入信号的响应速度。例如外接一个自锁开关，则可以选择 0.1uF 较大容量的电容。 D1 ESD二极管： 静电保护二极管，防止静电干扰或者过压损坏 IO 口。根据 PCB 的成本及防护级别要求来决定添加与否，如果接口是给第三方设备连接，过压保护是必须的。 3、NPN 有源蜂鸣器驱动电路 主要包括：十足驱动、可靠关断、消除 EMI 辐射、保护驱动三极管。 R1 限流电阻： 保护 IO 口及防止流过基极电流过大损坏三极管，限流降低功耗（因为控制开关三极管，无需大电流控制）。 R2 下拉电阻： 为三极管基极下拉电阻，当 R1 端没输入信号时为三极管提供可靠的关断控制，同时提升 R1 端高电平的门槛电压，防止 R1 端输入信号不足或其受干扰导致三极管进入不期望的放大状态（蜂鸣器轻微发声或乱发声）。 C1 控制滤波电容： C1 可以在有强干扰环境下，有效的滤除干扰信号，避免蜂鸣器变音和意外发声。 C3 电源滤波电容： C3 是电源滤波电容，滤除电源高频杂波，同时减轻对电路板电源影响。 C2 EMC滤波电容： 因为有源蜂鸣器本身是一个振荡电路，会产生 EMC 辐射（频率一般为 1~2KHz，上图右边小图）。由于脉冲信号能量不是很强，增加 C2 滤波电容将脉冲信号滤除（一般使用 0.1uF 电容），同时也可过滤掉关断时的正向尖峰脉冲（≥10V），不过会对开关控制产生轻微的响应延时。 4、NPN 无源蜂鸣器驱动电路 主要包括：十足驱动、可靠关断、消除 EMI 辐射、保护驱动三极管。 无源蜂鸣器本质上是一个感性元件，开关控制时在蜂鸣器两端会有较强反向感应电动势，产生几十伏的尖峰电压，可能损坏驱动三极管，要使用耐压值较大和响应频率较高的二极管释放尖峰电压，常用 IN4148 的开关二极管。其它电路的作用与有源蜂鸣器一样，这里不重复赘述。为了电路的兼容性和可扩展性，建议无论是有源还是无源蜂鸣器，统一使用无源蜂鸣器驱动电路。 5、NPN 继电器驱动电路 待续…… 6、485 总线接口EMC电路 待续…… ","date":"2022-05-18","objectID":"/20220518/:0:2","tags":["电路"],"title":"小电路多学问","uri":"/20220518/"},{"categories":["other"],"content":"竞业限制协议的简单介绍","date":"2022-05-17","objectID":"/20220517/","tags":["其它"],"title":"竞业限制协议","uri":"/20220517/"},{"categories":["other"],"content":"前言 大公司的管理人员、高级技术人员，往往需要签竞业限制协议。什么是竞业限制协议，它与保密协议有什么不同？ ","date":"2022-05-17","objectID":"/20220517/:0:1","tags":["其它"],"title":"竞业限制协议","uri":"/20220517/"},{"categories":["other"],"content":"竞业限制协议 竞业限制协议：是指用人单位与劳动者可以在劳动合同中约定保守用人单位的商业秘密和与知识产权相关的保密事项，并约定在解除或者终止劳动合同后一定期限内，劳动者不得到与本单位生产或者经营同类产品、从事同类业务的有竞争关系的其他用人单位任职，或者自己开业生产或者经营同类产品的书面协议。对负有保密义务的劳动者，用人单位与劳动者在解除或者终止劳动合同后，在竞业限制期限内（不得超过二年）按月给予劳动者经济补偿。同样劳动者违反竞业限制约定的，应当按照约定向用人单位支付违约金。 竞业协议限制的义务主体只能是用人单位的高级管理人员、高级技术人员和其他负有保密义务的人员，用人单位不得与上述人员以外的其他劳动者约定竞业限制，否则该约定就是无效的。 竞业协议限制的范围、地域、期限由用人单位与劳动者约定，竞业限制的约定不得违反法律、法规的规定。它所限制的是劳动者的自由择业权。 保密协议和竞业限制协议有如下区别：（1）保密义务一般是法律的直接规定或劳动合同的随附义务，不管用人单位与劳动者是否签订保密协议，劳动者均有义务保守商业秘密。而竞业限制是基于用人单位与劳动者的约定产生，没有约定的，无须承担竞业限制义务。（2）保密义务要求保密者不得泄露商业秘密，侧重的不能“说”，竞业限制义务要求劳动者不能到竞争单位任职或自营竞争业务，侧重的是不能“做”。（3）保密义务劳动者承担的义务仅限于保密，并不限制劳动者的就业权，而竞业限制义务不仅仅限制劳动者泄密，还限制劳动者的就业，劳动者的负担重很多。（4）保密义务一般期限较长，只要商业秘密存在，劳动者的保密义务就存在，而竞业限制期限较短，最长不超过二年。 ","date":"2022-05-17","objectID":"/20220517/:0:2","tags":["其它"],"title":"竞业限制协议","uri":"/20220517/"},{"categories":["other"],"content":"刷抖音刷出了继承法","date":"2022-05-02","objectID":"/20220502/","tags":["其它"],"title":"人生无常之继承法","uri":"/20220502/"},{"categories":["other"],"content":"前言 前段时间刷抖音刷出了一则新闻：话说北京一名 38 岁的独身男子去世，留下一套总价 115 万没还完贷款的商品房，舅舅想继承房产遭拒，法院判决民政局成为遗产的管理人。初时我还不明白为什么会这样，后来看了评论才知道我不了解继承法。这位男子挺可怜的，父母双亡、未婚、无子女，没有兄弟姐妹、祖父母、外祖父母，而舅舅不在继承法人范围内，他也没有立遗嘱，所以才有这样的结果。我为这位 38 岁的男子去世感到惋惜，也为这位舅舅没能继承亲人遗产感到可惜。这件事告诉我们学习多点知识总是没错的，平常不一定用上，但关键时刻可能帮上你一个大忙！ ","date":"2022-05-02","objectID":"/20220502/:0:1","tags":["其它"],"title":"人生无常之继承法","uri":"/20220502/"},{"categories":["other"],"content":"继承法 法律对于继承人顺序和范围有明确规定：第一顺序是配偶、子女、父母，第二顺序是兄弟姐妹、祖父母、外祖父母。除此之外的其他亲戚是没有继承权的（除非立遗嘱），至于最终谁是担任遗产管理人已不是重点，关键要记住继承人顺序和范围！ ","date":"2022-05-02","objectID":"/20220502/:0:2","tags":["其它"],"title":"人生无常之继承法","uri":"/20220502/"},{"categories":["software"],"content":"介绍 MinGW-w64 编译套件(GNU 工具集) 的安装与使用","date":"2022-04-28","objectID":"/20220428/","tags":["MinGW","GNU","GCC","编译"],"title":"MinGW-w64 编译套件(GNU 工具集)","uri":"/20220428/"},{"categories":["software"],"content":"前言 MinGW/MinGW-w64（Minimalist GNU for Windows）是为 windows 系统打造的编译器套件，其主要是把 GNU 的 gcc、make 等编译工具移植到 Windows 平台下，并且包含了 Win32API ，使得原是在 linux 写的 C 源代码可以在 Windows 上编译及运行（exe 执行文件）。MinGW-w64 使用 Windows 的 C 语言运行库，因此编译出的程序不需要第三方 DLL，可以直接在 Windows 下运行。MinGW-w64 与 MinGW 的区别在于 MinGW 只能编译生成 32 位可执行程序，而 MinGW-w64 则可以编译生成 64 位或 32 位可执行程序。因此 MinGW 现已被 MinGW-w64 所取代，并且 MinGW 也早已停止了更新。更多的编译构建工具知识，请移步《linux-编译-linux 编译构建工具》。 ","date":"2022-04-28","objectID":"/20220428/:0:1","tags":["MinGW","GNU","GCC","编译"],"title":"MinGW-w64 编译套件(GNU 工具集)","uri":"/20220428/"},{"categories":["software"],"content":"安装 1、MinGW-w64 的下载 一、版本说明 对于 MinGW-w64 的安装方式，分为在线安装和离线安装，但无论哪种安装方式，必须事先要理清软件不同类型的版本！关于 MinGW-w64 版本，打开【官方下载网页】，发现有很多类型版本，那是因为 MinGW-w64 是一个编译软件，涉及其本身是 32 位还是 64 位软件，还涉及其编译生成的应用软件是 32 位还是 64 位软件，以及用户目标程序使用哪种的线程模型来编写等等。所以我们需要根据自己实现情况选择对应版本，一般而言选择 x86_64-posix-sjlj 即可，关于 MinGW-w64 版本详细说明如下： 版本 适用范围 ● 软件在线安装 1、MinGW-W64-install.exe 在线安装器（安装过程选择类型版本） ● 操作系统位数 1、x86_64 MinGW-W64 为 64 位 Windwos 软件 2、i686 MinGW-W64 为 32 位 Windwos 软件 ● 使用线程模型 1、posix 用于应用软件跨平台编译，但性能会下降 2、win32 专用于 Windows 系统软件编译 ● 异常处理系统 1、sjlj 有性能损失，适合 32/64 位程序编译 2、seh 无性能损失，只适合纯 64 位程序编译 3、dwarf 无性能损失，只适合纯 32 位程序编译 二、下载说明 MinGW-w64 分为在线安装和离线安装，根据个人喜好选择对应版本下载即可。由于官方将下载托管到 SourceForge 上，所以你可以从【官网】链接到下载页面下载，也可直接打开 SourceForge【下载页面】下载。 2、MinGW-w64 的安装 一、在线安装 其实在线安装与离线安装无本质区别，在线安装程序（mingw-w64-install.exe）其实就是将【离线软件包】下载到【指定的目录下】而已，完成后还是需要手工将软件路径加入系统环境变量中。不建议在线安装，因为本人尝试了 N 次在线安装程序都没能成功下载【离线软件包】！下图为在线安装流程： ● 说明一：Version 指的是 gcc 的版本，如果没有特殊的需求，一般选择最高的版本号即可。 ● 说明二：Architecture 是指电脑系统是 32位 还是 64位，根据你的电脑系统做出对应选择。 ● 说明三：对于电脑只有两种操作系统，符合 posix 线程模型的 linux 等系统和 Windows 系统。开发 Windows 程序，则选择 win32 ；而开发 Linux、Unix、Mac OS 程序，则选择 posix 。 ● 说明四：异常处理在开发中非常重要，你在开发的过程中，大部分的时间会耗在处理各种异常情况上。如果你之前选择了 64 位，则这里有两个异常处理模型供你选择，seh 是新发明的，而 sjlj 则是古老的。seh 性能比较好，但不支持 32 位。 sjlj 稳定性好，而且支持 32位。 ● 说明五：关于将软件路径加入系统环境变量请查看下节离线安装说明。 二、离线安装 1、到官网打开页面下载离线包： 2、离线包解压到自定义目录下： 3、gcc 编译器工具所在的路径： 4、将路径添加到系统环境变量： 加入系统环境变量后，打开命令窗口，无论在何路径下，直接输入gcc命令即可使用 gcc 编译程序了。 ","date":"2022-04-28","objectID":"/20220428/:0:2","tags":["MinGW","GNU","GCC","编译"],"title":"MinGW-w64 编译套件(GNU 工具集)","uri":"/20220428/"},{"categories":["software"],"content":"使用 1、在命令窗口输入gcc -v可查看 gcc 版本。 2、查看 make 版本的命令为mingw32-make -v！ 3、Windows下使用MakeFile(Mingw)文件 待续…… ","date":"2022-04-28","objectID":"/20220428/:0:3","tags":["MinGW","GNU","GCC","编译"],"title":"MinGW-w64 编译套件(GNU 工具集)","uri":"/20220428/"},{"categories":["MCU"],"content":"Keil 4 与 Keil 5 的兼容性问题","date":"2022-03-27","objectID":"/20220327/","tags":["Keil MDK"],"title":"Keil 4 与 Keil 5 的兼容性","uri":"/20220327/"},{"categories":["MCU"],"content":"前言 2013 年 10 月，Keil 公司（被 ARM 公司收购）正式发布 Keil uVision5 IDE，相比 Keil 4 最大的区别是其增加了 Software Packs，可以独立于工具链进行添加更新芯片支持库和软件中间库，并且 SWD 下载速度提升到了 50M。由于 Keil 5 内部架构升级还是比较大，与 Keil 4 存在一些兼容问题，需要我们来解决。补充：Keil 软件资源下载请移步到《安富莱电子》，J-Link 驱动请移步 《segger 官网下载》。 ","date":"2022-03-27","objectID":"/20220327/:0:1","tags":["Keil MDK"],"title":"Keil 4 与 Keil 5 的兼容性","uri":"/20220327/"},{"categories":["MCU"],"content":"方法 1、Keil 4, Keil 5 共存安装 因为使用 Keil 4 开发已经很长一段时间了，很多工程是 Keil 4 工程格式，暂不想将它们改为 Keil 5 工程格式，怕编译器更改影响编译的目标文件，引发原程序新 BUG 的产生，最好的方法是在同一系统环境里同时安装 Keil 4 和 Keil 5。但由于软件认为是版本的升级，不允许两版本软件共存，需要我们作出特别处理。不过本人更推荐安装：官方专用的 keil 5 兼容 keil 4 工程补丁（MDKCM 525.EXE - 安富莱电子提供下载）。 1、要先安装 Keil 4，再安装 Keil 5，还要求安装到不同目录： 1.2、按win+r键运行，输入regedit打开注册表： 1.3、修改 Keil 4 版本的 exe 启动路径： 1.4、修改 Keil 5 版本的 exe 启动路径： 1.5、之后打开 Keil 4 和 Keil 5 工程就互不干扰了。 2、Keil 4 打开源文件卡死 之前用高版本的 Keil 5 打开过工程（没更改工程扩展名），现在用低版本的 Keil 4 打开就会出现：打开源文件直接跳至最后一行卡死。解决方法：打开工程关闭所有窗口文件，然后全部保存，关闭 Keil，再次打开就可以了。还有一方法：直接删除 .uvopt、.uvopt.bak、.uvproj.bak 文件（但可能会影响某些工程配置）。 3、Keil 4 打开 Keil 5 工程 某些情况下需要使用 Keil 4 打开 Keil 5 工程（例如：还没安装 Keil 5），而软件一般是高版本向低版本兼容，低版本不能打开高版本。对于没有使用 Software Packs 的 Keil 5 工程只需要修改里面几项内容后，即可使用 Keil 4 打开。 3.1、复制两个工程文件，并更改扩展名： 3.2、修改工程项目文件里面内容： 3.3、最后即可打开上图的project.uvproj工程并使用。 补充：但某些情况下可能出现编译“Error: XXXXXX: type of input file ‘xxxxxx’ unknown”错误时，需要手工对每个包含路径更新一遍： 4、Keil 5 死锁 J-Link 解决 我的 J-Link 比较旧：固件 V7 版，驱动为 V4.98；安装的 Keil 5 为 V5.33 版。在 Keil 5 中使用 J-Link 调试，会强制要求升级 J-Link 固件，不升级不能用，升级又被死锁。于是从网上搜索一些解决方案，得到两条重要信息：1、Keil V5.23 以及之前版本不检测 J-Link D版；2、使用 J-Link 驱动的 JLinkARM.dll 替换 Keil 5 后就不会提示升级固件（也有网文提到包括 JLink.exe）。有了这两条信息，就有了解决方案： 4.1、Keil V5.14 取代 Keil V5.33 的 Segger 文件夹： 4.2、J-Link V4.98 替换 Keil V5.33 的 JLinkARM.dll 文件： 4.3、成功解决强制升级及死锁问题： ","date":"2022-03-27","objectID":"/20220327/:0:2","tags":["Keil MDK"],"title":"Keil 4 与 Keil 5 的兼容性","uri":"/20220327/"},{"categories":["blog","linux"],"content":"网站 PPT 生成工具 Slidev 介绍","date":"2022-03-16","objectID":"/20220316/","tags":["Slidev","linux 工具/应用"],"title":"网站 PPT 生成工具 Slidev","uri":"/20220316/"},{"categories":["blog","linux"],"content":"Slidev 的简介 Slidev /slʌɪdɪv/ 基于 Node.js、Vue.js 开发，利用它我们可以使用 Markdown 及扩展语法编写 PPT，它支持各种好看的主题、代码高亮、公式、流程图、自定义的网页交互组件，还可以方便地导出成 pdf 或者直接部署成一个静态网站（纯静态的 HTML、JavaScript 文件）。前提需要安装 Node.js 的版本 \u003e=14.0.0（注：Node.js 都会默认安装 npm，具体请参考笔记《网站 node 包管理器 npm》） 官网：Slidev、GitHub ","date":"2022-03-16","objectID":"/20220316/:0:1","tags":["Slidev","linux 工具/应用"],"title":"网站 PPT 生成工具 Slidev","uri":"/20220316/"},{"categories":["blog","linux"],"content":"Ubuntu 平台 1、Slidev 的安装与使用 1、项目创建 npm init slidev@latest #创建PPT项目，根据向导进行操作： #1、输入项目名称（文件夹名称，例如输入：myppt） #2、询问是否启动服务（输入：y） #3、选择资源服务器（选择：npm） #4、之后自动拉取资源包，最后自动启动本地演示服务 #5、根据提示在浏览器输入网址浏览PPT网站：http://localhost:3030 #6、如果想退出服务按`Ctrl + C`组合键退出 2、全局安装 npm i -g @slidev/cli #安装 slidev 工具（方便以后操作） slidev -v #查看版本（用于验证是否安装成功） ####命令基本使用#### cd myppt #进入之前创建的项目文件夹 slidev #启动本地演示服务（浏览网址：http://localhost:3030，按`Ctrl + C`组合键退出） slidev build #构建静态网站网页（存到 dist 文件夹，并且手工把 index.html 网页内容的 href=\"/assets/ 改为 href=\"/网站相对路径/assets/ 相对路径） slidev build --base aaa #同上，并指定网站相对路径，无须手工改 index.html（例如主页为 https://o2ospring.github.io 则网站相对路径 https://o2ospring.github.io/aaa） slidev export #构建PPT为PDF文件（测试不成功，以后再补充！！！！） #构建PPT事前需要安装依赖包：npm i -D playwright-chromium 2、PPT 内容编写及语法 PPT 浏览快捷键 ● 这里提前介绍一下我们浏览已构建好 PPT 网页的基本操作快捷键（下表），如果要更多操作可以把鼠标移到网页左下角即可调出导航菜单。 快捷键 动作 ← 前一步显示 → 或 空格 后一步显示 ↑ 前一页显示 ↓ 后一页显示 f 全屏进入/退出 o 总览进入/退出 d 亮/暗模式切换 PPT 整体内容编写 ● 在根目录下的slides.md文件里编写整个 PPT 文档，使用标准的 Markdown 语法编写即可，也可以使用扩展语法来丰富 PPT 内容及样式。首页开头有两个---包含相关配置信息（例如：使用哪个主题等）。页与页之间使用一个---作为分隔，也可以像首页一样使用两个---包含自己专用配置信息（例如：修改此页布局为左右分割） --- # 主题方案选择（默认：'default'，更多：https://cn.sli.dev/themes/gallery.html） theme: 'default' # 配色方案选择（自动：'auto'，明亮：'light'，暗黑：'dark'） colorSchema: 'auto' # 幻灯片长宽比（默认：'16/9'） aspectRatio: '16/9' # 幻灯片的宽度（默认：空白，单位为 px） canvasWidth: 980 # 幻灯片总标题（默认：空白-\u003e首页标题，否则这里指定总标题） title: '' # 总标题的后缀（默认：'%s'，加入后缀如：'%s-我的PPT'） titleTemplate: '%s - Slidev' # 幻灯片的信息（点击左下角导航栏中感叹号查看），可以使用 markdown 语法来书写 info: | ## 关于本 PPT 这是我的第一个 PPT 演示，请关注我博客 [o2ospring's blog](https://o2ospring.github.io)! # 语法高亮设置（目前可选 'prism' 或 'shiki' 方案） highlighter: 'prism' # 显示代码行号（显示行号：true，不显示行号：false） lineNumbers: false # 启用 monaco 编辑器，默认情况下仅在开发者（dev）模式中启用 #monaco: 'dev' # 在单页（SPA）构建中启用 pdf 下载，也可以指定一个自定义 url #download: true # vue-router 模式，可以使用 'history' 或 'hash' 模式 #routerMode: 'history' # 字体将从 Google 字体自动导入 # 了解更多：https://sli.dev/custom/fonts #fonts: # sans: 'Roboto' # serif: 'Roboto Slab' # mono: 'Fira Code' # 为所有幻灯片添加默认的 frontmatter #defaults: # layout: 'default' # random image from a curated Unsplash collection by Anthony # like them? see https://unsplash.com/collections/94734566/slidev background: https://source.unsplash.com/collection/94734566/1920x1080 # apply any windi css classes to the current slide class: 'text-center' # persist drawings in exports and build drawings: persist: false --- # 这是第一页标题 本行内容为首页内容（一般是幻灯片主题）.... \u003c!-- 扩展文字按钮，一般用于在首页点击进入下一页 --\u003e \u003cdiv class=\"pt-12\"\u003e \u003cspan @click=\"$slidev.nav.next\" class=\"px-2 py-1 rounded cursor-pointer\" hover=\"bg-white bg-opacity-10\"\u003e 点击进入下一页 \u003ccarbon:arrow-right class=\"inline\"/\u003e \u003c/span\u003e \u003c/div\u003e \u003c!-- 专门做的 github 链接小图标（在页面右下角） --\u003e \u003cdiv class=\"abs-br m-6 flex gap-2\"\u003e \u003ca href=\"https://github.com/o2ospring\" target=\"_blank\" alt=\"GitHub\" class=\"text-xl icon-btn opacity-50 !border-none !hover:text-white\"\u003e \u003ccarbon-logo-github /\u003e \u003c/a\u003e \u003c/div\u003e \u003c!-- 在页尾注释的文字是备注，不是注释！ --\u003e --- # 这是第二页标题 这是普通文本内容 * 这是无序列表 1. 这是有序列表 修改单页的布局 ● 页面布局一般有两种：一整页、左右分割两部分。 \u003c!-- 左右分割布局格式，如下 --\u003e --- layout: two-cols --- \u003ctemplate v-slot:default\u003e # 左半页标题 这是左半页内容 ![插入图片1](https://o2ospring.github.io/android-chrome-192x192.png) \u003c/template\u003e \u003ctemplate v-slot:right\u003e # 右半页标题 这是右半页内容 ![插入图片2](https://o2ospring.github.io/about/o2ospring_blog.png) \u003c/template\u003e 代码块及扩展 ● 除了能对代码进行配色，还可以支持高亮动画显示。 \u003c!-- 代码块及扩展，其中{all|2|1-3|all}为扩展语法，表示分四步高亮显示：全部、第2行、第1-3行、全部代码，如下 --\u003e `` `json {all|2|1-3|all} {\"menu\": { \"id\": \"file\", \"value\": \"File\", \"popup\": { \"menuitem\": [ {\"value\": \"New\", \"onclick\": \"CreateNewDoc()\"}, {\"value\": \"Open\", \"onclick\": \"OpenDoc()\"}, {\"value\": \"Close\", \"onclick\": \"CloseDoc()\"} ] } }} `` ` 显示动画语法 ● 显示主要包括显示顺序、显示动画。关于几个不同的显示顺序语法，不建议同一页面使用多个不同语法，否则显示顺序可能错乱！ \u003c!-- 针对行内容的显示顺序，如下 --\u003e \u003cdiv v-click=\"3\"\u003e111 此行内容最后显示\u003c/div\u003e \u003cdiv v-click=\"2\"\u003e222 此行内容次之显示\u003c/div\u003e \u003cdiv v-click=\"2\"\u003e222 此行内容次之显示\u003c/div\u003e \u003cdiv v-click=\"1\"\u003e333 此行内容最先显示\u003c/div\u003e \u003c!-- 针对列表项的显示顺序，如下 --\u003e \u003cv-clicks\u003e - 无序列表内容一；//点一步显示下一项列表（注意：列表动画扩展语法需要空行隔开↑） - 无序列表内容二。//点一步显示下一项列表（注意：列表动画扩展语法需要空行隔开↓） \u003c/v-clicks\u003e 插入图标或图片 ● 你可以通过 Icônes 来浏览访问所有可用的图标，每个图标都有自己的标识符。例如：小火箭的标识符为uim-rocke","date":"2022-03-16","objectID":"/20220316/:0:2","tags":["Slidev","linux 工具/应用"],"title":"网站 PPT 生成工具 Slidev","uri":"/20220316/"},{"categories":["MCU"],"content":"ACM32F403RE 国产 MCU 试用笔记","date":"2022-03-15","objectID":"/20220315/","tags":["ARM Cortex-M"],"title":"ACM32F403RE 国产 MCU 试用笔记","uri":"/20220315/"},{"categories":["MCU"],"content":"前言 现在很多公司要求应用芯片国产化，于是找来一家国产单片机厂家（上海爱信诺航芯电子科技有限公司（简称：上海航芯）），有幸拿到厂家的一块 MCU 为 ACM32F403RET8 开发板（资料：开发工具/开发板/ACM32F403RET7_NUCLEO_V1.0），用于前期技术验证。目前只是简单试用了一下，没有深入研究，不过其驱动库比 STM32F 单片机简单很多，很容易上手。本文只是记录初次使用时遇到的一些问题，没详细介绍如何使用，关于具体使用方法可参考官方文档。ACM32F403RE 基于 ARMv8-M 架构，支持 Cortex-M33 和 Cortex-M4F 指令集，最高支持 180MHz 系统工作频率，支持浮点运算和 DSP。如此强劲的内核，当然不会“裸跑”，直接上 rt-thread 实时操作运行测试。 ","date":"2022-03-15","objectID":"/20220315/:0:1","tags":["ARM Cortex-M"],"title":"ACM32F403RE 国产 MCU 试用笔记","uri":"/20220315/"},{"categories":["MCU"],"content":"基于 rt-thread 的 acm32f4xx-nucleo 工程初次调试 1、安装 IDE 芯片支持包及下载工程 时间：2022-03-15 软件：Keil MDK V5.33 版本：rt-thread v4.1.0-beta 工程：rt-thread\\bsp\\acm32f4xx-nucleo 网址：开发工具/IDE支持包/Aisinochip.ACM32F4.Keil.pack、rt-thread（版本 v4.1.0-beta） 下载安装操作完成后，就可以打开软件工程了。还有一点必须注意：工程配置那里必须重新选择 MCU 型号！ 2、安装厂家调试器驱动不成功问题 时间：2022-03-15 系统：Windows 7 旗舰版 驱动：ACM32-在线编程器\\USB转SPI-I2C驱动\\AisinochipUSBDriver.exe 问题： 无法成功安装 AISINOCHIP CMSIS-DAP 调试器驱动： 解决： 1、首先安装 USB 转 SPI-I2C 驱动：ACM32-在线编程器\\USB转SPI-I2C驱动\\AisinochipUSBDriver.exe 2、再安装 AISINOCHIP CMSIS-DAP 调试器驱动： 3、编译工程提示有两个函数未定义 时间：2022-03-15 软件：Keil MDK V5.33 版本：rt-thread v4.1.0-beta 工程：rt-thread\\bsp\\acm32f4xx-nucleo 问题： 编译工程提示出错： .\\build\\keil\\ACM32F4XX.axf: Error: L6218E: Undefined symbol System_EnableIAccelerate (referred from system_acm32f4.o). .\\build\\keil\\ACM32F4XX.axf: Error: L6218E: Undefined symbol HAL_EFlash_Init_Para (referred from hal_eflash.o). 分析： 1、未定义System_EnableIAccelerate()函数，应该是缺少System_Accelerate.c文件； 2、未定义HAL_EFlash_Init_Para()函数，应该是缺少HAL_EFlash_EX.c文件； 3、实际上这两个源文件厂家提供的是没开源的.lib库文件，由于 rt-thread 仓库项目过滤规则.gitignore过滤了.lib文件，厂家应该没留意，造成没有推送这两个源文件到 github 远程仓库。 解决： 1、从官网下载演示源码 开发工具/SDK驱动库/Nucleo_ModulesDemo_Rev1.0.8 2、复制ModulesDemo_Rev1.0.8\\ModulesDemo\\Core_Drivers\\Device\\System_Accelerate.lib到rt-thread\\bsp\\acm32f4xx-nucleo\\libraries\\Device\\ 3、复制ModulesDemo_Rev1.0.8\\ModulesDemo\\Core_Drivers\\HAL_Driver\\Src\\HAL_EFlash_EX.lib到rt-thread\\bsp\\acm32f4xx-nucleo\\libraries\\HAL_Driver\\Src\\ 4、最后把它们加入项目工程： 4、单步运行与源文件代码对应不上 时间：2022-03-16 硬件：ACM32F403RET7_NUCLEO_V1.1 软件：Keil MDK V5.33 版本：rt-thread v4.1.0-beta 工程：rt-thread\\bsp\\acm32f4xx-nucleo 问题： 进入调试后，先全速再单步运行代码，发现执行与源文件代码对应不上，貌似执行的是另一源文件另一段代码。 原因： 因配置重新选择了另一款调试器，造成调试器相关配置重置。 解决： 1、如果使用 CMSIS-DAP 调试器，参考《开发工具/开发板/ACM32F4_FP4_F3系列芯片开发快速上手V0.4.pdf》里面的配置说明； 2、造成上述现象，是因为没勾选：Option for Target → Utilities →Update Target before Debugging选项： 5、操作系统调试串口不能输入命令 时间：2022-03-16 硬件：ACM32F403RET7_NUCLEO_V1.1 软件：Keil MDK V5.33 版本：rt-thread v4.1.0-beta 工程：rt-thread\\bsp\\acm32f4xx-nucleo 问题： rt-thread 系统调试口只能打印数据，不能输入命令。 原因： 由于厂家《ACM32F403RET7_NUCLEO_V1.1》开发板的 UART1（PA9、PA10）引脚连接了 ACL16（CMSIS-DAP）调试器芯片，硬件复用冲突。 解决： 到《rtconfig.h》修改配置，把调试口移到 UART2（PA2、PA3）即可： #define RT_CONSOLE_DEVICE_NAME \"uart2\" #define BSP_USING_UART2 #define BSP_UART2_RX_USING_DMA（如果屏蔽表示不开 DMA） #define BSP_UART2_TX_USING_DMA（如果屏蔽表示不开 DMA） 6、操作系统调试串口逻辑结构说明 //\u003crtconfig.h\u003e配置串行通讯总开关：（由用户配置） #define BSP_USING_UART2 #define BSP_UART2_RX_USING_DMA #define BSP_UART2_TX_USING_DMA ...... //\u003cboard.h\u003e定义串口的端口与引脚：（由用户配置） #if defined(BSP_USING_UART2) #define UART2_TX_PORT GPIOA #define UART2_RX_PORT GPIOA #define UART2_TX_PIN GPIO_PIN_2 #define UART2_RX_PIN GPIO_PIN_3 #if defined(BSP_UART2_RX_USING_DMA) #define UART2_RX_DMA_INSTANCE DMA_Channel0 #define UART2_RX_DMA_RCC BIT12 #define UART2_RX_DMA_IRQ DMA_IRQn ...... //\u003cuart_config.h\u003e串行对象初始值： #if defined(BSP_UART2_TX_USING_DMA) #if defined(BSP_UART2_RX_USING_DMA) #ifndef UART2_DMA_RX_CONFIG #define UART2_DMA_RX_CONFIG \\ { \\ .Instance = UART2_RX_DMA_INSTANCE, \\ .dma_rcc = UART2_RX_DMA_RCC, \\ .dma_irq = UART2_RX_DMA_IRQ, \\ .channel = UART2_RX_DMA_CHANNEL, \\ .request = UART2_RX_DMA_REQUEST, \\ } #endif /* UART2_DMA_RX_CONFIG */ #endif /* BSP_UART2_RX_USING_DMA */ ...... #ifndef UART2_CONFIG #define UART2_CONFIG \\ { \\ .name = \"uart2\", \\ .Instance = UART2, \\ .irq_type = UART2_IRQn, \\ .enable_id = EN_UART2, \\ .tx_port = UART2_TX_PORT, \\ .rx_port = UART2_RX_PORT, \\ .tx_pin = UART2_TX_PIN, \\ .rx_pin = UART2_RX_PIN, \\ } #endif /* UART2_CONFIG */ #endif /* BSP_USING_UART2 */ ...... //\u003cdrv_uart.c\u003e串行对象初始化： static struct acm32_uart_config uart_config[] = { #ifdef BSP_USING_UART1 UART1_CONFIG, #endif #ifdef BSP_USING_UART2 UART2_CONFIG, #endif ...... rt_err_t rt_hw_uart_init(void) { ...... for (int i = 0; i \u003c obj_num; i++) { uart_obj[i].config = \u0026uart_config[i]; ...... } ...... } ...... acm32_uart_ops = { _uart_configure, ... } uart_obj[i].serial.ops = \u0026acm32_uart_ops; rt_err_t rt_serial_init() { ... serial-\u003eops-\u003econfigure(serial, \u0026serial-\u003econfig) ...} _uart_configure( HAL_UART_Init( ...... 1、rt-thread","date":"2022-03-15","objectID":"/20220315/:0:2","tags":["ARM Cortex-M"],"title":"ACM32F403RE 国产 MCU 试用笔记","uri":"/20220315/"},{"categories":["software","linux"],"content":"简单介绍 cygwin 的安装及使用","date":"2022-02-27","objectID":"/20220227/","tags":["Cygwin","linux 工具/应用"],"title":"cygwin 之 unix 模拟环境","uri":"/20220227/"},{"categories":["software","linux"],"content":"前言 有时候想利用 linux 的资源开发 windows 软件，或者是利用 linux 的资源（工具）帮忙我们在 windows 系统上完成某项工作（尤其是使用 gnu 工具集在 windows 上进行嵌入式系统开发是非常有用的!）。使用 Cygwin 是非常好的选择，它由 cygnus solutions 公司开发的自由软件，其集成绝大部分的 linux 软件包，只需使用 Cygwin 安装程序（实则是资源管理器）安装（添加）对应软件包即可。 ","date":"2022-02-27","objectID":"/20220227/:0:1","tags":["Cygwin","linux 工具/应用"],"title":"cygwin 之 unix 模拟环境","uri":"/20220227/"},{"categories":["software","linux"],"content":"安装 1、到 Cygwin 官网下载： ● 软件简介： Cygwin 是一个在 windows 平台上运行的类 unix 模拟环境，是一个 windows 软件；在其编译及运行的软件也是.exe的 windows 软件，而非 linux 软件（例如：gcc是gcc.exe的 windows 软件!）；甚至对系统的操作也是对 windows 操作（例如：reboot命令，是重启 windwons 系统!）。简单说：包括 cygwin 以及在其里面运行的软件都是 windows 软件，它只是模拟在 linux 中运行。 ● 特别说明 ： 1、注意：Cygwin 环境中编译构建的软件在运行时必须依赖cygwin1.dll，如果制作独立软件建议用 MinGW-w64/TDM-GCC 工具链来编译构建软件； 2、关于：Cygwin 和 MinGW 都是为用户提供在 windows 操作系统使用 GNU 工具的方法，使得原是 linux 写的 c 源代码可以在 windows 上编译及运行（exe 执行文件）。Cygwin 大而全面，提供完整的类 Unix 环境；而 MinGW 小而高效，其主要是编译器，一般只支持编译使用 C/C++ 标准库的程序。 3、补充：UnxUtils 也是 Windows 下的 Unix Linux 工具集，其集成了 Unix 系统的很多命令，下载解压并把它 usr/local/wbin 文件夹的绝对路径加到 windows 环境变量即可使用。 ● 下载网址 ： Cygwin 官网下载：http://www.cygwin.com 2、点安装程序直接安装： 关于 Cygwin 安装程序（setup-x86_64.exe），更准确说是 Cygwin 软件资源管理器，其主要工作是安装/删除/升级相关软件包。例如：发现wget不存在，按照初次在线安装一样的流程安装，当到软件包安装界面时，选择full全列表并在搜索框输入wget选择对应软件包进行安装。 安装工作分两部分： 1、安装 Cygwin 程序（设置安装路径）； 2、下载+安装软件包（设置下载缓存路径）。 安装方式则分三种： 1、在线安装（实质就是 2 和 3）。 2、下载离线软件包， 3、安装离线软件包。 3、常用工具所需软件包： 下面列出一些常用的工具软件包，可以在软件包安装界面进行勾选安装。当需要安装很多软件包时，手工勾选显得繁琐且低效，这时我们可以使用apt-cyg命令工具来安装（后面章节会介绍这个命令安装及使用）。 软件/工具 所需软件包 常用 wget, curl, gawk, openssh, nc, bzip2, xz, tar, unzip, lua, dos2unix gcc gcc-core, gcc-g++, binutils, gdb, make, cmake, libgccpp1 待续… 待续…… ","date":"2022-02-27","objectID":"/20220227/:0:2","tags":["Cygwin","linux 工具/应用"],"title":"cygwin 之 unix 模拟环境","uri":"/20220227/"},{"categories":["software","linux"],"content":"使用 1、Cygwin 里查看系统信息： # 查看系统信息、软件包 cygcheck -h #帮助 cygcheck -s #查看系统信息(包括已装软件包等) cygcheck -l #列出[已装软件包]所有文件路径 cygcheck -c #列出[已装软件包]版本信息 cygcheck -c cygwin #查看[cygwin]版本信息 cygcheck -p vim #从[cygwin.com]网上查询[vim]软件包 cygcheck /bin/gcc #检查[gcc]可执行文件依赖于哪些库（相当于Linux下的ldd命令） 2、Cygwin 里安装 hugo 案例： Hugo 是一个博客生成工具，本节以安装 Hugo 作为示例，介绍 Cygwin 的基础操作（可同时打开《博客生成工具 Hugo》的『Hugo 的安装』章节对比一下两者的区别）。Hugo 官方为我们编译好各种平台二进制文件，安装时不需要安装任何依赖软件，直接下载使用即可。特别说明：我们要下载的 hugo 是 windows 版本，非 linux 版本，文件为hugo_0.92.2_Windows-64bit.zip。在 windows 的桌面双击Cygwin64 Terminal运行 Cygwin 的 unix 模拟环境的终端机，之后与 linux 环境下一样使用命令进行相关操作： wget https://github.com/gohugoio/hugo/releases/download/v0.92.2/hugo_0.92.2_Windows-64bit.zip #在命令窗口直接下载hugo(下载建议的extended版本) unzip -q hugo_0.92.2_Windows-64bit.zip #解压到当前文件夹 mv hugo.exe /usr/local/bin/ #将hugo移到本地应用程序目录 vi /etc/profile #编辑系统环境变量,在文件最后加入内容：export PATH=$PATH:/usr/local/bin (备注:实际是系统默认路径,可以不加) hugo version #查看版本,验证安装是否成功（建议重新打开 Cygwin 再运行命令查看） ","date":"2022-02-27","objectID":"/20220227/:0:3","tags":["Cygwin","linux 工具/应用"],"title":"cygwin 之 unix 模拟环境","uri":"/20220227/"},{"categories":["software","linux"],"content":"扩展 1、apt-cyg 工具安装以及使用： 用惯 Ubuntu 就知道，使用apt-get install/remove命令非常方便安装/卸载软件（常用于批量操作），那么 Cygwin 是否有类似命令？当然有的，那就是apt-cyg第三方工具，需要手工安装，以及事前须要安装依赖包：bash wget tar gawk bzip2 xz。其中 bash、tar、gawk 属于 Base 类，在安装最小系统时已包含；而 wget、bzip2、xz 属于 Archive 类，需要通过 Cygwin 安装程序先装上，确保后续运行 apt-cyg 不出错。 1.1、安装依赖包wget tar gawk bzip2： 这些依赖包的安装方法按照前面的【安装】章节操作即可，或者说在前面【安装】章节已把这些依赖软件包安装了。 1.2、下载 apt-cyg 并且添加到 Cygwin： 1.3、验证apt-cyg安装是否成功有效： apt-cyg install vim #在 Cygwin 中使用`apt-cyg`命令安装 vim，用于验证`apt-cyg`是否安装成功 #【补充一】可能用到的命令： apt-cyg --help #查看帮忙 apt-cyg mirror #查看镜像源地址 apt-cyg mirror http://mirrors.163.com/cygwin #设置(修改)镜像源地址 #【补充二】使用 apt-cyg 安装常用工具： apt-cyg install python python-crypto #安装python环境 apt-cyg install util-linux #安装util-linux包（包含more/col/whereis等命令）: apt-cyg install inetutils #安装telnet/ftp工具 apt-cyg install man cygwin-doc apt-cyg install vim screen wget subversion \\ openssh pwgen gzip bzip2 curl rsync \\ bash-completion lftp nc tree p7zip \\ connect-proxy util-linux bind-utils inetutils 2、windows 调用 Cygwin 工具： 其实 windows 的 cmd 命令窗口可以直接使用 Cygwin 相关软件包工具，方法很简单：只需把软件包所在路径加入系统环境变量里即可。这里不得不说一下 Windows 下的 Unix Linux 工具集 UnxUtils，其集成了 Unix 系统的很多命令，下载解压并把它 usr/local/wbin 文件夹的绝对路径加到 windows 环境变量即可使用。 2.1、添加 windows 系统环境变量： # 共加三个路径到 windows 环境变量， # D:\\cygwin64\\bin # D:\\cygwin64\\sbin # D:\\cygwin64\\usr\\local\\bin # 要求使用 ; 分隔各个变量，具体如下： ;D:\\cygwin64\\bin;D:\\cygwin64\\sbin;D:\\cygwin64\\usr\\local\\bin 2.2、验证 cmd 命令窗调用 linux 命令： ","date":"2022-02-27","objectID":"/20220227/:0:4","tags":["Cygwin","linux 工具/应用"],"title":"cygwin 之 unix 模拟环境","uri":"/20220227/"},{"categories":["blog","linux"],"content":"Hugo 应用笔记，记录使用 Hugo 搭建个人博客的过程","date":"2022-01-26","objectID":"/20220126/","tags":["hugo","LoveIt","linux 工具/应用"],"title":"博客生成工具 Hugo","uri":"/20220126/"},{"categories":["blog","linux"],"content":"Hugo 的简介 Hugo /'hjuːgəʊ/ 是一种用 Go 语言编写的静态网站生成器，旨在让网站创建再次变得简单有趣。其主要用于个人 Blog、项目文档、初创公司站点构建。Hugo 的特点：简单、易用、高效、易扩展、快速部署，其中最大的优点就是超级快！ 中文官网 英文官网 ","date":"2022-01-26","objectID":"/20220126/:0:1","tags":["hugo","LoveIt","linux 工具/应用"],"title":"博客生成工具 Hugo","uri":"/20220126/"},{"categories":["blog","linux"],"content":"Ubuntu 平台 1、Hugo 的安装 Hugo 官方为我们编译好各种平台二进制文件，安装时不需要安装任何依赖软件，直接下载使用即可。建议安装最新版本的 Hugo，因为你可以直接在官网下载最新主题，快速熟悉 Hugo 的基本使用（搭建本地的博客先能跑起来），之后再找一个中文主题，有中文说明，方便我们更深入了解 Hugo 使用与配置。 在您的电脑上安装Hugo执行文件，更详尽可参考 Hugo 官方的部署文档； 在您的电脑上安装Git执行文件，更详尽可参考 Git 官方的部署文档； Hugo全部版本下载 Hugo中文官方文档 Hugo英文官方文档 go全部版本下载 wget https://github.com/gohugoio/hugo/releases/download/v0.92.0/hugo_extended_0.92.0_Linux-64bit.tar.gz #在命令窗口直接下载hugo(下载建议的extended版本) tar -xzvf hugo_extended_0.92.0_Linux-64bit.tar.gz #解压到当前文件夹 sudo mv hugo /usr/local/bin/ #将hugo移到本地应用程序目录 sudo gedit /etc/profile #编辑系统环境变量,在文件最后加入内容：export PATH=$PATH:/usr/local/bin (备注:实际是系统默认路径,可以不加) source /etc/profile #使能系统环境变量。 hugo version #查看版本,验证安装是否成功 #不需要安装go,忽略下面两行内容 #sudo apt install golang-go #安装go #go version #查看版本,验证安装是否成功 2、Hugo 的使用 操作hugo命令时，必须在网站根目录里操作。在官网挑选一个最新主题（例如：casper 主题），确保与最新 Hugo 相匹配，避免因版本出现各种兼容问题。当使用官方最新主题搭建本地的博客能顺利跑起来后，再使用 中文主题-Maupassant 编译制作，因为其有中文说明而且超简洁，方便我们快速了解 Hugo 配置。 官方主题下载 中文官方文档 英文官方文档 中文主题-Maupassant → 基本使用（最简单最容易入门的一款主题） 中文主题-Bootstrap → 快速入门（可进一步了解使用 Hugo 建站） 中文主题-LoveIt → 基本概念（我选用的主题，外观-功能-性能综合不错） 中文主题-NexT → 优化 Hugo Next主题（另一款不错的主题） ########建网站######## hugo new site mysite #新建名为“mysite”的网站 cd mysite #进入网站“mysite”根目录 #下载官方(Casper)主题到./themes/，并且重命名为:casper git clone https://github.com/vjeantet/hugo-theme-casper.git themes/casper ########加博文######## hugo new post/first.md #新建一篇文章（实际目录在:./content/post/） #使用Markdown语法随便添加几行内容（用于展示） hugo server -t casper -D #指定主题“casper”编译并启动服务器（-t 因为配置文件没绑定主题,所以这里需要指定）（-D 表示草稿也编译） #根据提示用浏览器打开网址预览网站：http://localhost:1313/ 3、LoveIt 主题 第一步：先把(LoveIt)主题示范网站运行起来 #########建站######### hugo new site mywebsite #新建网站:“mywebsite” cd mywebsite #进入网站根目录 git init #初始化网站根仓库。把主题(LoveIt)(v0.2.10)添加到子仓库： git submodule add https://github.com/dillonzq/LoveIt.git themes/LoveIt #########配置########## #(1) #复制作者提供的示例：将 mywebsite/themes/LoveIt/exampleSite/ 里面的文件(夹)全复制到 mywebsite/ 根目录下 #(2) #删除编译异常文件夹：删 mywebsite/content/posts/theme-documentation-built-in-shortcodes 文件夹； #(3) #再执行下面相关指令： gedit ./config.toml #打开文件编辑，将里面的 themesDir = \"../..\" 修改为 themesDir = \"themes/\" #　以及 enableGitInfo = true 改为 enableGitInfo = false hugo server #编译并启动服务器（如果要在本地使能评论系统则修改代码和改用下行命令───────┐ #hugo serve -e production #编译并启动服务器←(先参考:https://lewky.cn/posts/hugo-4.html/)────┘） #########补充########## #取消多国语言只保留中文： #(1) #修改配置： gedit ./config.toml #打开文件编辑，将里面的 defaultContentLanguage = \"en\" 修改为 defaultContentLanguage = \"zh-cn\" #　以及屏蔽 [languages.en] 和 [languages.fr] 各约200行的非中文语言菜单配置 #(2) #屏蔽文件： #将 mywebsite/content 目录下所有文件名为 index.en.md 改为 #index.en.md （注：实际是要删除文件(夹)的，只因为目前还需要作为参考之用） #将 mywebsite/content 目录下所有文件名为 index.fr.md 改为 #index.fr.md （注：实际是要删除文件(夹)的，只因为目前还需要作为参考之用） #(3) #重新编译： hugo server #重新编译并启动服务器 #此时即可根据提示用浏览器打开网址预览网站：http://localhost:1313/ 第二步：在(LoveIt)主题示范网站加网页文章 添加博文： ########加博文######## mkdir content/posts/test #创建博文专题文件夹（必须含有主页《例如中文为:index.zh-cn.md》，否则不支持文章封面） hugo new content/posts/test/index.zh-cn.md #在网站根目录运行命令添加博文主页（主页文件名称须固定,不能其它，否则不支持文章封面） #也可不用建文件夹直接在 content/posts/ 目录下创建博文(如：xxxx.zh-cn.md 文件)，但不支持多语言及文章封面 #实际上直接创建md文件并编写即可，无须`hugo new`命令创建，文件头信息则要按标准写。 编写博文： 文章头部是博文相关参数及信息（具体参考 2 前置参数）； 后面是使用 Markdown 编写的博文。 示范博文如下： --- weight: 1 hiddenFromHomePage: false title: \"第一篇文章主题\" date: 2020-03-06T21:40:32+08:00 lastmod: 2020-03-06T21:40:32+08:00 draft: false author: \"文章作者\" authorLink: \"https://o2ospring.github.io\" description: \"文章封面描述\" resources: - name: \"文章封面名称\" src: \"featured-image.jpg\" tags: [\"文章标签/关键词-1\", \"文章标签/关键词-2\"] categories: [\"文章分类-1\", \"文章分类-2(可关联多个分类)\"] lightgallery: true toc: auto: false --- ### markdown 章节 1 * `weight`后面的编号表示专题主页在博客首页的排序编号 * `hiddenFromHomePage`如果设为`true`，这篇文章将不会显示到博客首页上 * `date`和`lastmod`为文章创建及修改时间 * `authorLink`文章作者主页链接 * `draft`表示草稿，发布文章必定是设置为`false` * `src`为主题主页封面图片，在自己文件夹下且名称为`featured-image.xxx`，可以是`jpg`、`png`等图片格式 * `lightgallery`如果设为`true`，点击文章中的图片将可以按照画廊形式呈现，前提：图片在自己专题文件夹里 ### markdown 章节 2 * markdown 选项 2-1 * markdown 选项 2-2 第三步：开启及绑定(Valine)评论系统 关于 Valine：是一款快速、简洁且高效的无后端评论系统（Valine 更多知识）。 到 Valine 注册并登录。具体请看【图示】 配置config.toml文件和 Valine 评论系统","date":"2022-01-26","objectID":"/20220126/:0:2","tags":["hugo","LoveIt","linux 工具/应用"],"title":"博客生成工具 Hugo","uri":"/20220126/"},{"categories":["blog","linux"],"content":"Hexo 应用笔记，记录使用 Hexo 搭建个人博客的过程","date":"2022-01-25","objectID":"/20220125/","tags":["Hexo","linux 工具/应用"],"title":"博客生成工具 Hexo","uri":"/20220125/"},{"categories":["blog","linux"],"content":"Hexo 的简介 Hexo /'heksoʊ/ 是一个基于 Node.js 的命令行工具。Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。前提需要安装 npm（注：Node.js 都会默认安装 npm，具体请参考笔记《网站 node 包管理器 npm》）注意：node.js(npm) 版本过低，Hexo 不支持（运行命令时提示各种错误），建议安装最新版本（例如：node-v17.5.0-linux-x64.tar.gz）！ 官网：Hexo ","date":"2022-01-25","objectID":"/20220125/:0:1","tags":["Hexo","linux 工具/应用"],"title":"博客生成工具 Hexo","uri":"/20220125/"},{"categories":["blog","linux"],"content":"Ubuntu 平台 1、Hexo 的安装 Hexo 的安装很简单，只需要通过 NPM 工具安装即可。（NPM 请阅读《网站 node 包管理器 npm》） 官方使用说明：文档 npm install -g hexo-cli #全局安装：使用 npm 安装 Hexo hexo version #查看 hexo 版本,可判断其是否安装成功 hexo help #查看 hexo 帮助,可查看命令选项功能列表 2、Hexo 的使用 官方使用说明：命令 网文：使用Hexo博客生成工具 hexo init myhexo/ #创建及初始博客目录(myhexo)(实际从github上clone博客网站资源) cd myhexo/ #进入目录(myhexo) npm install #安装所需资源包 hexo new abc #创建名称为\"abc\"的文件-文章(默认路径)：source/_posts/abc.md，此时可在文件加入一些内容 hexo new page -p about/me \"About me\" #创建目录及文件-文章(指定路径)：source/about/me.md 并加入内容\"About me\"(注:-p 实为 --path) hexo g #生成静态网页(默认路径：public/)(注:g 实为 generate) hexo s #启动本地Web服务(注:s 实为 server) #根据提示用浏览器打开网址预览网站：http://localhost:4000/ 3、Hexo 的主题 待续…… 4、Hexo 的发布 将静态网页托管到 GitHub Pages 直接将public/里面的所有文件（静态网页）托管到 GitHub Pages 上，具体操作请参考：《博客生成工具 Hugo》之【4、Hugo 的发布】。 关于 Github Pages，是 GitHub 的一个功能，其允许用户在 GitHub 仓库托管你的个人、组织或项目的静态页面（自动识别 html、css、javascript）。与创建代码仓库操作步骤一样，不同是要指定仓库名称格式为username.github.io，username 改为你的 GitHub 账户名。 ","date":"2022-01-25","objectID":"/20220125/:0:2","tags":["Hexo","linux 工具/应用"],"title":"博客生成工具 Hexo","uri":"/20220125/"},{"categories":["blog","linux"],"content":"我们经常需要编写一些技术说明书，GitBook 可以帮助你编写简洁电子文档","date":"2022-01-24","objectID":"/20220124/","tags":["GitBook","linux 工具/应用"],"title":"电子书制作工具 GitBook","uri":"/20220124/"},{"categories":["blog","linux"],"content":"GitBook 的简介 GitBook /ɡɪt/bʊk/ 是一个基于 Node.js 的命令行工具，可使用 Github/Git 和 Markdown 来制作精美的电子书（例如：IT 行业技术说明书）。前提需要安装 npm（注：Node.js 都会默认安装 npm，具体请参考笔记《网站 node 包管理器 npm》）注意：node.js(npm) 版本过高，GitBook 不支持（运行命令时提示各种错误），目前建议安装 node-v10.24.1-linux-x64.tar.xz。 官网：gitbook ","date":"2022-01-24","objectID":"/20220124/:0:1","tags":["GitBook","linux 工具/应用"],"title":"电子书制作工具 GitBook","uri":"/20220124/"},{"categories":["blog","linux"],"content":"Ubuntu 平台 1、gitbook 的安装 GitBook 的安装很简单，只需要通过 NPM 工具安装即可。（NPM 请阅读《网站 node 包管理器 npm》） 网文：gitbook 的安装与使用 npm install -g gitbook-cli #安装GitBook电子书构建工具 gitbook -V #查看及检查是否最新版本,否则安装最新版本 #运行上行命令提示出错：TypeError: cb.apply is not a function #问题原因：node.js(npm) 版本过高，GitBook 不支持！ #解决方法：卸载高版本，安装低版本（如：v10.x，全部版本在：https://nodejs.org/dist/） 2、gitbook 的使用 电子书其实主要包括三部分内容：目录、文章介绍、具体章节。编写这三部分的 markdown 文档，再使用 gitbook 构建静态网页。 网文：gitbook 的安装与使用 gitbook init #在当前目录初始电子书（生成两文件: # README.md 书籍的介绍在这个文件里， # SUMMARY.md 书籍的目录结构在这里配置） # 目录语法为Markdown的无序列表+本地文件链接，例如： # * [简介](README.md) # * [第一章](./part1/README.md) # * [第一节](./part1/1.md) # * [第二章](part2/README.md) gitbook build #构建生成静态网页（创建 _book 目录） #gitbook build --format=website #指定输出格式: `website`（默认,静态网页） #gitbook build --format=json #指定输出格式: `json` #gitbook build --format=ebook #指定输出格式: `ebook` gitbook serve #启动本地Web服务 （在浏览器打开 http://localhost:4000/ 预览书籍） 3、gitbook 的发布 方式一：将静态网页托管到托管到 Gitbook 在 Gitbook.com 为此本书创建一个 git 仓库（配置相关参数）； 拷贝 git 地址，然后git clone到本地； 在本地按照 Gitbook 规范编辑电子书，然后git push到 Gitbook 的远程仓库。其默认访问地址是：https://用户名.gitbooks.io/项目名/content/ 具体请参考电子书：gitbook.com 官网操作 方式二：将静态网页托管到 GitHub Pages 直接将_book/里面的所有文件（静态网页）托管到 GitHub Pages 上，具体操作请参考：《博客生成工具 Hugo》之【4、Hugo 的发布】。建议与提醒：只有一本电子书（静态网页）托管到主页站点上是不值得的事，不如建一个人博客，再链接电子书的项目站点（普通项目代码仓库配置为静态网页站点即可，访问地址为https://username.github.io/代码仓库名）； 关于 Github Pages，是 GitHub 的一个功能，其允许用户在 GitHub 仓库托管你的个人、组织或项目的静态页面（自动识别 html、css、javascript）。与创建代码仓库操作步骤一样，不同是要指定仓库名称格式为username.github.io，username 改为你的 GitHub 账户名。 ","date":"2022-01-24","objectID":"/20220124/:0:2","tags":["GitBook","linux 工具/应用"],"title":"电子书制作工具 GitBook","uri":"/20220124/"},{"categories":["blog","linux"],"content":"做一个网站依赖的代码越来越多，npm 就是 node 的包管理器，是前后端工程师必备工具","date":"2022-01-23","objectID":"/20220123/","tags":["npm","linux 工具/应用"],"title":"网站 node 包管理器 npm","uri":"/20220123/"},{"categories":["blog","linux"],"content":"NPM 的简介 npm（Node Package Manager）是 node 的包管理器，随同 NodeJS 一起安装的包管理和分发工具，它很方便让 JavaScript 开发者下载、安装、上传以及管理已经安装的包，无论是前端还是后端开发都会使用到 npm 包管理器。（前端框架开发 react、Vue…，后台 node 开发）。历史原由：做一个网站依赖的代码越来越多，需要去很多网站下载相关分享代码，每次都要手工下载是不现实的，而且如果有个网站关闭了怎么办？于是出现了一个解决方案：用一个工具集中及管理这些代码（资源镜像站），这就是npm之 node 包管理器。 npm 的实现思路可以这么理解： 1、买个服务器做仓库（资源镜像）； 2、让 jQuery、Bootstrap、Underscore…等将代码提交到服务器上； 3、如果有人想用这些库，只需运行命令（如：npm install jQuery）下载到本地，库的代码就会被下载到当前 ./node_modules 目录中。 ","date":"2022-01-23","objectID":"/20220123/:0:1","tags":["npm","linux 工具/应用"],"title":"网站 node 包管理器 npm","uri":"/20220123/"},{"categories":["blog","linux"],"content":"Ubuntu 平台 1、npm 的安装 ● npm 的 linux 版本无需要安装，直接下载解压就可以使用，进入【下载页面】选择 Linux Binaries (x64) 版本下载。更多下载网址： 全部版本下载页面 英文最新下载页面 中文最新下载页面 网文：Linux 系统下 Nodejs 安装与卸载 ####安装方法#### wget https://nodejs.org/dist/latest-v10.x/node-v10.24.1-linux-x64.tar.xz #在命令窗口直接下载 tar -xf node-v10.24.1-linux-x64.tar.xz #解压到当前目录 sudo mv node-v10.24.1-linux-x64 /usr/local/node #移动文件夹并重命名为[node]（如果要安装多个版本，文件夹名称改为另一个名，例如:[node-v17.9.0-linux-x64]） # sudo gedit /etc/profile #（因在系统目录下创建了软链接，此步可不用设置）编辑系统环境变量，在文件最后加入两行内容：export PATH=$PATH:/usr/local/node/bin # source /etc/profile #（因在系统目录下创建了软链接，此步可不用设置）使能系统环境变量。　export PATH=$PATH:/usr/local/node/lib/node_modules/npm/bin cd /usr/bin #切换到软链接目录下 sudo ln -s /usr/local/node/bin/node node #添加执行软链接（如果要安装多个版本，则要改名，例如：sudo ln -s /usr/local/node-v17.9.0-linux-x64/bin/node node-17.9.0） sudo ln -s /usr/local/node/bin/npm npm #添加执行软链接（如果要安装多个版本，则要改名，例如：sudo ln -s /usr/local/node-v17.9.0-linux-x64/bin/npm npm-17.9.0） node -v #查看版本,验证安装是否成功（v10.24.1） npm -v #查看版本,验证安装是否成功（6.14.12） ####卸载方法#### sudo rm -rf /usr/local/node #直接删除整个目录即可（注意小心操作） ● 由于不同的软件需要使用不同的 npm 版本（例如：使用gitbook制作电子书就是因为不支持新版本，运行命令时提示各种错误），所以建议根据实际安装多个版本的 node（npm），多个版本共存的处理方法如下： ####安装方法#### #(1) #安装另一版本同上面介绍一样，只是[node]和[npm]名称不一样， #例如：文件夹名称为[node-v17.9.0-linux-x64]，软链接名称为[node-17.9.0]和[npm-17.9.0]【具体请看(2)】 #(2) #需要修改前面安装的[node-v10.24.1-linux-x64] 软链接名称： cd /usr/bin #切换软链接目录下 sudo ln -s /usr/local/node/bin/node node-10.24.1 #添加执行软链接 sudo ln -s /usr/local/node/bin/npm npm-10.24.1 #添加执行软链接 ####共存处理### sudo update-alternatives --install /usr/bin/node node /usr/bin/node-17.9.0 1709 --slave /usr/bin/npm npm /usr/bin/npm-17.9.0 sudo update-alternatives --install /usr/bin/node node /usr/bin/node-10.24.1 1024 --slave /usr/bin/npm npm /usr/bin/npm-10.24.1 #备注：上面的 --slave 的 npm 表示的默认版本由 node 配置决定 ####选择版本### sudo update-alternatives --config node #配置默认版本，根据界面提示输入对应数字+回车选择 2、npm 的命令 我们常用的npm命令主要是做四种操作：初始化、安装、删除、配置。 网文：npm 常用命令汇总 npm -v #查看npm的版本 npm init #初始化一个NPM项目,生成package.json文件，里面有各种依赖包的信息 npm install #一键安装:安装package.json里的所有依赖文件到当前./node_modules/ 目录下 npm install XXXX #本地安装:安装包到当前./node_modules/ 目录下,需要通过require()调用（注:XXXX为具体包名） npm install XXXX -g #全局安装:安装包到系统 /usr/local/ 目录下(或npm默认安装目录)可以通过命令行在任何地方调用它 npm install XXXX@3.9.1 #安装指定版本的包 npm install XXXX@latest #安装最新版本的包 npm uninstall XXXX #卸载安装的包(或 npm remove) npm info XXXX #查看包的详细信息 npm search XXXX #查找npm仓库 npm config get registry #查看下载仓库镜像网址 npm list #查看当前项目安装的所有模块 npm list -g #查看全局的所有模块 #####[命令/选项]简写##### # install -\u003e i # -global -\u003e -g # -save -\u003e -S（大写） # -save-dev -\u003e -D（大写） 几个选项补充说明 npm install XXXX命令 1. 安装模块到项目 node_modules 目录下。 2. 不会将模块依赖写入 devDependencies 或 dependencies 节点。 3. 运行 npm install 初始化项目时不会下载模块。 npm install -g XXXX命令 1. 安装模块到全局，不会在项目 node_modules 目录中保存模块包。 2. 不会将模块依赖写入 devDependencies 或 dependencies 节点。 3. 运行 npm install 初始化项目时不会下载模块。 npm install -save XXXX命令 1. 安装模块到项目 node_modules 目录下。 2. 会将模块依赖写入 dependencies 节点。 3. 运行 npm install 初始化项目时，会将模块下载到项目目录下。 4. 运行 npm install –production 或者注明 NODE_ENV 变量值为 production 时，【会】自动下载模块到 node_modules 目录中。 5. 主要用于生产环境下，因为生产环境无须安装一些调试或工具模块。 npm install -save-dev XXXX命令 1. 安装模块到项目 node_modules 目录下。 2. 会将模块依赖写入devDependencies 节点。 3. 运行 npm install 初始化项目时，会将模块下载到项目目录下。 4. 运行 npm install –production 或者注明 NODE_ENV 变量值为 production 时，【不会】自动下载模块到 node_modules 目录中。 5. 主要用于开发环境下，因为开发环境往往安装一些调试或工具模块。 3、cnpm 之替代 因为 npm 安装插件是从国外服务器下载，受网络影响大，可能出现异常，所以我们乐于分享的淘宝团队做了一个完整 npmjs.org 镜像（中国 NPM 镜像），你可以用它来代替官方版本（只读），其同步频率目前为每 10 分钟一次以保证尽量与官方服务同步。cnpm跟npm用法是一致，只是在执行命令时将npm改为cnpm即可，但必须要清楚一点：cnpm与npm命令执行有差异。例如：先执行了cnpm install lodash，然后再执行npm uninstall lodash，此时会报错。补充说明：尽管使用 npm 改成淘宝仓库，但当模块比较多的时候，发现安装速度还是远远比 cnpm 慢。个人建议：从通用角度来看，还是建议使用 npm，并把下载仓库路径改为淘宝镜像以提高下载速度。 网文：npm更换成淘宝镜像源以及cnpm ###特别说明#### ##原淘宝【npm】域名即将于【2022.06.30】停止解析，请切换至新域名 # https://npm.taobao.org --切换为--\u003e https://npmmirror.com # https://registry.npm.taobao.org --切换为--\u003e https://registry.npmmirror.com ###cnpm替代#### # npm config get registry #查看下载仓库镜像网址 # npm config set registry https://registry.npmmirror.com #修改下载仓库为淘宝镜像（注意:淘宝镜像只读不能写!）","date":"2022-01-23","objectID":"/20220123/:0:2","tags":["npm","linux 工具/应用"],"title":"网站 node 包管理器 npm","uri":"/20220123/"},{"categories":["software","linux"],"content":"lua 的学习笔记，主要介绍 lua 的基本语法","date":"2021-12-21","objectID":"/20211221/","tags":["lua","linux 工具/应用"],"title":"lua 脚本基本语法","uri":"/20211221/"},{"categories":["software","linux"],"content":"前言 Lua /'luːə/ 是一个小巧且速度极快的脚本语言，由标准 C 编写而成，几乎在所有操作系统和平台上都可以编译运行，是作为嵌入式脚本的最佳选择。本人常用它来对文本内容进行批处理。 ","date":"2021-12-21","objectID":"/20211221/:0:1","tags":["lua","linux 工具/应用"],"title":"lua 脚本基本语法","uri":"/20211221/"},{"categories":["software","linux"],"content":"Lua 简介 1、lua 概述、官网、资料 Lua 是一个小巧的脚本语言，标准 C 编写而成，它可以被 C/C++ 代码调用，也可以反过来调用 C/C++ 的函数，几乎在所有操作系统和平台上都可以编译、运行。Lua 并没有提供强大的库，一个完整的 Lua 解释器不过 200KB，但它在所有脚本引擎中速度是最快的，是作为嵌入式脚本的最佳选择。Lua 是巴西里约热内卢天主教大学（Pontifical Catholic University of Rio de Janeiro）里的一个由 Roberto Ierusalimschy、Waldemar Celes 和 Luiz Henrique de Figueiredo 三人所组成的研究小组于 1993 年开发的。 安装 lua 后，其包括三部分： lua（解释器）： 用于运行 lua 脚本文件。例如：lua test.lua命令是运行 test.lua 脚本文件。 luac（编译器）： 用于加密 lua 脚本文件（但可逆向解密，参考网文）。例如：lua -o t.lua test.lua命令对 test.lua 脚本文件加密并生成 t.lua 加密文件，使用同样方式运行脚本加密文件即可：lua t.lua。 liblua.a（静态库）： 用于集成到其它程序中，例如编译一个 C 程序，调用 lua 操作 API 运行 lua 脚本。如果需要动态库，则需要修改 Makefile 文件并重新编译，具体请参考网文。 资料：官网、网文教程、菜鸟教程、Lua 5.3 API 参考手册、Lua 5.3 参考手册 、Lua API、中国顶级程序员-网游大咖-云风(吴云洋)-博客 + 他的git仓库 + Lua 编程技巧 ","date":"2021-12-21","objectID":"/20211221/:0:2","tags":["lua","linux 工具/应用"],"title":"lua 脚本基本语法","uri":"/20211221/"},{"categories":["software","linux"],"content":"Lua 安装 1、lua 解释器下载与安装 wget http://www.lua.org/ftp/lua-5.4.3.tar.gz #下载 tar zxf lua-5.4.3.tar.gz #解压 cd lua-5.4.3 #进入文件夹 make all test #编译 sudo make install #安装（安装到 /usr/local/bin/：lua(解释器)、luac(编译器)，及 /usr/local/lib/：liblua.a(静态库)） lua -v #查看版本（用于验证是否安装成功） 2、lua 脚本的编写与运行 ● 方法一：（1）编写脚本文件（但不指出 lua 脚本解析器），（2）在命令窗口运行脚本。 --（1）-- print(\"Hello World!\") --创建 HelloWorld.lua 脚本文件，在其增加此行脚本内容 ##（2）## chmod 777 HelloWorld.lua #修改 HelloWorld.lua 文件权限，使其权限为可执行文件 lua ./HelloWorld.lua #在命令窗口运行脚本文件，结果为打印出：Hello World! ● 方法二：（1）编写脚本文件（首行指出 lua 脚本解析器），（2）在命令窗口运行脚本。 #!/usr/local/bin/lua ---(1)--- --上行表示指定 lua 脚本解析器执行。★★注意：上行必须使用 \\n 来换行，不能是 \\r\\n 之类的来换行! 否则会提示 ^M 错误★★ print(\"Hello World!\") --创建 HelloWorld.lua 脚本文件，在其增加这里三行脚本内容 ###(2)### chmod 777 HelloWorld.lua #修改 HelloWorld.lua 文件权限，使其权限为可执行文件 ./HelloWorld.lua #在命令窗口运行脚本文件，结果为打印出：Hello World! ● 说明三：lua 脚本解析器支持交互式编程 lua #在命令窗口运行lua脚本解析器进入交互式编程， \u003e #进入了交互式编程，这里可以即时编写一行脚本并按回车执行： \u003e print(\"Hello World！\") #编写一行脚本内容，按回车后， Hello World！ #执行脚本（本例为打印信息）。 \u003e 3、lua 在 Windows 上安装 ● 方法一：安装现成集成环境（不过 lua 的版本则比较旧） 安装 SciTE 的 IDE 集成环境：网址 安装 LuaDist 的集成库（已不维护）：网址 安装 LuaRocks 的集成库：网址 例如：安装 SciTE 的 IDE 集成环境后，直接在命令窗口运行 lua 脚本文件即可： lua.exe .\\HelloWorld.lua #直接在命令窗口运行lua脚本文件 ● 方法二：自己编译自己安装（可以使用 lua 的最新版本） 下载 TDM-GCC 编译工具，不需要勾选检测是否最新版本，直接点击Creat安装即可（图示），最后在命令窗口输入gcc -v可查看 gcc 版本。 下载 lua 源代码，解压文件并编译。【网上也有已编译好的 lua】 gcc -v #查看gcc版本（用于验证TDM-GCC是否安装成功） cd lua-5.4.4 #进入lua文件夹（刚才文件解压的根文件夹） mingw32-make mingw #编译lua源代码（在src\\里生成：lua.exe(解释器)、luac.exe(编译器)，liblua.a(静态库)） cd src #进入src\\目录 lua.exe -v #查看lua版本（用于验证lua是否编译成功） 将 lua 加入环境变量（图示），但建议直接把lua.exe、luac.exe、liblua.a、lua54.dll剪切到C:\\Windows目录下。 备注： 关于 TDM-GCC：是为 windows 系统打造的编译器套件，其衍生自 MinGW 和 MinGW-w64 的项目，分为 32 位与 64 位两个版本，32 位版本的编译目标仅兼容 32 位应用程序，64 位版本的编译目标兼容 32 位应用程序与 64 位应用程序，最新的官方二进制版本为 GCC 10.3.0。更多的编译构建工具知识，请移步《linux-编译-linux 编译构建工具》。 参考：TDM-GCC 安装 lua、MinGW 编译 lua、MinGW 安装文件区别 ","date":"2021-12-21","objectID":"/20211221/:0:3","tags":["lua","linux 工具/应用"],"title":"lua 脚本基本语法","uri":"/20211221/"},{"categories":["software","linux"],"content":"Lua 语法 1、lua 概述 lua 由标准 C 编写而成，可以被 C/C++ 代码调用，也可以反过来调用 C/C++ 的函数，基于此我们可以很容易想像出它的语法一定会与 C 语言很相似。其中独立语句可以使用;分号分隔，也可以不用。还有特别说明一下，Lua 的所有变量其实都是字符，例如直接打印一个函数返回值return 100，虽然它是number数据类型，但打印结果还是字符串：100。 2、lua 关键字 一、lua 的关键字： 说明一、lua 关键字主要包括：声明、函数、跳转、返回、结束、判断、循环、真假、与或非等语句关键字。下面列出 22 个关键字： 关键字 关键字 关键字 关键字 local if then true function elseif false goto else nil break for in or return while do and end repeat until not 二、Lua 的数据类型： 说明二、Lua 数据类型主要包括：空值、布尔值、数值、字符串、数据、线程、表这些数据类型，它们通过type()函数返回值获得（返回为字符串，由字符串单词指出数据类型）。下面列出 8 个数据类型： 关键字 含义 “nil” 空值（在条件表达式中相当于 false） “boolean” 布尔值，包含两个值：true 和 false “number” 表示双精度类型的实浮点数 “string” 字符串由一对双引号或单引号来表示 “function” 由 C 或 Lua 编写的函数 “userdata” 表示任意存储在变量中的 C 数据结构 “thread” 表示执行的独立线路，用于执行协同程序 “table” Lua 中的表其实是一个\"关联数组\"（associative arrays），数组的索引可以是数字、字符串或表类型。在 Lua 里，table 的创建是通过“构造表达式”来完成，最简单构造表达式是{}，用来创建一个空表 补充说明 type()返回都是字符串！ --类型打印实例-- tb = {} aaa = nil print(type(tb)) --\u003e table print(type(\"Hello world\")) --\u003e string print(type(10.4*3)) --\u003e number print(type(print)) --\u003e function print(type(type)) --\u003e function print(type(true)) --\u003e boolean print(type(nil)) --\u003e nil print(type(type(print))) --\u003e string !!! if type(123) == \"number\" then --判断方法 end if type(aaa) == \"nil\" then --判断方法 end 三、Lua 的运算符： 说明三、Lua 运算符主要包括：算术、关系、逻辑、其它这几类运算符。它们有不同的优先级（强烈建议使用()指定），下面列出 8 级优先级： 优先级 运算符 备注 最高 ^ 连续几个^则是优先从右到左组合 x^y^z == x^(y^z) ↑ not　- - 为负号 │ *　/　% │ +　- │ .. │ \u003c　\u003e　\u003c=　\u003e=　~=　== │ and 最低 or --算术运算符-- + --加法 - --减法 * --乘法 / --除法 % --取余 ^ --乘幂（10^2为100） - --负号（-10） --关系运算符-- == --等于 ~= --不等于 \u003e --大于 \u003c --小于 \u003e= --大于等于 \u003c= --小于等于 --逻辑运算符-- （用于条件判断中：if() elseif() while() until()） and --逻辑与操作符（如：(A and B)） or --逻辑或操作符（如：(A or B)） not --逻辑非操作符（如：not(A and B)） --其它运算符-- # --返回字符串或数组的长度（如：#\"Hello\" 返回字符个数 5）（如果存在`nil`的组员，则计算组员个数可能出错！！！） : --表示表员/组员为函数且以隐式方式把表作为入口参数（如：file:read() 表示[表file]的表员是read()函数,并以隐式方式把[表file]作为入口参数,在函数内访问表员i写作 self.i ） . --表示表员/组员 （如：tb.i 表示 表tb的表员i） .. --连接两个字符串（如：a=\"Hello \" b=\"World\" print(a..b)，结果为：Hello World） ... --可变符：select(\"#\",...)则返回可变参数的个数 -- select( 3,...)则返回从第3开始的所有参数 -- (...)表示函数入口的变长参数 -- {...}表示由当前函数变长参数构成的数组 四、Lua 的注释： 说明四、Lua 注释主要包括：行、块两类注释。下面列出 2 种注释演示： --这是一行注释 --[[ 多行注释 多行注释 --]] 3、lua 变量 一、Lua 的变量： 说明一、Lua 变量有三种类型：全局变量、局部变量（local声明）、表中的域，它们的默认值（没有初始化时）均为nil。下面是展示变量的声明和初始化： tb = {} --这是一个没赋值的全局数组/表 tb.i --这是一个表的表员（《指定键名》为\"i\"的表员） tb[\"i\"] --这是一个表的表员（《指定键名》为\"i\"的表员） tb[i] --这是一个数组组员（【没有键名】的第i个组员） v = 1 --这是一个初始值为1的全局变量 a,b = a,v --这是多个变量给多个变量赋值，右边的变量值是本行命令之前的缓冲值(固定不会变)，不会受本行命令影响！ a,b = b,a --同上，结果就是 a 与 b 数值交换 a,b = 1 --等同 a,b = 1,nil a = --等同 a = nil b = nil --赋空值，相当于删除全局变量（释放内存） a,b = f() --函数多个返回值依次赋值a,b，如果只有一个返回值则 b=nil local c = 1 --这是一个局部变量，局部变量的访问速度比全局变量更快 二、Lua 的表/数组： 说明二、Lua 表/数组主要分为：一维数组、多维数组。表/数组的元素组成：键(名)=值。关于数组与表区别：数组其实就是一个有序的表。关于我对【表员】和〖组员〗的定义：有或无《键名》的元素都称为【表员】，没有《键名》的元素称为〖组员〗。不建议〖组员〗的数值设置为nil，否则会影响相关函数操作！ -----【一维数组】----- array = {a=\"a\",\"1\",b=\"b\",c} --数组 array, 共用一个组员（组员编号默认从1计起，默认为一维数组） print(array.c) --打印《指定键名》为 \"c\"的表员：nil（未赋值） print(array.a) --打印《指定键名》为 \"a\"的表员：a print(array[\"b\"]) --打印《指定键名》为 \"b\"的表员：b print(array[1]) --打印【有序组员】的第一个组员：1 print(array[2]) --打印不存在组员：nil（组员编号默认从1计起） print(array[0]) --打印不存在组员：nil（组员编号默认从1计起） print(array[\"abc\"]) --打印不存在表员：nil array = {} --数组 array（空数组，需要初始组员编号及数值） for i = -2,2,1 do array[i] = i*2 --初始组员编号及数值（本例组员设置为从-2计起） end --！！！但不建议设置编号为负数！！！ for i = -2,2,1 do print(array[i]) --打印所有的组员：-4 -2 0 2 4（共5行组员数值） end -----【多维数组】----- array = {} --数组 array（空数组，需要初始组员编号及数值） for i=1,3,1 do array[i] = {} --数组 array 首先初始一维数组，（必须初始第一维后，再初始此一维中的第二维，否则视为非法语句！） for j=1,3,1 do array[i][j] = i*j --数组 array 接着初始二维数组。（必须初始第一维后，再初始此一维中的第二维，否则视为非法语句！） end end for i=1,3,1 do for j=1,3,1 do print(array[i][j]) --打印所有的组员：1 2 3 2 4 6 3 6 9（共9行组员数值） end end 三、lua 的字符串： 说明三、字符串语法包括\"\" '' [[]]，其中[[]]中书写的特殊字符不需要转义。 -----【字符串】------- s = [[a\\\\\\\"\\'[[b]c]] --多行字符串：其语法不支持转义符，不支持连续多个“]”字符，但支持单个或隔开的“]”字符。 string1 = \"Lua\" --单行字符串：\"\" （注：\"\" 与 '' 没本质区别） string2 = '\\\"runoob.com\\\"' --单行字符串：'' （注：\"\" 与 '' 没本质区别） string3 = --多行字符串：[[]]（注：[[ 后可直接换行，不算入多行字符串的回车或换行！） [[ \"Lua Script\" ]] print(s) --打印的信息为：a","date":"2021-12-21","objectID":"/20211221/:0:4","tags":["lua","linux 工具/应用"],"title":"lua 脚本基本语法","uri":"/20211221/"},{"categories":["software","linux"],"content":"Lua 数据库 待续…… ","date":"2021-12-21","objectID":"/20211221/:0:5","tags":["lua","linux 工具/应用"],"title":"lua 脚本基本语法","uri":"/20211221/"},{"categories":["software"],"content":"介绍 attribute-at 编译属性的使用","date":"2021-06-27","objectID":"/20210627/","tags":["attribute"],"title":"attribute-at 编译属性-指定地址","uri":"/20210627/"},{"categories":["software"],"content":"简介 某些情况下的某个数据必须存储到指定地址的空间内，这样我们的程序或硬件才能正确访问（例如：设备的 ID）。对于这类需求，GCC 的编译属性__attribute__((at(绝对地址)))为我们提供了解决方案。 更多的 attribute 编译属性： 《attribute-section 编译属性-数据拼接》 《attribute-aligned 编译属性-地址对齐》 《attribute-packed 编译属性-字节对齐》 《attribute-weak 编译属性-弱符号》 《attribute-un/used 编译属性-未用警告》 《attribute-at 编译属性-地址指定》 ","date":"2021-06-27","objectID":"/20210627/:0:1","tags":["attribute"],"title":"attribute-at 编译属性-指定地址","uri":"/20210627/"},{"categories":["software"],"content":"使用 1、作用对象 __attribute__((at(绝对地址)))作用对象： 全局变量。 2、功能说明 __attribute__((at(绝对地址)))将全局变量强制定位到 RAM/Flash 的绝对地址上。 3、编程语法 //【全局变量】定位绝对地址上 const uint8_t id_1[12] __attribute__((at(0x0800F000))) = {1,2,3,4,5,6,7,8,9,10,11,12}; const uint8_t __attribute__((at(0x0800F100))) id_2[12] = {1,2,3,4,5,6,7,8,9,10,11,12}; __attribute__((at(0x0800F200))) const uint8_t id_3[12] = {1,2,3,4,5,6,7,8,9,10,11,12}; 关于__attribute__(())语句书写位置补充说明：书写到不同位置可能会产生不同结果，甚至会编译出错。总原则建议：书写到对象名称的前面（但函数除外，因为函数名称与返回类型为不可分割的整体），不过对于变量或函数还是建议放到最前面修饰更方便阅读。例如：【对象名称前】typedef uint16_t __attribute__((aligned(64))) my_uint16addr64_t;、【变量最前面】__attribute__((used)) uint8_t data[5]; ","date":"2021-06-27","objectID":"/20210627/:0:2","tags":["attribute"],"title":"attribute-at 编译属性-指定地址","uri":"/20210627/"},{"categories":["software"],"content":"介绍 attribute-un/used 编译属性的使用","date":"2021-06-26","objectID":"/20210626/","tags":["attribute"],"title":"attribute-un/used 编译属性-未用警告","uri":"/20210626/"},{"categories":["software"],"content":"简介 某些情况下的某些变量或函数通过间接方式调用（例如：使用section修饰的数据、操作系统与应用程序分离设计），这些变量或函数必须要保留，不被编译器优化掉或编译产生警告。对于这类需求，GCC 的编译属性__attribute__((used))为我们提供了解决方案。 更多的 attribute 编译属性： 《attribute-section 编译属性-数据拼接》 《attribute-aligned 编译属性-地址对齐》 《attribute-packed 编译属性-字节对齐》 《attribute-weak 编译属性-弱符号》 《attribute-un/used 编译属性-未用警告》 《attribute-at 编译属性-地址指定》 ","date":"2021-06-26","objectID":"/20210626/:0:1","tags":["attribute"],"title":"attribute-un/used 编译属性-未用警告","uri":"/20210626/"},{"categories":["software"],"content":"使用 1、作用对象 __attribute__((used))作用对象： 变量和函数。 2、功能说明 __attribute__((used))向编译器说明该函数或变量即使没使用也不能优化掉，不能产生警告。 __attribute__((unused))则是表示该函数或变量可能不使用，编译器不要产生警告信息。 多数情况下，这项属性与其它属性组合使用，单独使用的情况反而较少。关于属性的组合书写格式：在(( ))内写入多项属性，并使用,分隔。例如：__attribute__((used, section(\"data_name\"))) 3、编程语法 //【变量】写法： __attribute__((used)) uint8_t data1[5]; __attribute__((unused)) uint8_t data2[5]; uint8_t __attribute__((unused)) data3[5]; __attribute__((used, section(\"data_name\"))) const uint32_t data4[10]; //【函数】写法一： //__attribute__((used)) static int keep_this_fn(int k); static int keep_this_fn(int k) __attribute__((used)); static int keep_this_fn(int k) { k++; } //【函数】写法二：（建议使用） static int keep_this_fn(int k); __attribute__((used)) static int keep_this_fn(int k) { k++; } 关于__attribute__(())语句书写位置补充说明：书写到不同位置可能会产生不同结果，甚至会编译出错。总原则建议：书写到对象名称的前面（但函数除外，因为函数名称与返回类型为不可分割的整体），不过对于变量或函数还是建议放到最前面修饰更方便阅读。例如：【对象名称前】typedef uint16_t __attribute__((aligned(64))) my_uint16addr64_t;、【变量最前面】__attribute__((used)) uint8_t data[5]; ","date":"2021-06-26","objectID":"/20210626/:0:2","tags":["attribute"],"title":"attribute-un/used 编译属性-未用警告","uri":"/20210626/"},{"categories":["software"],"content":"介绍 attribute-weak 编译属性的使用","date":"2021-06-25","objectID":"/20210625/","tags":["attribute"],"title":"attribute-weak 编译属性-弱符号","uri":"/20210625/"},{"categories":["software"],"content":"简介 有为公司搭建通用软件工程（开发平台）的同学们都知道，公共代码部分往往需要编写一些默认的处理函数，当用户想使用自己编写的处理函数，只需编写同名函数就可以让编译器编译时自动实现将默认函数取代为用户函数。对于这类需求，GCC 的编译属性__attribute__((weak))为我们提供了解决方案。 更多的 attribute 编译属性： 《attribute-section 编译属性-数据拼接》 《attribute-aligned 编译属性-地址对齐》 《attribute-packed 编译属性-字节对齐》 《attribute-weak 编译属性-弱符号》 《attribute-un/used 编译属性-未用警告》 《attribute-at 编译属性-地址指定》 ","date":"2021-06-25","objectID":"/20210625/:0:1","tags":["attribute"],"title":"attribute-weak 编译属性-弱符号","uri":"/20210625/"},{"categories":["software"],"content":"使用 1、作用对象 __attribute__((weak))作用对象： 常用于函数。在函数实体前面加入此特定语法声明，则表明此函数为弱函数。 2、应用情景 例如搭建一个单片机通用应用工程时，我们一定要事先编写所有的默认中断处理函数，防止某些情形产生中断而无处理函数造成程序跑飞。当有编写同名的专用中断处理函数时，编译器就使用对应专用函数；当没有编写专用中函数时，编译器则使用默认函数。这样做的好处是公共代码独立统一，在同一平台下所有项目工程共用。例如：STM32 单片机 HAL 驱动库就是一个典型例子，它为我们编写好的所有中断处理函数，但当我们想编写自己中断处理函数时，只需要编写同名函数就可以取代 HAL 库的中断函数，非常方便。 3、编程语法 test_main.c含有默认的中断函数： #include \u003cstdio.h\u003e#include \u003cstdint.h\u003evoid test_irq(void); int main(int arg1, char *arg2[]) { test_irq(); //验证结果 } //这是默认的中断函数------- __attribute__((weak)) void test_irq(void) { printf(\"run: default irq func\"); } user_irq.c用户编写的中断函数： #include \u003cstdio.h\u003e#include \u003cstdint.h\u003e //用户编写的中断函数------- void test_irq(void) { printf(\"run: user's irq func\"); } 弱函数在应用中的两种表现： #【没加】用户编写的中断函数时的编译运行： gcc test_main.c -o test_main #编译 ./test_main.exe #运行 run: default irq func #打印结果（弱函数被编译运行） #【加入】用户编写的中断函数时的编译运行： gcc test_main.c user_irq.c -o test_main #编译 ./test_main.exe #运行 run: user's irq func #打印结果（弱函数被取代） 关于__attribute__(())语句书写位置补充说明：书写到不同位置可能会产生不同结果，甚至会编译出错。总原则建议：书写到对象名称的前面（但函数除外，因为函数名称与返回类型为不可分割的整体），不过对于变量或函数还是建议放到最前面修饰更方便阅读。例如：【对象名称前】typedef uint16_t __attribute__((aligned(64))) my_uint16addr64_t;、【变量最前面】__attribute__((used)) uint8_t data[5]; ","date":"2021-06-25","objectID":"/20210625/:0:2","tags":["attribute"],"title":"attribute-weak 编译属性-弱符号","uri":"/20210625/"},{"categories":["software"],"content":"介绍 attribute-packed 编译属性的使用","date":"2021-06-24","objectID":"/20210624/","tags":["attribute"],"title":"attribute-packed 编译属性-字节对齐","uri":"/20210624/"},{"categories":["software"],"content":"简介 对于嵌入式底层二进制通讯数据，往往需要取消处理器默认长度的数据对齐方式（例如：4 字节对齐），而是取用 1 字节对齐方式。对于这类需求，GCC 的编译属性__attribute__((packed))为我们提供了解决方案。另外：#pragma pack(push,1) #pragma pack(pop)则是一样效果的另一套方案。 更多的 attribute 编译属性： 《attribute-section 编译属性-数据拼接》 《attribute-aligned 编译属性-地址对齐》 《attribute-packed 编译属性-字节对齐》 《attribute-weak 编译属性-弱符号》 《attribute-un/used 编译属性-未用警告》 《attribute-at 编译属性-地址指定》 ","date":"2021-06-24","objectID":"/20210624/:0:1","tags":["attribute"],"title":"attribute-packed 编译属性-字节对齐","uri":"/20210624/"},{"categories":["software"],"content":"使用 1、作用对象 __attribute__((packed))作用对象： 作用于结构体中每个成员，其所有变量数据都是按照单字节方式对齐。 2、应用情景 在我们单片机的通讯中，一般都是这样定义通讯协议：第一字节为帧头，第二字节为数据长度，第三字节是命令……。对于很多刚入行的工程师基本上都是这样读写数据：使用单字节数组方式读写数据（例如：d[1] = 5）。这样的写法缺点很多，一是这种偏移量难理解其意义不利用阅读且容易出错，二是如果中间要插入参数则其后面所有偏移量都要修改，三是对于整型等这类数据访问很不方便（例如：u16 = (d[11]\u003c\u003c8) | d[10]）。其实我们可以将这组数据进行格式化，只需通过结构体定义这组数据，并且使用特定扩展语法强制结构体数据以单字节方式对齐，之后就可以非常方便地使用结构体方式对数据进行读写（例如：d.cmd = 1）。 3、编程语法 #include \u003cstdio.h\u003e#include \u003cstdint.h\u003eint main(int arg1, char *arg2[]) { //---------------------------------------------------------------------------------------------------- //方式1、__attribute__((packed)) //---------------------------------------------------------------------------------------------------- typedef struct data1_ { uint8_t head; //帧头 uint8_t len; //数据长度 uint8_t cmd; //命令 uint32_t d1; //数据1 uint16_t d2; //数据2 uint8_t checksum; //校验和 }__attribute__((packed)) data1_t; data1_t dd1; //////////////////// dd1.head = 1; //1字节 dd1.len = 7; //1字节 dd1.cmd = 123; //1字节 dd1.d1 = 987654321; //4字节 dd1.d2 = 65535; //2字节 dd1.checksum = 0; //1字节 printf(\"dd1.d1=%u\\n\", dd1.d1); //dd1.d1=987654321 printf(\"dd1.d2=%u\\n\", dd1.d2); //dd1.d2=65535 printf(\"sizeof(dd1)=%u\\n\", sizeof(dd1)); //sizeof(dd1)=10 printf(\"----------------\\n\"); //---------------- //---------------------------------------------------------------------------------------------------- //方式2、#pragma pack(push,1) #pragma pack(pop) //---------------------------------------------------------------------------------------------------- #pragma pack(push,1) //(push)与(pop)要配对, 可以嵌套; 1-\u003e1字节对齐, 其可 1,2,4,8,16 typedef struct data2_ //#pragma pack(push,1) 相当于两条语句：#pragma pack(push) #pragma pack(1) { uint8_t head; //帧头 uint8_t len; //数据长度 uint8_t cmd; //命令 uint32_t d1; //数据1 uint16_t d2; //数据2 uint8_t checksum; //校验和 }data2_t; #pragma pack(pop) data2_t dd2; //////////////////// dd2.head = 1; //1字节 dd2.len = 7; //1字节 dd2.cmd = 123; //1字节 dd2.d1 = 987654321; //4字节 dd2.d2 = 65535; //2字节 dd2.checksum = 0; //1字节 printf(\"dd2.d1=%u\\n\", dd2.d1); //dd2.d1=987654321 printf(\"dd2.d2=%u\\n\", dd2.d2); //dd2.d2=65535 printf(\"sizeof(dd2)=%u\\n\", sizeof(dd2)); //sizeof(dd2)=10 printf(\"----------------\\n\"); //---------------- } 关于__attribute__(())语句书写位置补充说明：书写到不同位置可能会产生不同结果，甚至会编译出错。总原则建议：书写到对象名称的前面（但函数除外，因为函数名称与返回类型为不可分割的整体），不过对于变量或函数还是建议放到最前面修饰更方便阅读。例如：【对象名称前】typedef uint16_t __attribute__((aligned(64))) my_uint16addr64_t;、【变量最前面】__attribute__((used)) uint8_t data[5]; ","date":"2021-06-24","objectID":"/20210624/:0:2","tags":["attribute"],"title":"attribute-packed 编译属性-字节对齐","uri":"/20210624/"},{"categories":["software"],"content":"介绍 attribute-aligned 编译属性的使用","date":"2021-06-23","objectID":"/20210623/","tags":["attribute"],"title":"attribute-aligned 编译属性-地址对齐","uri":"/20210623/"},{"categories":["software"],"content":"简介 对于一些硬件控制器或者是操作系统堆栈，要求数据的起始地址必须是处理器位长的倍数关系，如果不是倍数关系则会影响运行速率甚至硬件会运行出错。对于这类需求，GCC 的编译属性__attribute__((aligned(n)))为我们提供了解决方案。 更多的 attribute 编译属性： 《attribute-section 编译属性-数据拼接》 《attribute-aligned 编译属性-地址对齐》 《attribute-packed 编译属性-字节对齐》 《attribute-weak 编译属性-弱符号》 《attribute-un/used 编译属性-未用警告》 《attribute-at 编译属性-地址指定》 ","date":"2021-06-23","objectID":"/20210623/:0:1","tags":["attribute"],"title":"attribute-aligned 编译属性-地址对齐","uri":"/20210623/"},{"categories":["software"],"content":"使用 1、作用对象 __attribute__((aligned(n)))作用对象： 1、单个标准数据类型变量的起始地址。 2、整个标准数据类型数组的起始地址。 3、结构体的起始地址，还可以通过特定语法影响其大小（此特性可以影响结构体数组的组员起始地址）。 总结：主要作用是影响变量的起始地址，对于结构体还可以通过特定语法影响其大小。 2、编程语法 #include \u003cstdio.h\u003e#include \u003cstdint.h\u003eint main(int arg1, char *arg2[]) { //---------------------------------------------------------------------------------------------------- //1、单个标准数据类型变量的【起始地址】对齐： //---------------------------------------------------------------------------------------------------- typedef uint8_t __attribute__((aligned(64))) my_uint16addr64_t; //自定义标准数据类型的【起始地址】对齐 //typedef uint8_t my_uint16addr64_t __attribute__((aligned(64))); //同上 my_uint16addr64_t a; // my_uint16addr64_t a5[5]; 非法语句!!!!!!!!!! printf(\"\u0026a=%u\\n\", \u0026a); //\u0026a=4294953984 --\u003e 起始地址整除[64] printf(\"sizeof(a)=%u\\n\", sizeof(a)); //sizeof(a)=1 --\u003e 还是原标准数据类型的大小!! printf(\"----------------\\n\"); //---------------- //---------------------------------------------------------------------------------------------------- //2、整个标准数据类型数组的【起始地址】对齐： //---------------------------------------------------------------------------------------------------- __attribute__((aligned(64))) uint8_t a5[5]; //作用对象：整个数组 //uint8_t __attribute__((aligned(64))) a5[5]; //作用对象：整个数组（同上） //uint8_t a5[5] __attribute__((aligned(64))); //作用对象：整个数组（同上） //__attribute__((aligned(64))) (uint8_t a5[5]); //作用对象：非法!!!! //(__attribute__((aligned(64))) uint8_t) a5[5]; //作用对象：非法!!!! //uint8_t (__attribute__((aligned(64))) a5[5]); //作用对象：非法!!!! //在数组声明中，只要括号括住两个语段，__attribute__((aligned(n)))的作用对象都为非法!!! printf(\"\u0026a5=%u\\n\", \u0026a5); //\u0026a5=4294953856 --\u003e 起始地址整除[64] printf(\"sizeof(a5)=%u\\n\", sizeof(a5)); //sizeof(a5)=5 --\u003e 还是原标准数据类型的大小!! printf(\"----------------\\n\"); //---------------- //---------------------------------------------------------------------------------------------------- //3、结构体的【起始地址】对齐（通过特定语法可影响结构体【大小】） //---------------------------------------------------------------------------------------------------- typedef struct objx_ { uint16_t a; uint8_t b; }__attribute__((aligned(64))) objx_t; //此写法可影响结构体类型的【起始地址】和【大小】，或者是结构体数组的组员(结构体) typedef struct objy_ { uint16_t a; uint8_t b; }objy_t __attribute__((aligned(64))); //此写法只影响结构体类型的【起始地址】，但不影响其大小，不能用于结构体数组-\u003e解决方法请看[z5] objx_t x5[5]; objx_t x; objy_t y; // objx_t y5[5]; 非法语句!!!!!!!!!! __attribute__((aligned(64))) struct objy_ z5[5]; //实际就是第【2】的只影响数组的【起始地址】对齐 printf(\"\u0026x5=%u\\n\", \u0026x5); //\u0026x5=4294953408 --\u003e 起始地址整除[64] printf(\"\u0026x=%u\\n\", \u0026x); //\u0026x=4294953728 --\u003e 起始地址整除[64] printf(\"\u0026y=%u\\n\", \u0026y); //\u0026y=4294953920 --\u003e 起始地址整除[64] printf(\"\u0026z5=%u\\n\", \u0026z5); //\u0026z5=4294953792 --\u003e 起始地址整除[64] printf(\"sizeof(z5[0])=%u\\n\", sizeof(z5[0])); //sizeof(z5[0])=4 --\u003e 单个结构体大小为[4]字节 printf(\"sizeof(x5[0])=%u\\n\", sizeof(x5[0])); //sizeof(x5[0])=64 --\u003e 单个结构体大小为[64]字节 printf(\"sizeof(x5)=%u\\n\", sizeof(x5)); //sizeof(x5)=320 --\u003e 结构体数组总大小[320]字节 printf(\"sizeof(x)=%u\\n\", sizeof(x)); //sizeof(x)=64 --\u003e 此个结构体大小为[64]字节 printf(\"sizeof(y)=%u\\n\", sizeof(y)); //sizeof(y)=4 --\u003e 此个结构体大小为[4]字节 printf(\"----------------\\n\"); //---------------- } 关于__attribute__(())语句书写位置补充说明：书写到不同位置可能会产生不同结果，甚至会编译出错。总原则建议：书写到对象名称的前面（但函数除外，因为函数名称与返回类型为不可分割的整体），不过对于变量或函数还是建议放到最前面修饰更方便阅读。例如：【对象名称前】typedef uint16_t __attribute__((aligned(64))) my_uint16addr64_t;、【变量最前面】__attribute__((used)) uint8_t data[5]; ","date":"2021-06-23","objectID":"/20210623/:0:2","tags":["attribute"],"title":"attribute-aligned 编译属性-地址对齐","uri":"/20210623/"},{"categories":["software"],"content":"介绍 attribute-section 编译属性的使用","date":"2021-06-22","objectID":"/20210622/","tags":["attribute"],"title":"attribute-section 编译属性-数据拼接","uri":"/20210622/"},{"categories":["software"],"content":"简介 数据拼接就是把分散的数据（全局/只读），通过编译器的编译链接把它们拼接起来放到一段连续的空间内，本人简称为“串表”。如果这些分散的数据都是同一类型，则这段数据就是数组，程序可实现快速访问。对于这类需求，GCC 的编译属性__attribute__((section(\"name\"))为我们提供了解决方案。 更多的 attribute 编译属性： 《attribute-section 编译属性-数据拼接》 《attribute-aligned 编译属性-地址对齐》 《attribute-packed 编译属性-字节对齐》 《attribute-weak 编译属性-弱符号》 《attribute-un/used 编译属性-未用警告》 《attribute-at 编译属性-地址指定》 ","date":"2021-06-22","objectID":"/20210622/:0:1","tags":["attribute"],"title":"attribute-section 编译属性-数据拼接","uri":"/20210622/"},{"categories":["software"],"content":"用途 数据拼接常用于设备启动时初始化各个模块，其中 linux 的 initcall 机制就是基于此原理实现的。下面对比介绍上电初始化的几种方式：调用方式、列表方式、串表方式。 1、调用方式 在main()函数最前在分别调用这些初始化函数，当新增一模块就必须在main()增加代码 ，这种方式与main()过于耦合。试想一下 linux 系统，少则几百多则上千上万个初始化函数放在一起，那是多么恐怖的事，而且 linux 核心源文件是不给程序员随便改动的，否则会影响系统稳定性。也就是说对于中大型工程这种方式不可取。 int main(void) { //每当增加模块初始化，都需在这里增加初始化函数 init_a(); init_b(); init_c(); while(1) { ... } } 2、列表方式 做一个数组列表，在列表加入这些初始化函数，main()的上电初始化时用for循环统一初始化，当新增一模块无须动代码，只需要在数组列表增加内容即可，这种方式比调用方式简洁方便很多。而且这个表格可以独立放到一个文件里，不但集中管理调用初始化函数，还有效阻隔核心代码不被程序员改动。由于集中管理，会存在一定可能性的误操作（如：误删别的模块初始化操作），与独立模块还存在一定的耦合性。 typedef void (*func_t)(void); const func_t func_tab[] = { init_a, init_b, init_c }; //平时只需维护此列表 int main(void) { int i; for (i=0; i\u003csizeof(func_tab)/sizeof(func_tab[0]); i++) { (*(func_tab[i]))(); } while(1) { ... } } 3、串表方式 在main()的上电初始化时使用for循环调用事先已预设好的串表，串表内容（组员）分散在各种模块中，依靠编译器的编译链接把它们存到这个串表里（无需人工添加）。 关键字-属性__attribute__ /ə’trɪbjuːt/ 关键字-分段section /’sekʃn/ 语法：__attribute__((used, section(\".name.\" \"tail\"))) .name. 为分段名称，同名分段数据存放到同一段连接的空间内。 tail 为分段名称后缀，先由它决定数据先后顺序，再由代码编译先后顺序决定。 used 向编译器说明这段代码即使没使用也不能优化掉，不能产生警告； 而 unused 则是表示该函数或变量可能不使用，编译器不要产生警告信息。 主程序：main.h //---定义串表--- typedef void (*p_init_fun_t)(void); struct init_fun_tab { p_init_func_t pfun; //初始函数(指针) const uint8_t *name; //函数名称(指针) }; // 属性关键字 分段关键字 分段名称 分段名称后缀 // +-----+-----+ +----+----+ +---+---+ +-+-+ #define INITSECTION(level) __attribute__((used, __section__(\".init_fn.\" level))) #define INIT_FRONT_EXPORT(func,name) INITSECTION(\"0.front\") const struct init_fun_tab init_fn_##func = {func, name} //串表头 #define INIT_TABLE_EXPORT(func,name) INITSECTION(\"1\" ) const struct init_fun_tab init_fn_##func = {func, name} #define INIT_LIMIT_EXPORT(func,name) INITSECTION(\"1.limit\") const struct init_fun_tab init_fn_##func = {func, name} //串表尾 // +---------+-------+ +----------------------------+------------------------+ // 串表宏 一个表员(结构体)数据 主程序：main.c //---调用串表--- void tab_front(void) {} INIT_FRONT_EXPORT(tab_front, \"tab_front()\"); //串表头 void tab_limit(void) {} INIT_LIMIT_EXPORT(tab_limit, \"tab_limit()\"); //串表尾 int main(void) { const struct init_fun_tab *p_init; //执行串表（由编译器维护列表内容） for (p_init=\u0026init_fn_tab_front+1; p_init\u003c\u0026init_fn_tab_limit; p_init++) { printf(\"run:%s\\r\\n\", p_init-\u003ename); (*(p_init-\u003epfun))(); } while(1) { ... } } 模块a： //---加入串表--- include \"main.h\" void init_a(void) { printf(\"init_a code\\r\\n\"); }//加入串表 INIT_TABLE_EXPORT(init_a, \"init_a()\"); //告知编译器将函数地址加入到串表 模块b： //---加入串表--- include \"main.h\" void init_b(void) { printf(\"init_b code\\r\\n\"); }//加入串表 INIT_TABLE_EXPORT(init_b, \"init_b()\"); //告知编译器将函数地址加入到串表 main.c写好后，就不会改动，如果模块想在main.c完成初始化工作，只需在其初始化函数后面加入INIT_TABLE_EXPORT()宏，编译器编译时就可以通过此宏知道将函数指针加入到main.c的初始化列表上。从代码上看，模块与模块之间没有任何的函数调用关系，高质量实现高内聚性低耦合度。 4、作用对象 __attribute__((section(x)))作用对象： 主要针对只读变量。 ","date":"2021-06-22","objectID":"/20210622/:0:2","tags":["attribute"],"title":"attribute-section 编译属性-数据拼接","uri":"/20210622/"},{"categories":["software"],"content":"扩展 数据拼接除了可以用在初始化上，还可以应用于很多场合，只要和列表有关的都有应用的可能性。 1、回调串表 本人编写独立模块时，喜欢通过回调函数的方式来通知其它模块，而且回调函数做成列表，即使用列表触发通知多个第三方模块。拿按键模块作为示例，当检测到有按键动作时，调用回调列表触发【界面模块】和【恢复出厂初始化模块】执行相应动作。 按键模块：key.h typedef void (*p_key_fun_t)(uint8_t key, uint8_t action, uint32_t time); struct key_fun_tab { p_key_func_t pfun; //回调函数(指针) }; // 属性关键字 分段关键字 分段名称 分段名称后缀 // +-----+-----+ +----+----+ +--+--+ +-+-+ #define KEYSECTION(level) __attribute__((used, __section__(\".key_fn.\" level))) #define KEY_FRONT_EXPORT(func) KEYSECTION(\"0.front\") const struct key_fun_tab key_fn_##func = {func} //串表头 #define KEY_TABLE_EXPORT(func) KEYSECTION(\"1\" ) const struct key_fun_tab key_fn_##func = {func} #define KEY_LIMIT_EXPORT(func) KEYSECTION(\"1.limit\") const struct key_fun_tab key_fn_##func = {func} //串表尾 // +---------+-------+ +---------------------+---------------------+ // 串表宏 一个表员(结构体)数据 按键模块：key.c void ktab_front(uint8_t key, uint8_t action, uint32_t time) {} void ktab_limit(uint8_t key, uint8_t action, uint32_t time) {} KEY_FRONT_EXPORT(ktab_front); //串表头 KEY_LIMIT_EXPORT(ktab_limit); //串表尾 void key_scan(void) { ... const struct key_fun_tab *p_key; //按键有动作时回调列表通知其它模块（由编译器维护列表内容） for (p_key=\u0026key_fn_ktab_front+1; p_key\u003c\u0026key_fn_ktab_limit; p_key++) { (*(p_key-\u003epfun))(key, action, time); } ... } 界面模块： //---加入串表--- include \"key.h\" void lcd_key_callback(uint8_t key, uint8_t action, uint32_t time) { if ((key \u003e= KEYNO_K1) \u0026\u0026 (key \u003c= KEYNO_K4)) { key -= KEYNO_K1; if ((action == KEYAT_1CLICK/*单击*/) || (action == KEYAT_2CLICK/*双击*/)) { if (time == 0) /*短按,非长按*/ { ....//收到按键单/双击动作 } } } }//加入串表 KEY_TABLE_EXPORT(lcd_key_callback); //告知编译器将函数地址加入到串表 恢复出厂初始化模块： //---加入串表--- include \"key.h\" void frst_key_callback(uint8_t key, uint8_t action, uint32_t time) { if (key == KEYNO_FRST) { if (action == KEYAT_1CLICK/*单击*/) { if (time == 5000) /*长按5秒*/ { ....//收到按键长按5秒动作 } } } }//加入串表 KEY_TABLE_EXPORT(frst_key_callback); //告知编译器将函数地址加入到串表 ","date":"2021-06-22","objectID":"/20210622/:0:3","tags":["attribute"],"title":"attribute-section 编译属性-数据拼接","uri":"/20210622/"},{"categories":["linux"],"content":"linux 中文输入工具的安装与使用","date":"2021-06-17","objectID":"/20210617/","tags":["输入法","linux 工具/应用"],"title":"linux 中文输入工具","uri":"/20210617/"},{"categories":["linux"],"content":"输入法简介 在 linux 系统下，我们必然要进行文本编辑，必然要输入中文，必然使用到输入法，中国常用的输入法有五笔和拼音。linux 系统文字输入包含两部分：输入法框架（系统）、输入法引擎（五笔）。因为输入法需要把文字显示出来，所以需要我们第一件事就是安装语言包。下面将介绍中文输入法的安装方法： ","date":"2021-06-17","objectID":"/20210617/:0:1","tags":["输入法","linux 工具/应用"],"title":"linux 中文输入工具","uri":"/20210617/"},{"categories":["linux"],"content":"Ubuntu 平台 1、语言包的安装 输入法得出来的只是文字编码，要把文字显示出来，则要调用系统的语言包（例如：简体中文语音包、日文语音包等），所以首先需要我们在系统安装语言包。 安装语言包：System Settings → Language Support → Language → Install/Remove Languages → 勾选 Chine(simplified) → Apply 2、输入法的安装 要想输入非英文，则需要安装另一个输入架构：IBus (“Intelligent Input Bus”) 是一个输入法框架，一个输入非英语字符的系统。 有了框架，还需要具体的输入法引擎，例如：中文引擎之ibus-pinyin(拼音) ibus-table-wubi(五笔)，日文引擎之ibus-anthy等。 除了 IBus，还有 Fcitx（Free Chinese Input Toy for X）、Fcitx5输入法框架，具体请上网了解。 IBus介绍 sudo apt-get install ibus ibus-clutter ibus-gtk ibus-gtk3 ibus-qt4 #安装IBus框架 im-config -s ibus #启用IBus框架 sudo apt-get install ibus-table-wubi #安装五笔引擎 sudo apt-get install ibus-pinyin #安装拼音引擎 （根据实际决定是否安装） sudo apt-get install ibus-googlepinyin #安装谷歌拼音引擎（根据实际决定是否安装） sudo apt-get install ibus-sunpinyin #安装sun拼音引擎 （根据实际决定是否安装） killall ibus-daemon #关闭IBus守护进程 ibus-daemon -drx #打开IBus守护进程 以及重启系统或者注销当前账户 3、输入法的配置 配置系统使用 IBus 输入法系统和具体输入法，然后设置系统显示输入法图标、设置转入法切换快速键等。 选择输入法系统：System Settings → Language Support → Keyboard input method system → 勾选IBus 添加具体输入法：System Settings → Text Entry → + → Chinese(....) → Add添加输入法，勾选 Show current input source in the menu bar，则会在系统界面右上角显示输入法切换图标。 sudo ibus-setup #设置ibus框架（此步貌似不用，input method → 貌似同上面重复操作） ","date":"2021-06-17","objectID":"/20210617/:0:2","tags":["输入法","linux 工具/应用"],"title":"linux 中文输入工具","uri":"/20210617/"},{"categories":["linux"],"content":"linux 网络文件系统 nfs 的安装与使用","date":"2021-06-17","objectID":"/20210620/","tags":["NFS","linux 工具/应用"],"title":"linux 网络文件系统 nfs","uri":"/20210620/"},{"categories":["linux"],"content":"NFS 的简介 NFS 就是 Network File System 的缩写，即网络文件系统，它最大的功能就是可以通过网络，让不同的机器、不同的操作系统可以共享彼此的文件。nfs 服务端相当于远程存储器，客户端像挂载 U 盘一样使用它。 网文： Ubuntu16.04安装nfs的两种方式 ","date":"2021-06-17","objectID":"/20210620/:0:1","tags":["NFS","linux 工具/应用"],"title":"linux 网络文件系统 nfs","uri":"/20210620/"},{"categories":["linux"],"content":"Ubuntu 平台 1、nfs 的安装 nfs 需要 RPC 服务，事先要安装 RPC 服务程序。RPC 服务器的 portmap 进程维护着一张 RPC 程序号到 Internet 端口号之间的映射表，它的字段包括程序号、版本号、所用协议、端口号和服务名，portmap 进程通过这张映射表来提供程序号-端口号之间的转化功能。 sudo apt-get install portmap #依赖的RPC服务安装 sudo apt-get install nfs-kernel-server #nfs服务端安装 sudo apt-get install nfs-common #nfs客户端安装 2、nfs 的配置 我们要共享服务端哪个文件夹，需要通过配置文件进行配置，例如配置是否可读写、是否指定客户端访问等。 sudo gedit /etc/exports #打开exports配置文件（具体配置内容请看下面介绍） sudo chmod 777 /home/xiaomi/nfs #修改文件(夹)权限,确保其权限正确性（事先创建的文件夹） #在exports配置文件加入内容： /home/xiaomi/nfs *(rw,sync,no_root_squash) #/home/xiaomi/nfs共享出去,所有客户端都可访问和读写 #[rw ] 读/写权限（如果ro:只读）； #[sync ] 数据同步写入内存和硬盘； #[no_root_squash ] NFS服务器共享目录用户的属性； #[no_subtree_check] 不检查父目录的权限。 #也可共享给指定网段的客户端: #/home/xiaomi/nfs 192.168.2.*(rw,sync,no_root_squash) 3、nfs 的开启 nfs 服务端安装后，需要我们手动启动运行，否则客户端无法连接服务端。 如果开启了系统防火墙（Firewall）将可能影响 nfs 服务，请关闭它（需要重启设备）： ● sudo ufw disable #关闭防火墙 ● sudo ufw status #查看防火墙状态 sudo /etc/init.d/portmap restart #重启RPC服务 sudo /etc/init.d/nfs-kernel-server restart #重启nfs服务 showmount -e #查看共享目录 #其它常用命令： sudo /etc/init.d/nfs-kernel-server start #启动nfs服务 sudo /etc/init.d/nfs-kernel-server stop #停止nfs服务 sudo /etc/init.d/nfs-kernel-server restart #重启nfs服务 sudo /etc/init.d/nfs-kernel-server status #查看nfs服务当前状态 #如果运行中: nfsd running 4、nfs 的挂载 与挂载 U 盘一样挂载即可，成功后所有操作与本地操作完全一样。当不需要操作时，取消挂载。 sudo mount -t nfs -o nolock 192.168.2.28:/home/xiaomi/nfs /mnt #将另一台机的/home/xiaomi/nfs目录挂载到本机/mnt目录下 #[-t nfs ] UNIX(LINUX) 文件网络共享 #[-o nolock] 不使用NFS文件锁(原因:很多嵌入式设备的根文件系统中不带portmap) umount /mnt #取消挂载（注：要在其它路径操作，否则系统提示忙不能取消挂载） ","date":"2021-06-17","objectID":"/20210620/:0:2","tags":["NFS","linux 工具/应用"],"title":"linux 网络文件系统 nfs","uri":"/20210620/"},{"categories":["linux"],"content":"linux 网络终端工具 ssh 的安装与使用","date":"2021-06-17","objectID":"/20210619/","tags":["SSH","linux 工具/应用"],"title":"linux 网络终端工具 ssh","uri":"/20210619/"},{"categories":["linux"],"content":"SSH 的简介 SSH 为 Secure Shell 的缩写，由 IETF 的网络工作小组（Network Working Group）所制定。SSH 为建立在应用层和传输层基础上的安全协议，而传统的网络服务程序（如：FTP、POP 和 Telnet） 则是不安全的。因为它们在网络上用明文传送数据、用户帐号和用户口令，很容易受到中间人（man-in-the-middle）攻击方式的攻击。我们调试 ARM 开发板时，常用串口作为调试终端；当使用 SSH 连接时，就是网络调试终端机（开发板为服务端，电脑为客户端），如果开发板有广域网 IP，则可以实现远程网络调试（远程网络终端）。 网文： SSH的安装及使用 ","date":"2021-06-17","objectID":"/20210619/:0:1","tags":["SSH","linux 工具/应用"],"title":"linux 网络终端工具 ssh","uri":"/20210619/"},{"categories":["linux"],"content":"Ubuntu 平台 1、ssh 的安装 SSH 包含服务端和客户端，原版 SSH 服务端是要收费的，因为受版权和加密算法的限制，现在很多人都转而使用 OpenSSH。OpenSSH 是 SSH 的替代软件，而且是免费的。Ubuntu 缺省已经安装了客户端（如果没安装则参考下面方法安装），但服务端需要我们手动安装。 #SSH客户端安装 sudo apt-get install ssh #安装SSH客户端（其服务端非免费） sudo apt-get install openssh-client #安装SSH客户端（OpenSSH是SSH的替代软件，而且是免费的，推荐使用） #SSH服务端安装 sudo apt-get install openssh-server #安装SSH服务端 2、ssh 的配置 一般情况下，不需要修改相关配置，如果需要开放或关闭一些权限，则就需要我们修改 SSH 服务端相关配置内容。 sudo gedit /etc/ssh/sshd_config #配置SSH服务端（常规配置内容请看下面介绍） #常规配置内容 Port 22 #连接端口 （默认：22） Protocol 2,1　#如果删除“,1”，只允许 SSH2 方式的连接 ServerKeyBits 1024 #定义服务端密匙的位数（默认：1024） PermitRootLogin prohibit-password #登记方式 （yes:允许root用户登录） PermitEmptyPasswords no　#禁止空密码进行登录 （默认：no ） PasswordAuthentication yes #允许密码方式的登录 （默认：yes） PubkeyAuthentication yes #允许ssh的公钥登录验证（默认：yes） RSAAuthentication yes #允许RSA登录验证 （默认：yes） 3、ssh 的开启 SSH 服务端安装后，需要我们手动启动运行，否则客户端无法连接服务端。 如果开启了系统防火墙（Firewall）将可能影响 SSH 服务，请关闭它（需要重启设备）： ● sudo ufw disable #关闭防火墙 ● sudo ufw status #查看防火墙状态 Linux系统中设置开机自动运行的两种方法 linux设置开机启动项两种方式 sudo /etc/init.d/ssh start #启动SSH服务端 ps -e | grep sshd #查看SSH服务端进程（如果有[sshd]表明启动成功） #其它常用命令： sudo /etc/init.d/ssh start #启动SSH服务端 sudo /etc/init.d/ssh restart #重启SSH服务端（例如修改配置后需要重启一下） sudo /etc/init.d/ssh stop #关闭SSH服务端 #或者 sudo service ssh start #启动SSH服务端 sudo service ssh restart #重启SSH服务端（例如修改配置后需要重启一下） sudo service ssh stop #关闭SSH服务端 #开机自动启动ssh服务的方法： sudo gedit /etc/rc.local #打开启动文件，在文件中加入: /etc/init.d/ssh start 4、ssh 的登录 SSH 登录主要有两方式（注：由服务端配置决定），一是使用账号及密码登陆，二是使用秘钥文件登陆。 关于 SSH 秘钥有两个文件：id_rsa（私钥 private key）和 id_rsa.pub（公钥 public key）。公钥相当于锁，私钥相当于钥匙，要想做到 SSH 免密登录，我们要先将锁装到服务器，然后客户端就可以利用这个钥匙开锁了。即是服务器装锁（公钥），客户端拿钥匙（私钥）。 在创建秘钥中，先提示存储路径再要求设置私钥密码，此密钥锁码表示在使用私钥时必须输入，这样就可以保护私钥不被盗用。当然，也可以留空，实现无密码登录（注：个人使用一般是无密码登录）。 在 win 系统下的 SecureCRT 终端机软件如何使用私钥登录 SSH，配置：选项 → 会话选项 → 连接/SSH2 → 右窗口选择公钥 → 属性，在打开窗口的使用身份或证书文件加入之前制作的私钥文件（如：D:\\Downloads\\id_rsa）。（如图） 网文： SecureCRT通过密钥进行SSH登录 #账号密码登陆 ssh root@192.168.1.20 #SSH客户端使用root超级用户登录（注：需要服务端开启权限） ssh xiaomi@192.168.1.20 #SSH客户端使用账号为xiaomi登录（之后按提示输入密码即可） ssh -p 1234 xiaomi@192.168.1.20 #SSH客户端使用指定端口1234及账号xiaomi登录 exit #SSH客户端登出 #秘钥文件登陆 -\u003e 制作密钥对（本例在服务器上制作） ssh-keygen #创建SSH默认RSA秘钥（弹出的提示全都回车确认即可，秘钥存储路径在弹出信息有指出） ssh-keygen -t rsa #创建SSH指定RSA秘钥（在用户的.ssh目录下发现id_rsa,id_rsa.pub就是创建的秘钥） #秘钥文件登陆 -\u003e 在服务器上安装公钥 cd ~/.ssh #进入秘钥存储路径 cat id_rsa.pub \u003e\u003e authorized_keys #在服务器上安装公钥（authorized /ˈɔːθəraɪzd/ 经授权的） chmod 600 authorized_keys #修改文件(夹)权限,确保其权限正确性 chmod 700 ~/.ssh #修改文件(夹)权限,确保其权限正确性 #秘钥文件登陆 -\u003e（本例在服务器上使用另一个终端机作为客户端登录） ssh -i ~/.ssh/id_rsa xiaomi@192.168.1.20 #SSH客户端使用秘钥文件登陆（-i 指定秘钥文件） 5、ssh 的sftp功能 sftp 为 SSH 的一部分，我们可以使用它来实现服务端与客户端之间传输文件。与 SSH 一样，使用 sftp 客户端登录服务端（不要在 SSH 客户端里直接使用命令 sftp 登录服务端，否则就是本地与远程设备都是服务端了）。在 win 系统下如何在 SecureCRT 终端机软件打开 sftp 服务？首先使用 SSH 建立连接后，配置：选项 → 会话选项 → 连接/SSH2/SFTP标签页 → 右窗口配置本地目录与远程目录，然后右键点击 SSH 终端窗口标签 → 连接SFTP标签页，即可打开 SFTP 终端机。（如图） sftp -oPort=22 xiaomi@192.168.1.20 #sftp客户端登录服务端（端口:22, 账号:xiaomi, IP:192.168.1.20） put /etc/md5.c /tmp #sftp客户端上传文件： 客户端 /etc/md5.c -\u003e 服务端 /tmp（路径） get /etc/md5.c /home/omd #sftp客户端下载文件： 服务端 /etc/md5.c -\u003e 客户端 /home/omd（路径） put -r /etc/hosts /tmp #sftp客户端上传文件夹：客户端 /etc/hosts -\u003e 服务端 /tmp get -r /etc/hosts /home/omd #sftp客户端下载文件夹：服务端 /etc/hosts -\u003e 客户端 /home/omd ls #sftp客户端查看远程目录文件 lls #sftp客户端查看本地目录文件 cd abc #sftp客户端进入远程目录路径abc lcd abc #sftp客户端改变本地目录路径abc pwd #sftp客户端查看远程所在路径 lpwd #sftp客户端查看本地所在路径 mkdir abc #sftp客户端创建远程文件夹 lmkdir abc #sftp客户端创建本地文件夹 quit #sftp客户端登出 发现问题： 实际使用中发现get -r下载文件夹出现有些文件多了些回车符，不明是什么原因。 无法下载隐藏文件(夹)，例如：git 仓库文件夹.git 解决方法： 目前想到的解决办法，就是使用tar压缩文件夹，再下载压缩文件。 ","date":"2021-06-17","objectID":"/20210619/:0:2","tags":["SSH","linux 工具/应用"],"title":"linux 网络终端工具 ssh","uri":"/20210619/"},{"categories":["linux"],"content":"linux 纯文本编辑器 vi 的基本使用","date":"2021-06-16","objectID":"/20210616/","tags":["vi/vim","linux 工具/应用"],"title":"linux 纯文本编辑器 vi","uri":"/20210616/"},{"categories":["linux"],"content":"前言 vi 编辑器是所有 Unix 及 Linux 系统下标准的文本编辑器，相当于 windows 系统中的记事本一样，它是我们使用 Linux 系统不能缺少的工具。而 vim 视为 vi 的升级版本，基础功能完全一样，只是一些功能的增强以及可用不同的颜色对文本关键字进行加亮，所以其更适合编写程序使用。 ","date":"2021-06-16","objectID":"/20210616/:0:1","tags":["vi/vim","linux 工具/应用"],"title":"linux 纯文本编辑器 vi","uri":"/20210616/"},{"categories":["linux"],"content":"简介 vi 工作模式 vi 编辑器是所有 Unix 及 Linux 系统下标准的纯文本编辑器。对 Unix 及 Linux 系统的任何版本，vi 编辑器是完全相同的。 官方网站：https://www.vim.org/ vi 分为三种工作状态： 1、命令模式（command mode）； 2、插入模式（insert mode）； 3、底行模式（last line mode）。 工作模式 应用情景 命令模式 控制屏幕光标的移动，对字符/字段/行的删除/复制/粘贴操作 插入模式 纯文本输入 底行模式 文件保存/退出 vi，设置编辑环境，查找/替换字符串操作 工作模式 切换方法 命令模式 按 i 进入【插入模式】； 按 : 进入【底行模式】。 插入模式 按ESC进入【命令模式】 底行模式 按ESC进入【命令模式】 ","date":"2021-06-16","objectID":"/20210616/:0:2","tags":["vi/vim","linux 工具/应用"],"title":"linux 纯文本编辑器 vi","uri":"/20210616/"},{"categories":["linux"],"content":"使用 vi 编辑文本 在终端机上输入vi命令即可进入 vi 编辑器编辑对应的文件，具体操作如下： sudo vi /home/root/read.txt # 使用 vi 编辑 read.txt 文档 #【命令模式】-------------------------------------- #『光标』+++++++ # [h ] 光标左移 # [j ] 光标下移 # [k ] 光标上移 # [l ] 光标右移 # [^ ] 光标移到行首 # [$ ] 光标移到行尾 # [5- ] 光标向上移动5行 # [5+ ] 光标向下移动5行 # [5G ] 光标移动到第5行 #『插入』+++++++ # [i ] 在光标前面插入【进入插入模式】 # [I ] 所在行最前插入【进入插入模式】 # [a ] 在光标后面插入【进入插入模式】 # [A ] 所在行最后插入【进入插入模式】 #『删除』+++++++ # [x ] 删除光标后[一个字符] # [X ] 删除光标前[一个字符] # [6x ] 删除光标后[六个字符] # [8X ] 删除光标前[八个字符] # [dd ] 删除光标所在的[一行] # [9dd] 删除光标所在行开始的[九行] #『复制』+++++++ # [yw ] 复制光标后[一段字段] (以空格或符号分隔开的字段!!) # [yy ] 复制光标所在的[一行] # [5yw] 复制光标后[五段字段] (以空格或符号分隔开的字段!!) # [9yy] 复制光标所在行开始的[九行] #『粘贴』+++++++ # [p ] 粘贴 #『撤消』+++++++ # [u ] 最后一次修改[撤消\u0026重做] # [Ctrl + r] 可多次[撤消] # #【底行模式】-------------------------------------- #『光标』+++++++ # [:5 ] 光标移动到第5行(要按回车执行,下面操作都一样) # [:set nu ] 显示行号 # [:set nonu] 不显示行号 #『查找』+++++++ # [/ab] 向下查找\"ab\"字符串，[n]继续查找下一个 # [?ab] 向上查找\"ab\"字符串，[n]继续查找上一个 #『替换』+++++++ # [: s/str1/str2/g] 所在行中所有 str1 字符串替换为 str2 # [:% s/str1/str2/g] 从[首行]到[最尾]行中所有\"str1\"字符串替换为\"str2\" # [:1,$ s/str1/str2/g] 第[01]行到[最尾]行中所有\"str1\"字符串替换为\"str2\" # [:6,20 s/str1/str2/g] 第[06]行到第[20]行中所有\"str1\"字符串替换为\"str2\" # [:.,20 s/str1/str2/g] [光标]行到第[20]行中所有\"str1\"字符串替换为\"str2\" # [:.,$-5 s/str1/str2/g] [光标]行到尾[05]行中所有\"str1\"字符串替换为\"str2\" #『退出』+++++++ └→g表示替换所有匹配项 # [:q!] 不保存退出 # [:wq] 保存退出 # [:w ] 保存文档(但不退出) # [:w filename] 另存为叫filename的文件(但不退出) 补充说明： vi 的查找与替换操作支持正则表达式，但是不支持限定操作（主要包括：{}、?、+、|），没能很好体现正则表达式优势。关于正则表达式相关语法知识，请移步《正则表达式语法》！ ","date":"2021-06-16","objectID":"/20210616/:0:3","tags":["vi/vim","linux 工具/应用"],"title":"linux 纯文本编辑器 vi","uri":"/20210616/"},{"categories":["software","MCU"],"content":"FreeRTOS 实时操作系统应用笔记","date":"2021-06-15","objectID":"/20210615/","tags":["FreeRTOS","RTOS"],"title":"FreeRTOS 实时操作系统应用笔记","uri":"/20210615/"},{"categories":["software","MCU"],"content":"前言 操作系统一般分为两种：实时操作系统 RTOS（Real Time Operating System）和 分时操作系统 TSOS（Time Sharing Operating System）。对于工控方面的编程，不是“裸跑”就是使用 RTOS 编程。本文是 FreeRTOS 操作系统 API 快速应用手册，也就是我们程序员Ctrl+C及Ctrl+V的编程过程。本文主要介绍动态 API 接口函数，静态 API 接口函数以后再补上。 ","date":"2021-06-15","objectID":"/20210615/:0:1","tags":["FreeRTOS","RTOS"],"title":"FreeRTOS 实时操作系统应用笔记","uri":"/20210615/"},{"categories":["software","MCU"],"content":"FreeRTOS 简介 点击展开内容 FreeRTOS 是 RTOS 系统的一种，由 Richard Barry 于 2003 年推出，其十分的小巧，可以在资源有限的微控制器中运行（当然，FreeRTOS 不仅局限于在微控制器中使用）。从文件数量上来看 FreeRTOS 要比 uC/OSII 和 uC/OSIII 小的多。FreeRTOS 操作系统是完全免费（MIT 开源许可证）的操作系统，具有源码公开、可移植、可裁减、调度策略灵活的特点，可以方便地移植到各种单片机上运行。FreeRTOS 的作者 Richard 于 2017 年加入了亚马逊（Amazon），并将 FreeRTOS 从 V9 版本升级至 V10 版本。同时，也推出了Amazon FreeRTOS，它基于 FreeRTOS 内核，并且增加了重要的 AWS 支持和 IoT 使用案例支持。例如，可轻松安全地将设备连接到云以及本地网络的软件库，这些库已经开源。所以，现在 FreeRTOS 将由亚马逊管理。 FreeRTOS 特点： FreeRTOS 的内核支持抢占式，合作式和时间片调度。 提供了一个用于低功耗的 Tickless 模式。 系统的组件在创建时可以选择动态或者静态的 RAM，比如任务、消息队列、信号量、软件定时器等等。 FreeRTOS-MPU 支持 Corex-M 系列中的 MPU 单元，如 STM32F429。 FreeRTOS 系统简单、小巧、易用，通常情况下内核占用 4k-9k 字节的空间。 高可移植性，代码主要 C 语言编写。 高效的软件定时器。 强大的跟踪执行功能。 堆栈溢出检测功能。 任务数量不限。 任务优先级不限。 官方 API 手册 FreeRTOS 官网 FreeRTOS 仓库 Amazon FreeRTOS 官网 Amazon FreeRTOS 仓库 FreeRTOS 基础篇 FreeRTOS 高级篇 ","date":"2021-06-15","objectID":"/20210615/:0:2","tags":["FreeRTOS","RTOS"],"title":"FreeRTOS 实时操作系统应用笔记","uri":"/20210615/"},{"categories":["software","MCU"],"content":"基本功能配置 点击展开内容 //主要功能头文件 #include \"FreeRTOSConfig.h\"#include \"FreeRTOS.h\"#include \"task.h\"#include \"queue.h\"#include \"semphr.h\"#include \"event_groups.h\" //基本功能配置 FreeRTOSConfig.h ","date":"2021-06-15","objectID":"/20210615/:0:3","tags":["FreeRTOS","RTOS"],"title":"FreeRTOS 实时操作系统应用笔记","uri":"/20210615/"},{"categories":["software","MCU"],"content":"临界中断开关 点击展开内容 //配置 (FreeRTOSConfig.h) #define configMAX_SYSCALL_INTERRUPT_PRIORITY 191 //有一个临界区中断优先级（数值越低优先级越低） //线程中调用 taskENTER_CRITICAL(); //\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e taskEXIT_CRITICAL(); //\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c //中断中调用 UBaseType_t uxSavedInterruptStatus; uxSavedInterruptStatus = taskENTER_CRITICAL_FROM_ISR(); //\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e taskEXIT_CRITICAL_FROM_ISR(status_value); //\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c 网文：FreeRTOS 系统内核控制函数与临界段保护 ","date":"2021-06-15","objectID":"/20210615/:0:4","tags":["FreeRTOS","RTOS"],"title":"FreeRTOS 实时操作系统应用笔记","uri":"/20210615/"},{"categories":["software","MCU"],"content":"调度器上解锁 点击展开内容 //使用 vTaskSuspendAll(); //\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e xTaskResumeAll(); //\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c ","date":"2021-06-15","objectID":"/20210615/:0:5","tags":["FreeRTOS","RTOS"],"title":"FreeRTOS 实时操作系统应用笔记","uri":"/20210615/"},{"categories":["software","MCU"],"content":"系统延时函数 点击展开内容 //配置 (FreeRTOSConfig.h) #define configUSE_16_BIT_TICKS 0 //32位类型节拍计数器 #define configTICK_RATE_HZ ((TickType_t)100) //系统节拍频率（10毫秒一个节拍） //使用 vTaskDelay(50); //相对节拍延时（调用那一刻开始计时。） TickType_t tick = xTaskGetTickCount(); //获取节拍计数（获取那一刻开始计时，） vTaskDelayUntil(\u0026tick, 50); //绝对节拍延时（之后以tick增量计时。） ","date":"2021-06-15","objectID":"/20210615/:0:6","tags":["FreeRTOS","RTOS"],"title":"FreeRTOS 实时操作系统应用笔记","uri":"/20210615/"},{"categories":["software","MCU"],"content":"线程基本操作 点击展开内容 //配置 #define NETWORK_THREAD_STK_SIZE 512 //线程堆栈大小 #define NETWORK_THREAD_PRIO 2 //线程优先级（数值越低优先级越低） //创建 (动态线程) TaskHandle_t *const p_network; //动态线程句柄 xTaskCreate(network_thread_entry, //动态线程函数 \"network\", //动态线程名称 NETWORK_THREAD_STK_SIZE, //动态线程堆栈大小 NULL, //动态线程入口 NETWORK_THREAD_PRIO, //动态线程优先级 p_network); //动态线程句柄（当填 NULL 表示不需要获取） //使用 UBaseType_t pri = uxPriorit = uxTaskPriorityGet(); //获取当前线程优先级 vTaskPrioritySet(NULL, 1); //修改当前线程优先级（如果指出线程句柄,则表示指定线程） taskYIELD(); //主动让出cpu让同优先级的其他task获得cpu vTaskDelete(p_network); //删除线程（自杀最后还要 return 退出） //线程 void vAppTask(void *pvParameters) { for(;;) { vTaskDelay(50); } } 网文：FreeRTOS 修改任务优先级 ","date":"2021-06-15","objectID":"/20210615/:0:7","tags":["FreeRTOS","RTOS"],"title":"FreeRTOS 实时操作系统应用笔记","uri":"/20210615/"},{"categories":["software","MCU"],"content":"任务通知操作 点击展开内容 相比于消息队列、信号量、事件组的应用，使用任务通知速度更快、内存更少、执行更高效。任务通知只能由发送方指定线程，与线程耦合在一起。 //eSetBits:事件标志, //eIncrement:计数信号量, //eSetValueWithOverwrite:直接写覆盖消息值, //eSetValueWithoutOverwrite:不写覆盖消息值(写失败返回pdFAIL), //eNoAction:通知线程但不更新通知值。 BaseType_t true /*= pdTRUE*/; uint32_t u32d; //二值信号量形式通知 true = xTaskNotifyGive(p_network/*线程*/); //以【二值信号量形式】通知任务 true = xTaskNotify(p_network/*线程*/, 0/*无效*/, eIncrement); //以【二值信号量形式】通知任务（等同 xTaskNotifyGive()） true = xTaskNotifyAndQuery(p_network, 0/*无效*/, eIncrement, \u0026u32d);//以【二值信号量形式】通知任务（相比 xTaskNotify() 多了个回传更新前的通知值） u32d = ulTaskNotifyTake(pdTRUE/*读后清零通知值*/, portMAX_DELAY); //以【二值信号量形式】获取通知（最终的通知值：清零后的值） //计数信号量形式通知 true = xTaskNotifyGive(p_network/*线程*/); //以【计数信号量形式】通知任务 true = xTaskNotify(p_network/*线程*/, 0/*无效*/, eIncrement); //以【计数信号量形式】通知任务（等同 xTaskNotifyGive()） u32d = ulTaskNotifyTake(pdFALSE/*计数信号量减1*/, portMAX_DELAY); //以【计数信号量形式】获取通知（最终的通知值：减一后的值） //事件标志形式通知 true = xTaskNotify(p_network/*线程*/, 0x00000001, eSetBits); //以【事件标志形式】通知任务 true = xTaskNotifyAndQuery(p_network, 0x00000001, eSetBits, \u0026u32d); //以【事件标志形式】通知任务（相比 xTaskNotify() 多了个回传更新前的通知值） true = xTaskNotifyWait(0xFFFFFFFE/*获取前清bit31~1标志*/, 0x00000001/*获取后清bit0标志*/, \u0026u32d/*获取前后两个清除操作中间的值*/, portMAX_DELAY); //以【事件标志形式】获取通知 //在中断里通知任务 BaseType_t xHigherPriorityTaskWoken = pdFALSE; //在中断里以【计数信号量形式】通知任务(中断-\u003e线程) vTaskNotifyGiveFromISR(p_network/*线程*/, \u0026xHigherPriorityTaskWoken); portYIELD_FROM_ISR(xHigherPriorityTaskWoken); //需要调用本函数执行一次上下文切换 BaseType_t xHigherPriorityTaskWoken = pdFALSE; //在中断里以【事件标志形式】通知任务(中断-\u003e线程) true = xTaskNotifyFromISR(p_network/*线程*/, 0x00000001, eSetBits/*事件标志*/, \u0026xHigherPriorityTaskWoken); portYIELD_FROM_ISR(xHigherPriorityTaskWoken); //如果 true == pdTRUE, 则要调用本函数执行一次上下文切换 BaseType_t xHigherPriorityTaskWoken = pdFALSE; //在中断里以【事件标志形式】通知任务(中断-\u003e线程) true = xTaskNotifyAndQueryFromISR(p_network/*线程*/, 0x00000001, eSetBits/*事件标志*/, \u0026u32d, \u0026xHigherPriorityTaskWoken); //（相比 xTaskNotifyFromISR() 多了个回传更新前的通知值） portYIELD_FROM_ISR(xHigherPriorityTaskWoken); //如果 true == pdTRUE, 则要调用本函数执行一次上下文切换 网文：FreeRTOS 任务通知 ","date":"2021-06-15","objectID":"/20210615/:0:8","tags":["FreeRTOS","RTOS"],"title":"FreeRTOS 实时操作系统应用笔记","uri":"/20210615/"},{"categories":["software","MCU"],"content":"信号量操作 点击展开内容 关于二值信号量与计数信号量无本质区别，当计数信号量最大计数值为 1 及初始值为 0 时，即是二值信号量。 //配置 (FreeRTOSConfig.h) #define configSUPPORT_DYNAMIC_ALLOCATION 1 //开启信号量 #define INCLUDE_vTaskSuspend 1 //如果需要永远等待-\u003eportMAX_DELAY //建删 SemaphoreHandle_t Sem_Handle = NULL; //信号量句柄 Sem_Handle = xSemaphoreCreateBinary(); //动态【二值信号量】创建 Sem_Handle = xSemaphoreCreateCounting(0xFFFF, 0); //动态【计数信号量】创建（入口：最大值,初始值） vSemaphoreDelete(Sem_Handle); //信号量删除（如果有任务阻塞在这个信号量上，则这个信号量不要删除!） //使用 BaseType_t true /*= pdTRUE*/; true = xSemaphoreGive(Sem_Handle); //信号量释放 （线程与线程） true = xSemaphoreTake(Sem_Handle, portMAX_DELAY); //信号量获取 （线程与线程）(非死等必要判断返回值:pdTRUE) //在中断里使用 BaseType_t xHigherPriorityTaskWoken = pdFALSE; //在中断里信号量释放（中断-\u003e中断)或(中断-\u003e线程) true = xSemaphoreGiveFromISR(Sem_Handle, \u0026xHigherPriorityTaskWoken); portYIELD_FROM_ISR(xHigherPriorityTaskWoken); //如果 true == pdTRUE, 则要调用本函数执行一次上下文切换 BaseType_t true /*= pdTRUE*/; BaseType_t xHigherPriorityTaskWoken; //在中断里信号量获取（中断-\u003e中断) true = xSemaphoreTakeFromISR(Sem_Handle, \u0026xHigherPriorityTaskWoken); 网文：FreeRTOS 信号量分析 ","date":"2021-06-15","objectID":"/20210615/:0:9","tags":["FreeRTOS","RTOS"],"title":"FreeRTOS 实时操作系统应用笔记","uri":"/20210615/"},{"categories":["software","MCU"],"content":"互斥量操作 点击展开内容 关于可递归锁也可称为可重入锁，与非递归锁唯一的区别是：同一个线程可以多次获取同一个递归锁，不会产生死锁。而如果一个线程多次获取同一个非递归锁，则会产生死锁。还有需要注意：中断是不能使用互斥锁的！ //配置 (FreeRTOSConfig.h) #define configUSE_MUTEXES 1 //开启互斥量 #define configUSE_RECURSIVE_MUTEXES 1 //开启递归互斥量 #define INCLUDE_vTaskSuspend 1 //如果需要永远等待-\u003eportMAX_DELAY //建删 SemaphoreHandle_t MuxSem_Handle = NULL; //信号量句柄 MuxSem_Handle = xSemaphoreCreateMutex(); //动态【互斥量】创建 MuxSem_Handle = xSemaphoreCreateRecursiveMutex(); //动态【递归互斥量】创建 vSemaphoreDelete(MuxSem_Handle); //信号量删除（如果有任务阻塞在这个信号量上，则这个信号量不要删除!） //使用 BaseType_t true /*= pdTRUE*/; true = xSemaphoreGive(MuxSem_Handle); //【互斥量】释放 true = xSemaphoreTake(MuxSem_Handle, portMAX_DELAY); //【互斥量】获取（portMAX_DELAY 表示永远等待）(非死等必要判断返回值:pdTRUE) true = xSemaphoreGiveRecursive(MuxSem_Handle); //【递归互斥量】释放 true = xSemaphoreTakeRecursive(MuxSem_Handle, portMAX_DELAY);//【递归互斥量】获取（portMAX_DELAY 表示永远等待）(非死等必要判断返回值:pdTRUE) 网文：可递归锁与非递归锁 ","date":"2021-06-15","objectID":"/20210615/:0:10","tags":["FreeRTOS","RTOS"],"title":"FreeRTOS 实时操作系统应用笔记","uri":"/20210615/"},{"categories":["software","MCU"],"content":"事件标志操作 点击展开内容 获取事件标志一般有两个分类操作：读后是否清除指定要读取的标志、当指定的标志全部触发时才读取。 //建删 EventGroupHandle_t xCreatedEventGroup = NULL; //动态事件句柄 xCreatedEventGroup = xEventGroupCreate(); //动态事件创建（返回 NULL 表示事件标志组创建失败） vEventGroupDelete(xCreatedEventGroup); //动态事件删除 //使用 EventBits_t bits; bits = xEventGroupSetBits(xCreatedEventGroup, 0x00000011); //事件标志设置（事件位置位之后的事件组值）（事件标志释放） bits = xEventGroupGetBits(xCreatedEventGroup); //事件标志获取（但不清除标志）（等同 bits = xEventGroupClearBits(xCreatedEventGroup, 0)） bits = xEventGroupClearBits(xCreatedEventGroup, 0x00000011); //事件标志清除（事件位清零之前的事件组值） bits = xEventGroupWaitBits(xCreatedEventGroup, 0x00000011, pdTRUE/*读后清除*/, pdTRUE /*当指定的条件全部成立时才触发*/, 10/*最长等待节拍数*/); //事件标志获取（返回值可以判断是否得到想要的标志位） bits = xEventGroupWaitBits(xCreatedEventGroup, 0x00000011, pdTRUE/*读后清除*/, pdFALSE/*当指定的条件中有成立都可触发*/, portMAX_DELAY/*永远等待*/);//事件标志获取（返回值可以判断是否得到想要的标志位） //在中断里使用 BaseType_t true /*= pdTRUE*/; BaseType_t xHigherPriorityTaskWoken = pdFALSE; //在中断里事件标志释放(中断-\u003e线程) true = xEventGroupSetBitsFromISR(xCreatedEventGroup, 0x00000011, \u0026xHigherPriorityTaskWoken); portYIELD_FROM_ISR(xHigherPriorityTaskWoken); //如果 true == pdTRUE, 则要调用本函数执行一次上下文切换 EventBits_t bits; BaseType_t true /*= pdTRUE*/; bits = xEventGroupGetBitsFromISR(xCreatedEventGroup); //事件标志获取（但不清除标志） true = xEventGroupClearBitsFromISR(xCreatedEventGroup, 0x00000011);//事件标志清除 网文：FreeRTOS 事件标志组 ","date":"2021-06-15","objectID":"/20210615/:0:11","tags":["FreeRTOS","RTOS"],"title":"FreeRTOS 实时操作系统应用笔记","uri":"/20210615/"},{"categories":["software","MCU"],"content":"消息队列操作 点击展开内容 投递消息一般分为两种：向队列尾部投递、向队列头部投递。FreeRTOS 的消息每次获取都是固定长度的信息（其获取函数是没有返回信息长度参数），所以如果用于传递变长的数据帧，则由应用自行处理。 //建删 QueueHandle_t xQueueHandle = NULL; xQueueHandle = xQueueCreate(20/*消息条数*/, 4/*单条大小*/); //创建消息 （单条大小:字节） vQueueDelete(xQueueHandle); //删除消息 vQueueAddToRegistry(xQueueHandle, \"msg name\"); //注册消息名称（仅仅用于调试） vQueueUnregisterQueue(xQueueHandle); //解除注册消息（仅仅用于调试） //使用 char msg[] = {1, 2, 3}; BaseType_t true /*= pdTRUE*/; true = xQueueReset(xQueueHandle); true = xQueueOverwrite(xQueueHandle, msg); //覆盖消息（仅仅适合只有一条消息的队列） true = xQueueSend(xQueueHandle, msg, portMAX_DELAY); //投递消息（等同 xQueueSendToBack()） true = xQueueSendToBack(xQueueHandle, msg, portMAX_DELAY); //【向队列尾部】投递消息 true = xQueueSendToFront(xQueueHandle, msg, portMAX_DELAY); //【向队列头部】投递消息 true = xQueueReceive(xQueueHandle, msg, portMAX_DELAY); //获取消息（返回 pdTRUE 表示获取到消息） true = xQueuePeek(xQueueHandle, msg, portMAX_DELAY); //查看消息（相比 xQueueReceive() 不会清除队列中读出的消息） UBaseType_t n = uxQueueMessagesWaiting(xQueueHandle); //查看入列信息数目（单位:条数） UBaseType_t n = uxQueueSpacesAvailable(xQueueHandle); //查看队列空闲数目（单位:条数） //在中断里使用 char msg[] = {1, 2, 3}; BaseType_t xHigherPriorityTaskWoken = pdFALSE; //在中断里覆盖消息(中断-\u003e中断)或(中断-\u003e线程)（仅仅适合只有一条消息的队列） true = xQueueOverwriteFromISR(xQueueHandle, msg, \u0026xHigherPriorityTaskWoken); portYIELD_FROM_ISR(xHigherPriorityTaskWoken); //如果 true == pdTRUE, 则要调用本函数执行一次上下文切换 char msg[] = {1, 2, 3}; BaseType_t xHigherPriorityTaskWoken = pdFALSE; //在中断里投递消息(中断-\u003e中断)或(中断-\u003e线程) true = xQueueSendFromISR(xQueueHandle, msg, \u0026xHigherPriorityTaskWoken); portYIELD_FROM_ISR(xHigherPriorityTaskWoken); //如果 true == pdTRUE, 则要调用本函数执行一次上下文切换 char msg[] = {1, 2, 3}; BaseType_t xHigherPriorityTaskWoken = pdFALSE; //在中断里【向队列尾部】投递消息(中断-\u003e中断)或(中断-\u003e线程) true = xQueueSendToBackFromISR(xQueueHandle, msg, \u0026xHigherPriorityTaskWoken); portYIELD_FROM_ISR(xHigherPriorityTaskWoken); //如果 true == pdTRUE, 则要调用本函数执行一次上下文切换 char msg[] = {1, 2, 3}; BaseType_t xHigherPriorityTaskWoken = pdFALSE; //在中断里【向队列头部】投递消息(中断-\u003e中断)或(中断-\u003e线程) true = xQueueSendToFrontFromISR(xQueueHandle, msg, \u0026xHigherPriorityTaskWoken); portYIELD_FROM_ISR(xHigherPriorityTaskWoken); //如果 true == pdTRUE, 则要调用本函数执行一次上下文切换 char msg[4]; BaseType_t xHigherPriorityTaskWoken = pdFALSE; //在中断里获取消息 true = xQueueReceiveFromISR(xQueueHandle, msg, \u0026xHigherPriorityTaskWoken); portYIELD_FROM_ISR(xHigherPriorityTaskWoken); //如果 true == pdTRUE, 则要调用本函数执行一次上下文切换 char msg[4]; BaseType_t xHigherPriorityTaskWoken = pdFALSE; //在中断里查看消息 true = xQueuePeekFromISR(xQueueHandle, msg, \u0026xHigherPriorityTaskWoken); portYIELD_FROM_ISR(xHigherPriorityTaskWoken); //如果 true == pdTRUE, 则要调用本函数执行一次上下文切换 true = xQueueIsQueueEmptyFromISR(xQueueHandle); //查看消息队列是否为空（返回 pdTRUE 表示为空） true = xQueueIsQueueFullFromISR(xQueueHandle); //查看消息队列是否为满（返回 pdTRUE 表示为满） UBaseType_t n = uxQueueMessagesWaitingFromISR(xQueueHandle);//查看入列信息数目（单位:条数） ","date":"2021-06-15","objectID":"/20210615/:0:12","tags":["FreeRTOS","RTOS"],"title":"FreeRTOS 实时操作系统应用笔记","uri":"/20210615/"},{"categories":["software","MCU"],"content":"动态内存操作 点击展开内容 //配置 (FreeRTOSConfig.h) #define configTOTAL_HEAP_SIZE ( ( size_t ) ( 17 * 1024 ) ) //动态内存大小定义（单位:字节） //使用 size_t size = xPortGetFreeHeapSize(); //获得FreeRTOS动态内存的剩余 void *pd = pvPortMalloc(1024); //申请动态内存 vPortFree(pd); //释放动态内存 // 五种动态内存管理方式简单总结如下，实际项目中，用户根据需要选择合适的文件： //（1）heap_1.c：五种方式里面最简单的，但是申请的内存不允许释放。 //（2）heap_2.c：支持动态内存的申请和释放，但是不支持内存碎片的处理，并将其合并成一个大的内存块。 //（3）heap_3.c：将编译器自带的malloc和free函数进行简单的封装，以支持线程安全，即支持多任务调用。 //（4）heap_4.c：支持动态内存的申请和释放，支持内存碎片处理，支持将动态内存设置在个固定的地址。 //（5）heap_5.c：在heap_4的基础上支持将动态内存设置在不连续的区域上。 网文：FreeRTOS 动态内存管理 网文：FreeRTOS 动态内存管理《heap_1.c》详解 ","date":"2021-06-15","objectID":"/20210615/:0:13","tags":["FreeRTOS","RTOS"],"title":"FreeRTOS 实时操作系统应用笔记","uri":"/20210615/"},{"categories":["linux"],"content":"linux 基本知识及基本命令使用","date":"2021-06-13","objectID":"/20210613/","tags":["命令","linux 工具/应用"],"title":"linux 基本命令使用","uri":"/20210613/"},{"categories":["linux"],"content":"一、认识linux linux发行版本 deb派系--桌面版系统 1、Debian（读音：‘debeen 待宾） 2、Ubuntu（读音：u’bʌntu 乌班图） 3、Deepin（读音：diːpin 低评） …… #〖安装本地软件包方法〗 sudo dpkg -i xxxx.deb #安装【本地软件包】 sudo dpkg -r xxxx #卸载【本地软件包】（保留配置）（不保留配置使用 -P 选项） sudo dpkg -l xxxx #显示软件的版本 #【安装远程软件包方法】 sudo apt-get install xxxx #安装软件包的最新版本 sudo apt-get remove xxxx #从系统中删除指定的软件包 sudo apt-get update #检测已安装软件包是否有更新（如果指定软件名则表示指定软件包是否有更新） sudo apt-get upgrade xxxx #升级指定的软件包(前提：先运行 update 检测)(而使用 dist-upgrade 则以更聪明的方式来解决更新过程中出现的软件依赖问题) sudo apt-cache list xxxx #从资源库中查询可用的软件包 sudo apt-cache search g++ #搜索单词为g++的软件包 sudo apt-cache show g++ #显示g++软件包详细信息 rpm派系--服务器系统 1、RedHat（读音：‘redhæt [红帽]） 2、CentOS（读音：sen’tus 圣斗士） 3、Fedora（读音：fɪ’dɔːrə 费多拉帽） …… #〖安装本地软件包方法〗 sudo rpm -ivh xxxx.rpm #安装【本地软件包】（其中 v 显示详细信息，h 显示安装进度） sudo rpm -e xxxx #卸载【本地软件包】 sudo rpm -Uvh xxxx.rpm #升级软件　（其中 v 显示详细信息，h 显示安装进度） #【安装远程软件包方法】 sudo yum install xxxx #安装软件包的最新版本 sudo yum remove xxxx #从系统中删除指定的软件包 sudo yum update xxxx #升级指定的软件包 sudo yum list #列出所有可安装的软件包（如果指定软件名则表示列出指定可安装的软件包） sudo yum list installed #列出已安装的软件包 sudo yum list updates #列出所有可更新的软件包 linux在线源码 如果想了解 linux 内核源代码，强烈推荐在 Bootlin 上阅读。 Linux 全称 GNU/Linux，是一种免费使用和自由传播的类 UNIX 操作系统，其内核由 Linus Benedict Torvalds（林纳斯·本纳第克特·托瓦兹）于 1991 年 10 月 5 日首次发布，它主要受到 Minix 和 Unix 思想的启发，是一个基于 POSIX 的多用户、多任务、支持多线程和多 CPU 的操作系统。它能运行主要的 Unix 工具软件、应用程序和网络协议。它支持 32 位和 64 位硬件。Linux 继承了 Unix 以网络为核心的设计思想，是一个性能稳定的多用户网络操作系统。Linux 有上百种不同的发行版，如基于社区开发的 debian、archlinux，和基于商业开发的 Red Hat Enterprise Linux、SUSE、Oracle Linux 等。 linux核心思想 ● linux 核心思想 首先记住这个：Linux 的核心思想即一切皆是文件，设备是文件，系统是文件。比如在我们插入一个 USB 设备，/etc 的目录下多一个 USB 设备的文件夹。而对 USB 所有的操作都是通过读写这个文件进行。脚本（Script /skrɪpt/）是存储在文件中的命令的集合，命令（Command /kə'mɑːnd/）是针对计算机的指令，终端/控制台（tty,Termial /'tɜːmɪnl//console /kən'səʊl/）是命令行接口，壳（Shell /ʃel/）是一个命令行解释器，内核（Kernel /'kɜːnl/）是 Linux 操作系统的核心。 ● linux 脚本解释器 Bash /bæʃ/是大多数 Linux 系统默认的 shell 脚本解释器（注：我们平时说 Linux 中有多少种 shell 其实指的就是其中存在几种 shell 脚本解释器），可以使用命令cat /etc/shells打开文件查看到系统可用的 shell 。在脚本文件中，我们常看到第一行内容为#!/bin/bash，表示告知系统使用哪个脚本解释器来执行脚本文件，即使用哪一种 shell 。（补充：Bourne Again shell /bʊən/ə'ɡen/ʃel/（简写为 Bash）（标记为#!/bin/bash）是 Bourne shell（标记为#!/bin/sh） 的扩展，与 Bourne shell 完全向后兼容，并且在 Bourne shell 的基础上增加、增强了很多特性。特别说明：#!/bin/bash这些信息在首行且必须使用\\n来换行，不能是\\r\\n之类的来换行，否则会提示 ^M 错误!!! ● linux 环境变量 shell 中变量分三种：内部变量、环境变量、用户变量。 内部变量：系统提供，不用定义，不可修改；（$$ $? $0 $# $* $@ $1 … $SHELL(当前使用的shell(路径)) $HOME(家目录)） 环境变量：系统提供，不用定义，可以修改，利用export将用户变量转为环境变量； 用户变量：用户定义，可以修改； 环境变量（environment variables /ɪn’vaɪrənmənt/‘veəriəbls/）一般是指在操作系统中用来指定操作系统运行环境的一些参数，其中一个目的是告诉系统知道应用程序所在哪个路径下，让系统可直接运行应用程序（如果应用程序已在系统标准位置下，则不需要增加环境变量。linux系统几个标准位置：/bin、/sbin、/usr/bin、/usr/sbin、/usr/local/bin 等）（Windown 系统使用分号分隔，而 linux 系统使用冒号分隔）。环境变量包括：系统环境变量和用户环境变量。环境变量配置推荐：如果要修改所有用户环境配置的话修改/etc/profile，修改单个用户的话修改~/.bashrc（如：开发板的 /root/.bashrc）。 1.1、export显示包括利用 export 将用户变量转为环境变量的 shell 变量。 1.2、echo $PATH命令为输出当前的 PATH 环境变量的值（以冒号分割不同路径） 1.3、export PATH=$PATH:/home/abc/mysql/bin可临时/永久配置环境变量（例子）。 2.1、/etc/environment整个系统环境变量，不能使用 export PATH，不建议改！ 2.2、/etc/profile所有用户环境变量，只在用户登录的时候读取一次。 2.3、/etc/bash.bashrc所有用户环境变量，每次运行 Shell 就会读取一次，影响效率。 2.4、~/.profile只针对当前用户，只在用户登录的时候读取一次（不同系统可能是：~/.bash_profile、~/.bash_login、~/.profile） 2.5、~/.bashrc只针对当前用户，每次运行 Shell 就会读取一次。 2.6、source xxxxxx手动生效上面脚本文件（如：source /etc/profile）。 linux软件安装 所谓命令，其实就是在终端机下调用某个软件（工具）运行。这些软件大部分是系统自带的，但有些需要我们去安装，安装的方式有在线安装、离线安装（离线软件包括：解压版、源码版、安装版）。 解压版：直接解压即可使用；（推荐方式） 源码版：需要交叉编译器源代码，再复制到目标板运行； 安装版：执行后按照提示安装； 【补充：通常还需要配置环境变量！】 ● 解压版-安装示例： wget https://developer.arm.com/-/media/Files/downloads/gnu-rm/10.3-2021.10/gcc-arm-none-eabi-10.3-2021.10-x86_64-linux.tar.bz2 # 下载交叉编译器压缩包 sudo tar -xjvf gcc-arm-none-eabi-10.3-2021.10-x86_64-linux.tar.bz2 -C /usr/lib/gcc # 将交叉编译器压缩包解压到：/usr/lib/gcc sudo gedit /etc/profile # 打开环境变量,在文件最后添加内容：export PATH=$PATH:/usr/lib/gcc/gcc-arm-none-eabi-10.3-2021.10/bin source /etc/profile # 使能环境变量。 sudo apt-get install lsb-core # 64位操作系统需要安装32位依赖库：lsb-core （arm-none-eabi-gcc 用到） sudo apt-get install lib32ncurses5 # 64位操作系统需要安装32位依赖库：lib32ncurses5（arm-none-eabi-gdb 用到） arm-none-eabi-gcc -v # 查看版本(验证是否安","date":"2021-06-13","objectID":"/20210613/:0:1","tags":["命令","linux 工具/应用"],"title":"linux 基本命令使用","uri":"/20210613/"},{"categories":["linux"],"content":"二、基本命令 1、常用的快速键 Ubuntu 拥有多个操作终端（使用Ctrl+Alt+F1~F7切换），F7为系统默认启动\u0026加载的图形操作终端，其余都是为纯命令行界面终端。 Ctrl+Alt+F1切换到命令行界面终端。 Ctrl+Alt+F7切换到图形界面终端。 Ctrl+Alt+t在图形界面下打开命令行终端机。 Ctrl+D关闭当前命令行终端机（纯终端则重启）。 Ctrl+C强制退出在当前命令行终端机的程序。 Ctrl+Insert复制选择的文本内容。 Shift+Insert粘贴缓存的文本内容。 Ctrl+A 或 Home转到行的开头。 Ctrl+E 或 End转到行的结尾。 Ctrl+L输入行移到页面顶部（相当清屏）。 ↑ 和 ↓方向键调取之前执行过的 Linux 命令。 Tab 自动补全命令，提高输入速度及精准度。 $ 命令行前面显示此字符，表示以用户权限操作。 # 命令行前面显示此字符，表示管理员权限操作。（root 权限） 2、系统权限操作 sudo su chmod chown chgrp sudo su # su 仅仅取得 root 权限，工作环境不变。 su root # 切换到root exit # 退出root(前提已进入root) # 【关于提示符】: # ~$ 表示处于普通用户权限 # ~# 表示处于 root 权限 sudo passwd # 设置root的密码 (根据提示输入:一般先要经过输入当前用户密码验证,再输入两次设置root新密码) # 【扩展说明】: # [su ] 向当前用户授权管理员权限级别许可,但工作环境没有任何变动 # [sudo ] 以管理员身份操作(只在操作过程中变成管理员工作环境,平常还是当前用户工作环境) # [chmod] 修改文件(夹)操作权限,特别是从Windows拷贝到linux时,经常要改权限,否则不能执行 sudo chmod 777 /srv/ftp/upload # 对目录[/srv/ftp/upload]拥有者rwx,用户组rwx,其它用户rwx sudo chmod 751 /srv/ftp/download # 对目录[/srv/ftp/upload]拥有者rwx,用户组r-x,其它用户--x sudo chmod ug+rw /srv/ftp/upload # 对目录[/srv/ftp/upload]拥有者u和用户组g[增加]读r和写w权限 sudo chmod ug-rw /srv/ftp/upload # 对目录[/srv/ftp/upload]拥有者u和用户组g[移除]读r和写w权限 sudo chmod ug=rw /srv/ftp/upload # 对目录[/srv/ftp/upload]拥有者u和用户组g[设为]读r和写w权限 # 【扩展说明】: # [u] 表文件拥有者 | [+] 添加某个权限 | [r] 可读 # [g] 表示同组用户 | [-] 取消某个权限 | [w] 可写 # [o] 表示其它用户 | [=] 重设 rwx权限 | [x] 可执行 # [a] 表示全部用户 | | sudo chown root /var/run/httpd.pid # 改变 /var/run/httpd.pid 文件的拥有者为 root sudo chown runoob:runoobgroup f.txt # 改变 f.txt 文件的拥有者为 runoob，群体的使用者为 runoobgroup sudo chown xiaomin 123.txt # 改变 123.txt 文件的拥有者为 xiaomin sudo chown -R xiaomin /home/abc/ # 改变 /home/abc/ 目录及其下面所有文件(夹)的拥有者为 xiaomin（拥有者owner /'əʊnə(r)/） sudo chgrp -R xiaomin /home/abc/ # 改变 /home/abc/ 目录及其下面所有文件(夹)的用户组为 xiaomin（用户组group /ɡruːp/） # 【权限总结】： # 1.文件(夹)的拥有者（用户/用户组） # 2.拥有者的操作权限（读/写/执行） ifconfig # 查看网络 ifconfig eth0 192.168.2.10 # 临时配置IP地址(是临时配置,没保存!) ifconfig eth0 192.168.2.10 netmask 255.255.255.0 ifconfig eth0 192.168.2.10 netmask 255.255.255.0 broadcast 192.168.2.255 sudo /etc/init.d/networking restart # 重启网络 sudo gedit /etc/network/interfaces # 编辑网络 (不用 gedit 时也可以用 vi 编辑) # 网络配置最基本内容: # # The loopback network interface # auto lo # iface lo inet loopback # # # The primary network interface # auto eth0 # iface eth0 inet static # address 192.168.0.42 # netmask 255.255.255.0 # gateway 192.168.0.1 # network 192.168.0.0 # broadcast 192.168.0.255 # dns-nameservers 114.114.114.114 8.8.8.8 3、根与目录操作 cd ./ ../ pwd ls ll !! tree cd .. # 退回上一级目录 cd ../.. # 退回上两级目录 cd ftp/upload # 进入当前子目录 cd ./ftp/upload # 进入当前子目录(同上)(平常可以省略[./]) cd /usr/local # 进入 绝对目录 # [../] 表示相对路径(上级目录) # [./] 表示相对路径(下级目录) # [/] 表示绝对路径 cd - # 回到之前所在的目录 cd ~ # 进入当前用户的家目录( ~ 表示家目录) pwd # 显示当前工作目录的全路径 (print working directory) !! # 显示上一条命令及上一条命令的结果 ./qt-creator-linux-x86.run # [./]符表示运行[qt-creator-linux-x86.run]此文件 ls # 查看当前目录下文件 ls upload # 查看当前目录下[upload]目录下文件 ls *.o # 查看当前目录下扩展名为[*.o]的相关文件 ls -l \u003e lsoutput.txt # 以长格式显示文件的详细信息, 直接将打印内容保存到当前目录下lsoutput.txt(创建覆盖内容) ls -l \u003e\u003e lsoutput.txt # 以长格式显示文件的详细信息, 直接将打印内容保存到当前目录下lsoutput.txt(尾部插入内容) ls -R # 连同子目录的内容一起列出（递归列出） ls -a # 显示所有文件（包含以点(.)开头的隐藏文件） ls -l # 以长格式显示文件的详细信息，可以查看文件权限，所属用户，日期等 ll # 同 ls -l（其它选项：-t 按修改时间列出，-s 显示出大小） ls -l libmad.so.0 # 以长格式显示文件的详细信息查看 libmad.so.0 文件 ls -l | grep rwxrwxr- # 列出当前目录文件(夹),但只显示经过[grep]筛选含有[rwxrwxr-]的内容(grep是独立命令,|是管道命令) # 【扩展说明】: # 文件属性第一个字符表示是什么? 如: -rwxrwxrwx, drwxrwxrwx, …… # [-] 正规文档(regular file): 纯文本文档(ASCII),二进制文件(binary),数据格式文件(data) # [d] 目录(directory) # [l] 连接文件(link),就是类似 Windows 系统底下的快捷方式 # [b] 区块(block)设备文件 # [c] 字符(character)设备文件 # [s] 资料接口文件(sockets) # [p] 数据输送文件(FIFO, pipe) tree # 列出指定目录下的所有文件(夹)，包括子目录里的文件(夹) tree -L 1 # 显示一级目录和文件 tree -L 1 -d # 显示一级目录 # 【目录结构】： # /bin: 常用命令(二进制执行文件) # /sbin: 系统命令(二进制执行文件) # /dev: 设备文件目录(设备以档案形态存于本目录) # /media:可移动媒体设备挂载目录(与/mnt无本质区别) # /mnt: 存储设备挂载目录(一般为挂载临时的安装目录) # /etc: 系统配置文件目录 # /home: 用户主目录 # /root: 管理员主目录 # /opt: 可选的附加应用程序(第三方协力软件) # /boot: 系统内核文件和引导装载程序文件 # /lib: 存放系统的库文件 # /proc: 虚拟机系统，记录进程，网络信息等 # /sys: 虚拟文件系统，记录内核数据 # /var: 系统运行产生的文件 # /usr: 用户程序目录(Unix Software Resource)","date":"2021-06-13","objectID":"/20210613/:0:2","tags":["命令","linux 工具/应用"],"title":"linux 基本命令使用","uri":"/20210613/"},{"categories":["software"],"content":"本人 C 语言编程规范介绍","date":"2021-06-09","objectID":"/20210609/","tags":["C","编程规范"],"title":"本人 C 语言编程规范","uri":"/20210609/"},{"categories":["software"],"content":"前言 代码编写规则应该在建立一个工程项目之前，应该贯穿整个项目的始终，以保证代码的一致性。采用标准的代码编写惯例，可以大大简化项目的维护负担。采用一种好的风格，以达到以下目的：可移植性、连贯、整洁、易于维护、易于理解、简洁。关于本人 C 语言编程规范，以简单实用为主，不会设置过多规则。写这篇文章目的是为以后介绍我开发的一些模块，其按规范编写以保持统一风格方便大家阅读代码。 ","date":"2021-06-09","objectID":"/20210609/:0:1","tags":["C","编程规范"],"title":"本人 C 语言编程规范","uri":"/20210609/"},{"categories":["software"],"content":"总体规范 1、源文件命名规范 使用全小写形式，单词与单词之间使用_连接； 为了避免文件（夹）重名，一般在名称前面加入前缀标识； 示范如下： o2o_eeprom.c o2o_eeprom.h 2、头文件总体规范 使用统一的头部声明； 此头文件包含重映射； 一些依赖头文件包含； 加入防重复包含的宏； 加入C++的兼容语句； 参数配置； 数据类型； 操作函数； 示范如下： /** * @file o2o_eeprom.h * @brief EEPROM存储器操作对象模块 * COPYRIGHT (C) 2021, 一春又一春设计部 * Change Logs: * Date Author Notes * 2021-05-30 o2ospring 原始版本 */ #ifndef O2O_EEPROM_H__ #define O2O_EEPROM_H__ //######################################################################################################## #include \"app_cfg.h\" /////////////////////// \u003c- 很多工程都会有专管理应用模块的头文件★★★★★★★★★★###ifdef __O2O_EEPROM_REMAP_H //////////////// \u003c- 如果在[app_cfg.h]定义此宏，则启动头文件重映射功能！ ## #include \"o2o_eeprom_remap.h\" ////////////// \u003c- 当启动重映射,则当前头文件包含映射到[o2o_eeprom_remap.h] ###else //################################################################################################## #include \u003cstdint.h\u003e //////////////////////// \u003c-使用的数据定义，如: int8_t, uint32_t 等 #ifdef __cplusplus extern \"C\" { #endif /********************************************************************************************************/ /*++++++++++++++++++++++++++++++++++++++++++++++ 参数配置 ++++++++++++++++++++++++++++++++++++++++++++++*/ /********************************************************************************************************/ /********************************************************************************************************/ /*++++++++++++++++++++++++++++++++++++++++++++++ 数据类型 ++++++++++++++++++++++++++++++++++++++++++++++*/ /********************************************************************************************************/ /********************************************************************************************************/ /*++++++++++++++++++++++++++++++++++++++++++++++ 操作函数 ++++++++++++++++++++++++++++++++++++++++++++++*/ /********************************************************************************************************/ extern int o2o_eeprom_write(o2o_eeprom_t *pob, uint32_t addr, uint8_t *pda, uint16_t len); #ifdef __cplusplus } #endif #endif //#ifdef __O2O_EEPROM_REMAP_H #endif //#ifndef O2O_EEPROM_H__ 3、源文件总体规范 头部声明； 模块开关； 全局变量； 函数声明； 函数实现； 示范如下： /** * @file o2o_eeprom.c * @brief EEPROM存储器操作对象模块 * COPYRIGHT (C) 2021, 一春又一春设计部 * Change Logs: * Date Author Notes * 2021-05-30 o2ospring 原始版本 */ #include \u003cstdint.h\u003e#include \u003cstring.h\u003e#define O2O_EEPROM_C__ #include \"o2o_eeprom.h\"#if (defined(APP_O2O_EEPROM_EN) \u0026\u0026 (APP_O2O_EEPROM_EN == DEF_ENABLED)) #ifdef O2O_EEPROM_X__ //再次调用头文件,用于增加存在交叉关系的内容! #undef O2O_EEPROM_H__ #include \"o2o_eeprom.h\"#endif //全局变量 uint32_t o2o_g_eeprom_flag = 0; //函数声明 int o2o_eeprom_write(o2o_eeprom_t *pob, uint32_t addr, uint8_t *pda, uint16_t len); int o2o_eeprom_read(o2o_eeprom_t *pob, uint32_t addr, uint8_t *pbf, uint16_t len); /** * @brief EEPROM对象写操作 * @param *pob 要操作的EEPROM对象 * @param addr 要写入位置 * @param *pda 要写入的数据源 * @param len 要写入的数据长度 * @return ＞0:操作成功 */ int o2o_eeprom_write(o2o_eeprom_t *pob, uint32_t addr, uint8_t *pda, uint16_t len) { } #endif //#if (APP_O2O_EEPROM_EN == DEF_ENABLED) ","date":"2021-06-09","objectID":"/20210609/:0:2","tags":["C","编程规范"],"title":"本人 C 语言编程规范","uri":"/20210609/"},{"categories":["software"],"content":"头部规范 1、文件头格式规范 文件名称； 模块摘要； 版权声明； 修改记录； 示范如下： /** * @file o2o_eeprom.c * @brief EEPROM存储器操作对象模块 * COPYRIGHT (C) 2021, 一春又一春设计部 * Change Logs: * Date Author Notes * 2021-05-30 o2ospring 原始版本 */ 2、函数头格式规范 函数摘要； 入口参数； 出口参数； 示范如下： /** * @brief 主函数 * @param argc 输入选项/参数的个数 * @param *argv[] 全部选项/参数内容 * @return 返回参数 */ int main(int argc, char *argv[]) { } ","date":"2021-06-09","objectID":"/20210609/:0:3","tags":["C","编程规范"],"title":"本人 C 语言编程规范","uri":"/20210609/"},{"categories":["software"],"content":"代码规范 1、宏定义名称书写规范 使用全大写形式，单词与单词之间使用_连接； 为了防止与其它模块重名，建议宏名称加入前缀； 宏的每个参数都要使用()括住； 只代表数值的宏，不需要使用()作为结尾； 示范如下： #define O2O_EEPROM_SIZE (32UL * 1024UL) #define O2O_MAX(a, b) (((a) \u003e (b)) ? (a) : (b)) 2、自定义类型书写规范 使用全小写形式，单词与单词之间使用_连接； 新定义数据类型名称以_t结尾； 对于结构体名称以_结尾； 示范如下： typedef unsigned char uint8_t; typedef signed char int8_t; typedef int (*o2o_pfunc_t)(int *, int); typedef struct o2o_limit_motor_ { uint8_t action; uint8_t load_act; uint16_t load_val; }o2o_limit_motor_t; typedef union o2o_motor_ { uint8_t load_act; uint16_t load_val; }o2o_motor_t; 3、变量书写规划 使用全小写形式，单词与单词之间使用_连接； 为了防止与其它模块重名，建议全局变量加入前缀； 如果变量对属性或类型敏感，则可以加入组合标识； g+ 表示属性为全局变量； s+ 表示属性为静态变量； c+ 表示属性为只读变量； p+ 表示属性为指针； vo_ 表示空数据类型；（只针对空指针） xx_ 表示可变动类型；（根据应用场合可设定数据类型，例如外置存储器大小） un_ 表示共用体类型； ob_ 表示结构体类型； sc_、ss_、sl_ 分别为 1、2、4 字节有符号数类型； uc_、us_、ul_ 分别为 1、2、4 字节无符号数类型； 完整变量命名：前缀 + 属性\u0026类型 + 描述 示范如下： int8_t o2o_gsc_delay; //如果局部变量则写法: sc_delay int16_t o2o_gss_delay; //如果局部变量则写法: ss_delay int32_t o2o_gsl_delay; //如果局部变量则写法: sl_delay uint8_t o2o_guc_delay; //如果局部变量则写法: uc_delay uint16_t o2o_gus_delay; //如果局部变量则写法: us_delay uint32_t o2o_gul_delay; //如果局部变量则写法: ul_delay uint32_t *o2o_pul_delay; //如果局部变量则写法: pul_delay (实际写法一般为 pul) void *o2o_pvo_delay; //如果局部变量则写法: pvo_delay (实际写法一般为 pvo) const int8_t o2o_csc_delay; static uint8_t o2o_suc_delay; o2o_limit_motor_t o2o_gob_motor; //如果局部变量则写法: ob_motor o2o_limit_motor_t *o2o_pob_motor; //如果局部变量则写法: pob_motor (可以简写为 p_motor) 对于平常时的使用，很少指出变量的类型，因为编程的重点在代码的业务逻辑及架构上。例如上面的变量统一写法为：delay motor g_delay g_motor p_delay p_motor即可。 4、代码书写规划 关键字与其它语句使用空格隔开，但else{}空置语句除外； 所有运算符都需要使用空格隔开；但for()条件判断除外； 示范如下： /** * @brief EEPROM对象写操作 * @param *pob 要操作的EEPROM对象 * @param addr 要写入位置 * @param *pda 要写入的数据源 * @param len 要写入的数据长度 * @return ＞0:操作成功 */ int o2o_eeprom_write(o2o_eeprom_t *pob, uint32_t addr, uint8_t *pda, uint16_t len) { int i; if (pda == 0) return; if (pob == 0) return; if (len == 0) return; if (addr \u003e= O2O_EEPROM_SIZE) return; if ((pob == 0) \u0026\u0026 (pda == 0)) { return; } else{} for (i=0; i\u003c20; i++) { pob-\u003ecnt_h = i; } while (1) { i += 1; i++; i = 0; } do { pda = \u0026i; } while (i \u003e 0); switch (addr) { case 1: break; case 2: break; default: break; } } ","date":"2021-06-09","objectID":"/20210609/:0:4","tags":["C","编程规范"],"title":"本人 C 语言编程规范","uri":"/20210609/"},{"categories":["software"],"content":"单词缩写 1、单词缩写字典 字母 描述 缩写词 A Average Avg Addition Add Accumulator Acc Address Addr Action Act Active Act Amplitude Amp Analog Input AI Anolog I/O AIO All All Alarm Alm Allocate Alloc Analog Output AO Apparent App Argument Arg Arrange Arrng Array Array Assemble Asm Attribute Attrib B Back Bk Background Bg Break Brk Bar Bar Bit Bit Block Blk Buffer Buf Button Btn Bypass Bypass C Calibration Cal Calculate Calc Configuration Cfg Channel Ch Change Chg Check Chk Clock Clk Clear Clr Clear Screen Cls Command Cmd Compare Cmp Complete Comp Count Cnt Counter Ctr Column Col Communication Comm Connect Con Construct Cons Control Ctrl Context Ctx Convert Conv Copy Cp Current Cur Cursor Csr Control Word CW Color Cr(clr) D Data Dat Date Date Day Day Day-of-week DOW Delay Dly Debounce Debounce Decrease Dec Decimal Dec Decode Decode Define Def Degree Deg Delete Del Destination Dst Descriptor Desc Device Dev Discrete Input DI Digit Dig Discrete I/O DIO Discrete Output(s) DO Disable Dis Display Disp Discovery Disc Division Div Divisor/Division Div Document Doc Down Down Dummy Dummy Dynamic Dyn E Edge Edge Edit Edt Effective Eff Electric Elec Empty Empty Enable En Engine Eng Enter Enter Entries Entries Equivalent Equiv Error(s) Err Ethernet Eth Engineering Units EU Event(s) Event Extension Ext Exit Exit Exception Exc Expiration Exp Exponent Exp F Field Fld Flag Flg Flush Flush Function(s) Fnct Format Frm Fraction Fract Free Free Frequency Freq Full Full G Grid Grd Gain Gain Get Get Generate Gen Group(s) Grp H Handler Handler Harmonic Harm Hexadecimal Hex High Hi History Hist Hit Hit High Priority Task HPT Hour(s) Hr I I.D. Id Idle Idle Impulse Imp Image Img Increment Inc Information Info Initial Init Insert Ins Input(s) In Initialization Init Initialize Init Instruction Instr Interrupt Int Invert Inv Interrupt Service Routine ISR Index Ix K Key Key Keyboard Key L Label Lab Length Len List Lst(Ls) Library Lib Limit Lim Low Lo Lower Le Lowest Lo Lock Lock Low Priority Task LTP M Manager Mngr(mgr) Magnitude Mag Mantissa Man Manual Man Manufacture Mfg Maximum Max Mailbox Mbox Minimum Min Mode Mode Month Month Move Mov Message Msg Measure Meas Mask Msk Multiplication Mul Multiplex Mux Make Mk N Negative Neg Number of Num Nesting Nesting Neutral Neut New New Next Next O Offset Offset Old Old Operation System OS Optimize Opt Original Orig Output Out Overflow Ovf P Password Pwd Picture Pic Point Pt Print Prn Program Prg Package Pkg Parameter Param Pass Pass Performance Perf Period Per Phase Ph Port Port Position Pos Positive Pos Power Pwr Previous Prev Priority Prio Printer Prt process Proc Product Prod Protocol Prot Pointer Ptr Put Put Q Queue Q Quality Qlty Quarter Quar R Raw Raw Reactive React Recall Rcl Rectangle Rect Read Rd Ready Rdy Reference Ref Register Reg Request Req Reset Reset Reserve Resv Resume Resume Response Resp Return Rtn Reverse Revs Ring Ring Row Row Repeat Rpt Real-Time RT Running Running Receive Rx S Server Srv Source Src Statistic Stat String Str Sybase Syb Sample Smp Scale Scale Scale Factor SF Scaling Scaling Scan Scan Schedule Sched Scheduler Sched Screen Scr Second(s) Sec Segment(s) Seg Select Sel Semaphore Sem Sequence Seq Server Svr Set Set Setting Setting Signal Sig Size Size Seven-segments SS Sourse Src Start Start Statistic(s) Stat Status Stat Stack Stk Standard Std Stop Stop String Str Subtraction Sub Suspend Suspend Switch Sw Synchronize Synch System Syst T Temp Tmp Text Txt Task Task Table Tbl Threshold Th Tick Tick Time Time Timer Tmr Toggle Tgl Total Tot Trigger Trig Time-stamp TS Timeout TO Unlock Unlock U User Usr Up Up Update Update Utility Util V Value Val Vector Vect Version Ver Variable Var Visible Vis Voltage Vol W Watchdog Wdog Window Wnd(win) Write Wr Y Year Year ","date":"2021-06-09","objectID":"/20210609/:0:5","tags":["C","编程规范"],"title":"本人 C 语言编程规范","uri":"/20210609/"},{"categories":["MCU"],"content":"介绍 STM32CubeMX 的基本使用","date":"2021-06-06","objectID":"/20210606/","tags":["STM32CubeMX","ARM Cortex-M"],"title":"STM32CubeMX 基本使用","uri":"/20210606/"},{"categories":["MCU"],"content":"一【基本知识】 ● STM32CubeMX 是 ST 意法半导体近几年来大力推荐的 STM32 芯片图形化配置工具，目的就是为了方便开发者，允许用户使用图形化向导【生成初始化代码】，省去了我们配置各种外设复杂的参数，大大的节省了时间。STM32CubeMX 支持多种工具链，比如 MDK、IAR For ARM、TrueStudio 以及 Makefile 等。STM32CubeMX 几乎覆盖了 STM32 全系列芯片，比如 STM32F、STM32G、STM32H、STM32L 等。 ● HAL 库是 Hardware Abstraction Layer 的缩写，中文名称为硬件抽象层，是 ST 公司为 STM32 的 MCU 最新推出的硬件抽象层驱动库，为更方便的实现跨 STM32 产品的最大可移植性。 网文：STM32 CubeMx 使用教程 ","date":"2021-06-06","objectID":"/20210606/:0:1","tags":["STM32CubeMX","ARM Cortex-M"],"title":"STM32CubeMX 基本使用","uri":"/20210606/"},{"categories":["MCU"],"content":"二【STM32CubeMX 安装】 1、安装 JRE 由于 STM32CubeMX 软件是基于 JAVA 环境运行的，所以事先需要安装 JRE。JRE 包含了 JVM 虚拟机以及 Java 语言的核心类库，用于运行 java 程序。打开【官网】，选择 Windows Offline (64-bit) 版本下载。安装方法很简单，点击“安装”即可。备注：想了解更多 JRE 的知识，请移步《linux JAVA 开发环境 JDK》。 2、安装 STM32CubeMX 首先到官网下载 STM32CubeMX，由于需要填写 Email 相关信息及官网下载网速可能过慢，个人建议到普通软件网站下载再升级到最新版（升级方法：Help → Check for Updates → Refresh）。STM32CubeMX 的安装很简单，一路 Next 及选择同意，最后 Done 即可。备注：无论安装目录还是创建工程，都不应使用中文，否则可能会出错！ 3、安装 HAL 库 HAL 库的安装分两种：离线安装、在线安装。如果你之前已经下载 HAL 库离线包，点击菜单：Help → Manage embedded software packages → From Local… 直接导入即可；否则建议在线安装：Help → Manage embedded software packages → Install Now。 ","date":"2021-06-06","objectID":"/20210606/:0:2","tags":["STM32CubeMX","ARM Cortex-M"],"title":"STM32CubeMX 基本使用","uri":"/20210606/"},{"categories":["MCU"],"content":"三【STM32CubeMX 使用】 1、第一步新键工程（如图） 2、选择芯片及封装（如图） 3、配置晶振及时钟（如图） 补充： STM32F429xxx时钟配置参考 4、配置 GPIO 引脚（如图） 5、配置 UART 串口（如图） 6、工程配置及生成（如图） ","date":"2021-06-06","objectID":"/20210606/:0:3","tags":["STM32CubeMX","ARM Cortex-M"],"title":"STM32CubeMX 基本使用","uri":"/20210606/"},{"categories":["MCU"],"content":"四【STM32CubeMX 更多】 1、【调试引脚】初始与使用（如图） 必须使能调试引脚，否则烧录一次之后将无法再使用仿真器仿真或烧录程序！（补救方法还是有的，只是操作起来有点麻烦。方法一：按着 MCU 的复位键不放，点击 Keil 下载，等界面进入下载流程时松开按键，如果不成功多试几次；方法二：BOOT1=X BOOT0=0 两引脚电平决定程序从单片机内部 Flash 存储器启动，暂时修改 BOOT0=1 为高电平，则程序启动不起就不会影响调试引脚功能，此时即可烧录程序，不过前提硬件需要预留 BOOT0 引脚为可设置高低电平！） 2、【普通IO脚】初始与使用（如图） 3、【外部中断】初始与使用（如图） 4、【串口通讯】初始与使用（如图） 5、【定 时 器】初始与使用（如图） 待续…… 6、【PWM 输出】初始与使用（如图） 7、【看 门 狗】初始与使用（如图） 8、【SPI 总线】初始与使用（如图） ","date":"2021-06-06","objectID":"/20210606/:0:4","tags":["STM32CubeMX","ARM Cortex-M"],"title":"STM32CubeMX 基本使用","uri":"/20210606/"},{"categories":["software"],"content":"介绍 Visual Scope 串口虚拟示波器工具的使用","date":"2021-06-02","objectID":"/20210602/","tags":["Visual Scope"],"title":"Visual Scope 串口虚拟示波器工具","uri":"/20210602/"},{"categories":["software"],"content":"前言 我们做项目时，往往需要查看数据曲线。例如：查看单片机使用率的曲线、查看 AD 读出温度值的曲线、查看电机转速的曲线…… 那么有没有像示波器一样显示曲线图的工具呢？当然是有的，今天为大家介绍一款串口虚拟示波器软件 Visual Scope。Visual Scope 串口虚拟示波器是一个电脑软件，它将通过串口传送到计算机的数据以图形的方式，在计算机屏幕上显示虚拟的示波器曲线，方便对数据分析，是您必不可缺的开发助手。Visual Scope 支持 4 通道的波形显示，支持 X、Y 轴任意缩放及移动，支持打开与保存波形数据的 Matlab 分析文件，支持 check sum 和 CRC16 两种数据校验方式。 ","date":"2021-06-02","objectID":"/20210602/:0:1","tags":["Visual Scope"],"title":"Visual Scope 串口虚拟示波器工具","uri":"/20210602/"},{"categories":["software"],"content":"使用 1、工作原理 首先Visual Scope向单片机发送启动通道传输数据指令，单片机收到指令后获知要传输哪几路通道的哪段数据（实际上 Visual Scope 为每个通道使用 4 字节指出一个数值，至于数值何含义则是由用户自行定义），然后单片机源源不断传送数据， Visual Scope把这些数据以图形曲线的方式呈现出来。备注：实际上单片机无须收到启动指令也可以源源不断传送数据给Visual Scope显示。 2、工具下载 Visual Scope为串口虚拟示波器工具，用于接收串口数据以曲线可视化方式展示出来； ECOM为串口调试助手工具，用于模拟单片机向电脑发送数据。 关于下载，可以到普通的软件网站下载即可： ● 西西软件：Visual Scope 串口示波器 网页下面点击 普通下载地址 下面的链接地址下载。 ● 脚本之家：ECOM 串口助手 网页下面点击 其它下载地址 下面的链接地址下载。 3、应用例子：连接电脑串口 把 USB 转串口工具插到电脑上，然后把 USB 转串口的RX、TX、地分别接到单片机的TX、RX、地 4、应用例子：配置通讯参数 由于Visual Scope试用版限制只能使用串口1，USB 转串口的串口号往往不是 1，所以只能我们强制修改串口号 配置Visual Scope使用串口的参数（试用版的波特率、串口号这几项不可修改） 配置Visual Scope传输数据使用哪种校验方式（本例子使用 CRC16 校验） 5、应用例子：配置界面显示 在Visual Scope勾选显示哪几路通道（本例 4 路通道全部显示）和设置栅格起始及宽度（本例设置 1000，X 轴其实就是通道上第几个取样点，而非时间轴），点RUN运行监测下位机数据 6、应用例子：模拟数据展示 模拟测试：为了方便测试，没有使用单片机，而是使用电脑两个串口互发数据进行测试。其中Visual Scope使用串口1，数据发送软件ECOM 串口调试助手使用串口6，串口1的RX、TX、地分别连接串口6的TX、RX、地。ECOM 串口调试助手支持多条数据循环发送，同时可以自动在数据尾部插入CRC校验，很方便我们的测试。 操作介绍：打开ECOM 串口调试助手启动串口6，根据图示设置相关发送数据。根据上几节内容设置Visual Scope，然后按RUN按钮。 后记： ● 关于启动命令和曲线数据的格式，上图已很清晰标明。 ● 关于 CRC16 运算、数据格式和协议更多细节内容可查看Visual Scope的菜单：Help / Communication Protocol了解。 7、特别例子：逻辑分析仪 利用Visual Scope虚拟示波器显示引脚电平状态，实现虚拟的逻辑分析仪功能，方便我们分析新写的模拟总线驱动模块的正确性！ ","date":"2021-06-02","objectID":"/20210602/:0:2","tags":["Visual Scope"],"title":"Visual Scope 串口虚拟示波器工具","uri":"/20210602/"},{"categories":["MCU"],"content":"ARM-Cortex-M 系列 MCU 错误追踪库-CmBacktrace","date":"2021-05-26","objectID":"/20210526/","tags":["ARM Cortex-M","CmBacktrace"],"title":"ARM-Cortex-M 系列 MCU 错误追踪库-CmBacktrace","uri":"/20210526/"},{"categories":["MCU"],"content":"前言 ● 对于 “hard falut” 死机，是玩 ARM Cortex-M 系列 MCU 工程师望而生畏的错误，虽然大多数情况下都是内存溢出引起，但想定位出错误代码位置，那可是一件不容易的事。 ● 对于入门新人，定位错误的方法也往往是连接上仿真器，一步步 F10/F11 单步运行调试，定位到具体的错误代码，再去猜测、排除、推敲错误原因，这种过程十分痛苦。 ● 对于熟练老手，知道可以通过故障寄存器信息来定位故障原因及故障代码地址，虽然这样能解决一小部分问题，但是重复的、繁琐的分析过程也会耽误很多时间。而且对于一些复杂问题，只依靠代码地址是无法解决的，必须得还原错误现场的函数调用逻辑关系。虽然连接仿真器可以查看到的函数调用栈，但故障状态下是无法显示的，所以还是得老老实实一步一步 F10/F11 单步去定位错误代码的位置。 ● 工欲善其事，必先利其器。今天为大家介绍 CmBacktrace（Cortex Microcontroller Backtrace）（/‘kɔːteks /maɪkrəʊkɒnt’rəʊlə /bæk treɪs） ARM Cortex-M 系列 MCU 错误追踪库，配合 addr2line 工具，可以对故障进行精确定位。 ","date":"2021-05-26","objectID":"/20210526/:0:1","tags":["ARM Cortex-M","CmBacktrace"],"title":"ARM-Cortex-M 系列 MCU 错误追踪库-CmBacktrace","uri":"/20210526/"},{"categories":["MCU"],"content":"使用 1、工具简介及异常事件： 工具 介绍 CmBacktrace ARM Cortex-M 系列 MCU 错误追踪库。支持断言（assert）、故障（Hard Fault, Memory Management Fault, Bus Fault, Usage Fault, Debug Fault） addr2line 是一个可以将指令的地址和可执行映像转换成文件名、函数名和源代码行数的工具。它是标准的 GNU Binutils 中的一部分。 首先我们假设已经移植了 CmBacktrace 库到我们工程项目上，以及在电脑上安装了 addr2line 工具软件。 假设我们的单片机发生死机并通过串口打印出由 CmBacktrace 生成错误信息。 打开命令窗口，输入由 CmBacktrace 提示的 addr2line 命令串，生成错误代码定位位置信息。 2、生成的错误信息例子： 3、输入的错误定位命令： 4、输出的错误位置信息： 从上面的使用例子可以看出，我们很容易地使用工具为我们精准定位错误代码的位置。 ","date":"2021-05-26","objectID":"/20210526/:0:2","tags":["ARM Cortex-M","CmBacktrace"],"title":"ARM-Cortex-M 系列 MCU 错误追踪库-CmBacktrace","uri":"/20210526/"},{"categories":["MCU"],"content":"移植 一、CmBacktrace 移植： 1、将追踪模块加入工程： 2、初始及对接异常中断： 3、配置和适配平台环境： 4、人为地制造一个异常： 出现的异常及获取异常代码位置的方法请查看上一节内容！ 二、addr2line 移植： 1、addr2line 分析工具简介： Linux 系统一般会集成这个工具（它是标准的 GNU Binutils 中的一部分），而 Windows 系统需要我们自己下载添加。Windows 系统下我们可以从 CmBacktrace 项目的 tools 文件夹中获取 addr2line.exe，也可以安装 MinGW 在其安装目录的 bin 文件夹里获取 addr2line.exe。将其直接拷贝至 C:\\Windows 下使用或自定义路径下使用。关于 MinGW 的相关知识，请移步《MinGW-w64 编译套件(GNU 工具集)》 2、Windows 环境变量添加： 当 addr2line.exe 放到自定义路径下使用需要设置环境变量： 3、CmBacktrace 模块下载： 官方介绍及下载网址：gitee、github ","date":"2021-05-26","objectID":"/20210526/:0:3","tags":["ARM Cortex-M","CmBacktrace"],"title":"ARM-Cortex-M 系列 MCU 错误追踪库-CmBacktrace","uri":"/20210526/"},{"categories":["MCU"],"content":"Keil MDK(ARM)-在已运行单片机硬件上中途插入调试","date":"2021-05-20","objectID":"/20210520/","tags":["ARM Cortex-M","Keil MDK"],"title":"Keil MDK(ARM)-在已运行单片机硬件上中途插入调试","uri":"/20210520/"},{"categories":["MCU"],"content":"前言 一台没有上调试仿真器（如：j-link）的设备突然死机、调试控制大功率机器过程中调试仿真器突然掉线、给测试部测试了近一个月的设备突然死机（难以重现的 BUG 可遇不可求），而此时你想查看单片机当前内部一些变量、寄存器、堆栈的现场，想在实际断点处继续运行单片机程序，如何是好？我们都知道，平常在 KEIL 环境下，单片机连接仿真器后进入调试模式时，KEIL 就会自动将整个单片机进行复位，甚至有可能重新下载程序。不要说访问 RAM 数据了，程序 ROM 的代码都可能改变了！针对上面的问题，我们有没有一种方法，在不改变及不破坏单片机运行现场情况下直接切入调试模式？方法当然是有的，不急，听我慢慢道来。 ","date":"2021-05-20","objectID":"/20210520/:0:1","tags":["ARM Cortex-M","Keil MDK"],"title":"Keil MDK(ARM)-在已运行单片机硬件上中途插入调试","uri":"/20210520/"},{"categories":["MCU"],"content":"方法 注意：为了防止一些操作引起单片机复位，首先我们把仿真器拔离单片机。 1、新建工程目标： 只是克隆一模一样工程配置，之后再修改几项配置。 2、修改工程配置： 事先在工程根目录下创建文件，本例文件名为abn-debug-load-axf.ini，其内容为： LOAD %L INCREMENTAL 注：该文件用于加载 axf 文件到 KEIL 中，但是不会下载到单片机中，而 axf 文件可以方便我们进行源码级别的调试。 接着修改配置+添加文件： 3、直接进入调试： 在已运行的硬件板重新插上仿真器（如：j-link 仿真器），然后在 keil 开发环境直接点击debug按钮（注意：不要点击编译/下载/烧录这类按钮）。相当于从正常运行状态，暂停一下，再进入仿真模式，之后按照平时调试方式正常操作即可。注意-有两个前提条件： 1、原程序没有开启看门狗； 2、保留原来的代码、 axf、map 文件，或使用原来代码编译出一样的 axf、map 文件； ","date":"2021-05-20","objectID":"/20210520/:0:2","tags":["ARM Cortex-M","Keil MDK"],"title":"Keil MDK(ARM)-在已运行单片机硬件上中途插入调试","uri":"/20210520/"},{"categories":["software"],"content":"介绍 Serial Studio 数据可视化工具的使用","date":"2021-05-15","objectID":"/20210515/","tags":["Serial Studio"],"title":"Serial Studio 数据可视化工具","uri":"/20210515/"},{"categories":["software"],"content":"一、简介 Serial Studio（/‘sɪəriəl /‘stjuːdiəʊ/） 是一个多平台、多用途的串行数据可视化应用软件。此程序的目标是使嵌入式开发人员可以轻松地可视化呈现和分析其设备（或项目）生成的数据，而无需为每个项目编写专用的计算机软件。由于开源，这个工具可以扩展支持几乎所有与数据采集/测量相关的项目。Serial Studio 使用 MIT 开源协议，我们可以自由使用、复制、修改、合并、发布、分发，再许可和(或)出售。 在实际使用上发现 Serial Studio 主要针对飞行器数据可视化的一款应用软件，因为它的可视化仪表盘主要分为陀螺仪、地图坐标（经纬度）、加速计、电池指示器。Serial Studio 类似汽车的仪表盘，专业性比不上虚拟示波器这类测量软件。 ","date":"2021-05-15","objectID":"/20210515/:0:1","tags":["Serial Studio"],"title":"Serial Studio 数据可视化工具","uri":"/20210515/"},{"categories":["software"],"content":"二、使用 1、工作原理 首先在 Serial Studio 电脑软件上向设备发送启动命令，被启动的设备不断地向 Serial Studio 发送数据，Serial Studio 以仪表盘可视化方式把这些数据展示出来。关于仪表盘呈现界面需要事先通过电脑的 json 文件或者由设备第一时间直接发 json 信息给 Serial Studio 进行即时定制。Serial Studio 与设备连接的方式可以是串口、TCP/UDP、MQTT。设备为服务端，Serial Studio 为客户端。 2、安装方法 下载安装包直接安装，一直点下一步即可（注：实测只能安装到 C 盘）。相关网址：官方下载 、GitHub开源 、官方通讯协议说明 3、界面简介 3.1、界面语言选择： 3.2、界面功能介绍： 4、应用例子：仪表盘界面配置 4.1、配置仪表盘界面及数据格式： 本例使用电脑 json 配置文件来配置仪表盘界面（使用设备发来 json 配置未测试成功），具体请看下图： 4.2、json 描述仪表盘语法说明： 数据结构组成：\"g\":所有小窗口 ＞ \"d\":小窗口所有数据 ＞ \"w\":单个标准部件（包括：小窗口部件 ＞ 数据小部件） t：项目标题（字符串，必填） g：组（数组） t：组标题（字符串，必填） w：窗口小部件类型（字符串），可选-可以如下： map：创建在地图上显示位置的小部件 bar：垂直进度栏（带有max＆min值） gyro：陀螺仪指示器（带有x，y＆z值） accelerometer：加速计指示（与x，y，＆z值） d：组数据集（数组） t：数据集标题（字符串，可选） v：数据集值（变量，必填） u：数据集单位（字符串，可选） g：数据集图（布尔值，可选） w：窗口小部件类型（字符串），取决于组窗口小部件类型，可能如下： 对于gyro＆accelerometer小部件： x：X轴的值 y：Y轴的值 z：Z轴的值 对于map小部件： lat：纬度 lon：经度 对于bar小部件： max：最大值 min：最小值 4.3、json 描述仪表盘界面例子： ● 新建 test.json 文件，其须为UTF-8编码，因为数据单位使用一些特殊字符。 ● 编写仪表盘界面描述：（实际上无须重新编写 json，只需要对下面参考例子增删改即可） { \"t\":\"%1\", \"g\":[ { \"t\":\"Mission Status-任务状态\", \"d\":[ { \"t\":\"Runtime\", \"v\":\"%2\", \"u\":\"ms\" }, { \"t\":\"Packet count\", \"v\":\"%3\" }, { \"t\":\"Battery voltage\", \"v\":\"%4\", \"g\":true, \"u\":\"V\", \"w\":\"bar\", \"min\":3.6, \"max\":4.3 } ] }, { \"t\":\"Sensor Readings-传感器读数\", \"d\":[ { \"t\":\"Temperature(温度)\", \"v\":\"%5\", \"g\":true, \"u\":\"°C\", \"w\":\"bar\", \"min\":0, \"max\":80 }, { \"t\":\"Altitude(海拔)\", \"v\":\"%6\", \"u\":\"m\", \"w\":\"bar\", \"min\":0, \"max\":3000 }, { \"t\":\"Pressure(压力)\", \"v\":\"%7\", \"u\":\"KPa\", \"g\":true, \"w\":\"bar\", \"min\":54, \"max\":102 }, { \"t\":\"External Temperature\", \"v\":\"%8\", \"g\":true, \"u\":\"°C\", \"w\":\"bar\", \"min\":0, \"max\":80 }, { \"t\":\"Humidity(湿度)\", \"v\":\"%9\", \"g\":true, \"u\":\"%\", \"w\":\"bar\", \"min\":0, \"max\":100 } ] }, { \"t\":\"GPS-地图坐标\", \"w\":\"map\", \"d\":[ { \"t\":\"GPS Time\", \"v\":\"%10\" }, { \"t\":\"Longitude(经度)\", \"v\":\"%11\", \"u\":\"°E\", \"w\":\"lon\" }, { \"t\":\"Latitude(纬度)\", \"v\":\"%12\", \"u\":\"°N\", \"w\":\"lat\" }, { \"t\":\"Altitude(海拔)\", \"v\":\"%13\", \"u\":\"m\" }, { \"t\":\"No. Sats\", \"v\":\"%14\" } ] }, { \"t\":\"Accelerometer-加速计\", \"w\":\"accelerometer\", \"d\":[ { \"t\":\"X\", \"v\":\"%15\", \"u\":\"m/s^2\", \"g\":true, \"w\":\"x\" }, { \"t\":\"Y\", \"v\":\"%16\", \"u\":\"m/s^2\", \"g\":true, \"w\":\"y\" }, { \"t\":\"Z\", \"v\":\"%17\", \"u\":\"m/s^2\", \"g\":true, \"w\":\"z\" } ] }, { \"t\":\"Gyroscope-陀螺仪\", \"w\":\"gyro\", \"d\":[ { \"t\":\"X\", \"v\":\"%18\", \"u\":\"°\", \"g\":true, \"w\":\"yaw\" }, { \"t\":\"Y\", \"v\":\"%19\", \"u\":\"°\", \"g\":true, \"w\":\"roll\" }, { \"t\":\"Z\", \"v\":\"%20\", \"u\":\"°\", \"g\":true, \"w\":\"pitch\" } ] } ] } 5、应用例子：仪表盘界面启动 配置 Serial Studio 与设备的连接方式，本例为使用 UDP 方式进行连接，并向设备发送自定义“start”启动命令（收到命令后，设备端就可以不断发送相关可视化数据到仪表盘显示了）： 6、应用例子：仪表盘界面显示 6.1、设备发送的可视化数据包格式说明： ● 数据包协议：起始符为/*，结束符为*/，数据之间使用,分隔。json 中诸如\"%1\"、\"%2\"……表示第几个数据。上面例子最大为\"%20\"表示共有 20 个数据，其中第 1 个数据为数据集合的标题。 ● 特别要注意：数据须为UTF-8编码，如果是全英文字符则可以ACSII编码。 /*title,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20*/ 6.2、将收到的数据在仪表盘界面显示： 使用 UDP 软件模拟设备发送数据给 Serial Studio，然后分别在 Serial Studio 的控制台、仪表盘、小部件窗口查看数据： ","date":"2021-05-15","objectID":"/20210515/:0:2","tags":["Serial Studio"],"title":"Serial Studio 数据可视化工具","uri":"/20210515/"},{"categories":["hardware"],"content":"介绍 RGB 屏与 MIPI 屏的基本知识","date":"2021-03-23","objectID":"/20210323/","tags":["RGB","MIPI","显示屏"],"title":"RGB 屏与 MIPI 屏基本知识","uri":"/20210323/"},{"categories":["hardware"],"content":"前言 性能较弱的单片机一般没有视频接口，我们只能使用并行总线方式驱动并口显示屏，其最大分辨率一般为 480×320。但随着工业的不断进步，现在的单片机性能越来越强，慢慢出现了自带显示总线控制器（视频接口），其中 RGB 接口最为常见，其分辨率可达 800×600 上下。顺带介绍一下手机使用的 MIPI 接口，其可用于多方面的数据传输，显示屏数据传输只是它的其中一项功能。 ","date":"2021-03-23","objectID":"/20210323/:0:1","tags":["RGB","MIPI","显示屏"],"title":"RGB 屏与 MIPI 屏基本知识","uri":"/20210323/"},{"categories":["hardware"],"content":"RGB 屏 点击展开内容 RGB：称为色光三原色，分别为红、绿、蓝。目前的显示器大都是采用了 RGB 颜色标准。在显示器上，是通过电子枪打在屏幕的红、绿、蓝三色发光极上来产生色彩的，目前的电脑一般都能显示 32 位颜色，约有一百万种以上的颜色。 YUV：其的发明是由于彩色电视与黑白电视的过渡时期。Y 表示明亮度（Luminance 或 Luma），也就是灰阶值；U 和 V 表示的是色度（Chrominance 或 Chroma），作用是描述影像色彩及饱和度，用于指定像素的颜色。 RGB 控制端口 端口名称 说明 R[7:0] 红色数据 G[7:0] 绿色数据 B[7:0] 蓝色数据 CLK 像素同步时钟信号 HSYNC 水平同步信号 VSYNC 垂直同步信号 DE 数据使能信号 显示格式 说明 RGB888 红、绿、蓝分别为 8、8、8 根线，共 24 位色 RGB666 红、绿、蓝分别为 6、6、6 根线，共 18 位色 RGB565 红、绿、蓝分别为 5、6、5 根线，共 16 位色 RGB 接口时序 HBP 和 HFP 存在的必要性：从道理上说，LCD 使用矩阵寻址这两个阶段完全可以没有。但是考虑到从前 CRT 电子枪行扫描时，需要一个返回时间，而且目前的制式中，在有效信号的两端分别加入了消隐时间。就是为了做到一致，这二者才出来的。 VBP 和 VFP 存在的必要性：同理。 ","date":"2021-03-23","objectID":"/20210323/:0:2","tags":["RGB","MIPI","显示屏"],"title":"RGB 屏与 MIPI 屏基本知识","uri":"/20210323/"},{"categories":["hardware"],"content":"MIPI 屏 点击展开内容 MIPI（移动行业处理器接口）是 Mobile Industry Processor Interface 的缩写。MIPI（移动行业处理器接口）是 MIPI 联盟发起的为移动应用处理器制定的开放标准。MIPI 并不是一个单一的接口或协议，而是包含了一套协议和标准，以满足各种子系统（图像子系统[摄像头和显示器]、存储子系统、无线子系统、电源管理子系统、低带宽子系统[音频、键盘、鼠标、蓝牙]）独特的要求。 分层结构 层级 解析 Application 层 描述高层编码和解析数据流（类似 485 总线用户定义的控制数据协议） Low Level Protocol 层 定义了如何组帧和解析以及错误检测等（类似 485 总线串口数据帧格式定义） Lane Management 层 发送和收集数据流到每条 lane（类似485总线串口的 RX、TX 控制端定义） PHY 层 定义了传输媒介，输入/输出电路和和时钟和信号机制（类似 485 总线RS485收发器芯片） 规范 所在层级 功能 DCS 规范 Application 层 DCS 是一个标准化的命令集，用于命令模式的显示模组（类似 485 总线用户定义的控制指令） DSI 规范 Low Level Protocol 层 Lane Management 层 定义了一个位于处理器和显示模组之间的高速串行接口（类似 485 总线串口驱动器） D-PHY 规范 PHY 层 提供DSI和CSI的物理层定义（类似 485 总线RS485 收发器芯片） 串行接口 解析 DSI（Display Serial Interface） 定义了一个位于处理器和显示模组之间的高速串行接口 CSI（Camera Serial Interface） 定义了一个位于处理器和摄像模组之间的高速串行接口 接口定义 接口定义 解析 时钟 一个时钟 lane（由两根差分信号线组成） 数据 一个或多个数据 lane（每个都是由两根差分信号线组成） 速度模式 速度 电平 LP 低功耗信号模式（Low-Power signaling mode） 10MHz (max) 0-1.2V（差分） HS 高速信号模式（High-Speed signaling mode） 80Mbps ~ 1Gbps/Lane 100-300mV(200mV)（差分） ","date":"2021-03-23","objectID":"/20210323/:0:3","tags":["RGB","MIPI","显示屏"],"title":"RGB 屏与 MIPI 屏基本知识","uri":"/20210323/"},{"categories":["hardware"],"content":"接口区别 点击展开内容 RGB-TTL、LVDS、MIPI-DSI 接口比较：这些接口区别于信号的类型，也区别于信号内容。 接口类型 接口信号类型 信号内容 RGB-TTL TTL电平 RGB666 或 RGB888 及行场同步和时钟（R、G、B、CLK、HSYNC、VSYNC、DE） LVDS LVDS 信号（低电压差分信号） RGB 数据还有行场同步和时钟（1 组时钟 CLK，4 组 DATA） MIPI-DSI LVDS 信号（低电压差分信号） 视频流数据和控制指令（1 组时钟 CLK，1~4 组 lane） LVDS、MIPI-DSI 接口比较： 接口类型 传输内容 LVDS 传输视频数据 MIPI-DSI 不仅能够传输视频数据，还能传输控制指令 接口类型 信号与格式 LVDS 将 RGB TTL 信号按照 SPWG / JEIDA 格式转换成 LVDS 信号进行传输 MIPI-DSI LVDS 信号进行传输，及按照特定的握手顺序和指令规则传输屏幕控制所需的视频数据和控制数据 ","date":"2021-03-23","objectID":"/20210323/:0:4","tags":["RGB","MIPI","显示屏"],"title":"RGB 屏与 MIPI 屏基本知识","uri":"/20210323/"},{"categories":["hardware"],"content":"参考资料 点击展开内容 网文-1：MIPI DSI 协议介绍 网文-2：STM32F429 » 21. LTDC 液晶屏幕 网文-3：LCD 接口和 RGB 介绍 网文-4：MIPI-DSI、MIPI-CSI、LVDS 等接口解析 网文-5：RGB_TTL、LVDS、MIPI 接口液晶屏学习笔记 ","date":"2021-03-23","objectID":"/20210323/:0:5","tags":["RGB","MIPI","显示屏"],"title":"RGB 屏与 MIPI 屏基本知识","uri":"/20210323/"},{"categories":["MCU"],"content":"获取 ARM 编译后的 ROM 及 RAM 大小方法及原理","date":"2021-03-18","objectID":"/20210318/","tags":["ARM Cortex-M","Keil MDK"],"title":"获取 ARM 编译后的 ROM 及 RAM 大小方法及原理","uri":"/20210318/"},{"categories":["MCU"],"content":"前言 ● 我们常用的 RT-Thread、Free OS 这类的操作系统都有动态内存管理，这段内存是编译后剩余的空间。那么是如何获知 Keil 编译器编译后剩余 RAM 的大小呢？ ● 前些年我做了 IAP 在线升级功能，其中需要程序能获知自己大小。那么又是如何通过特殊语法获取的呢？ ","date":"2021-03-18","objectID":"/20210318/:0:1","tags":["ARM Cortex-M","Keil MDK"],"title":"获取 ARM 编译后的 ROM 及 RAM 大小方法及原理","uri":"/20210318/"},{"categories":["MCU"],"content":"知识 1、RO段、RW段、ZI段 的组成： 名称 组成 RO段 是程序中的指令(Code)和常量(RO-Data) RW段 是程序中已初始化的变量(RW-Data) ZI段 是程序中未初始化的变量(ZI-Data)（默认初始化为0） 2、RO段、RW段、ZI段 的分布： ","date":"2021-03-18","objectID":"/20210318/:0:2","tags":["ARM Cortex-M","Keil MDK"],"title":"获取 ARM 编译后的 ROM 及 RAM 大小方法及原理","uri":"/20210318/"},{"categories":["MCU"],"content":"方法 1、获取 RO段、RW段、ZI段 地址及大小的方法： /*--------------IROM1--------------*/ extern int Image$$ER_IROM1$$RO$$Base; extern int Image$$ER_IROM1$$RO$$Limit; extern int Image$$ER_IROM1$$RO$$Length; #define LINKER_VAR_RO_START ((void *)\u0026Image$$ER_IROM1$$RO$$Base) //RO段起始地址 #define LINKER_VAR_RO_LIMIT ((void *)\u0026Image$$ER_IROM1$$RO$$Limit) //RO段结尾地址的后一个地址 #define LINKER_VAR_RO_SIZE ((void *)\u0026Image$$ER_IROM1$$RO$$Length) //RO段正使用空间的大小（即 _LIMIT - _START） /*--------------IRAM1--------------*/ extern int Image$$RW_IRAM1$$RW$$Base; extern int Image$$RW_IRAM1$$RW$$Limit; extern int Image$$RW_IRAM1$$RW$$Length; #define LINKER_VAR_RW_START ((void *)\u0026Image$$RW_IRAM1$$RW$$Base) //RW段起始地址 #define LINKER_VAR_RW_LIMIT ((void *)\u0026Image$$RW_IRAM1$$RW$$Limit) //RW段结尾地址的后一个地址 #define LINKER_VAR_RW_SIZE ((void *)\u0026Image$$RW_IRAM1$$RW$$Length) //RW段正使用空间的大小（即 _LIMIT - _START） extern int Image$$RW_IRAM1$$ZI$$Base; extern int Image$$RW_IRAM1$$ZI$$Limit; extern int Image$$RW_IRAM1$$ZI$$Length; #define LINKER_VAR_ZI_START ((void *)\u0026Image$$RW_IRAM1$$ZI$$Base) //ZI段起始地址 #define LINKER_VAR_ZI_LIMIT ((void *)\u0026Image$$RW_IRAM1$$ZI$$Limit) //ZI段结尾地址的后一个地址 #define LINKER_VAR_ZI_SIZE ((void *)\u0026Image$$RW_IRAM1$$ZI$$Length) //ZI段正使用空间的大小（即 _LIMIT - _START） /*------------应用例子-------------*/ ro_segment_size = (unsigned int)LINKER_VAR_RO_SIZE; //RO段大小 rw_segment_size = (unsigned int)LINKER_VAR_RW_SIZE; //RW段大小 zi_segment_size = (unsigned int)LINKER_VAR_ZI_SIZE; //ZI段大小 zi_segment_size = (unsigned int)LINKER_VAR_ZI_LIMIT - (unsigned int)LINKER_VAR_ZI_START; //ZI段大小 p_zi = LINKER_VAR_ZI_START; //ZI段起始地址 p_free_ram = LINKER_VAR_ZI_LIMIT; //空闲RAM起始地址 rom_size = ro_segment_size + rw_segment_size; //编译生成bin文件的大小 2、实测 rom_size 与实际 bin 文件大小不同原因： 那是因为编译器做了优化压缩，个人猜想是将RW段中初始化为 0 的变量优化掉，将它移到ZI段。大小差异如下图： ","date":"2021-03-18","objectID":"/20210318/:0:3","tags":["ARM Cortex-M","Keil MDK"],"title":"获取 ARM 编译后的 ROM 及 RAM 大小方法及原理","uri":"/20210318/"},{"categories":["MCU"],"content":"扩展 1、各种编译器的识别宏 ///////////////////////////////////////////////// //用于 ARM 处理器程序识别不同编译器，这些宏用于隐 //藏可由多个编译器编译的代码中与编译器相关的内容： ///////////////////////////////////////////////// // 1、MDK-ARM 使用编译器的宏名称（ARM RealView） #if defined(__CC_ARM) || defined(__CLANG_ARM) // 2、IAR-ARM 使用编译器的宏名称（IAR EWARM） #elif defined(__ICCARM__) // 3、GNU-gcc 使用编译器的宏名称（GNU Compiler Collection） #elif defined(__GNUC__) #endif 2、gcc 环境下获取 ROM、RAM 编译大小的方法 类型 说明 text 代码（Code）和常量（RO-Data）的大小（ROM） data 已初始化的全局变量（global）和静态变量（static）的大小（RAM/ROM） bss 未初始化的全局变量（global）和静态变量（static）的大小（RAM)。 其值一般默认默认为零！从 STM32F103 官方的 .ld 链接文件生成的 .map 文件查到，其包括：heap（堆）和 stack （栈）的大小！ dec text + data + bss 的总和值（十进制表示） hex text + data + bss 的总和值（十六进制表示） 补充 1、程序固件大小（ROM）：text + data 2、程序已用内存（RAM）：data + bss（包括：heap 和 stack 的大小） // 在 C 语言中，通过如下方式获取某个分段 // 的起始与结束地址，再由计算可得出大小。 // 具体变量名称在链接脚本中找出！！！！！ extern int _sbss; extern int _ebss; #define LINKER_VAR_ZI_START ((void *)\u0026_sbss) #define LINKER_VAR_ZI_LIMIT ((void *)\u0026_ebss) #define LINKER_VAR_ZI_SIZE (((void *)\u0026_ebss) - ((void *)\u0026_sbss)) 关于 text、data、bss、heap、stack 的分布更多知识，请查阅《linux-STM32F开发-makefile 构建与使用》→【提升】→【关于 text、data、bss、heap、stack 的分布】！ 3、MCU 的堆栈及静态区 RAM 区域 地址分布 说明 （1）静态区（static） 在低地址 存储包括未初化、已初始化的全局变量和静态变量的一块区域！ （2）堆区（heap） 在中地址 一般由程序员分配和释放，若程序员不释放，程序结束时可能由操作系统回收。分配方式类似于数据结构中的链表。通过malloc函数申请，通过free函数释放！堆：向高地址扩展！ （3）栈区（stack） 在高地址 由编译器自动分配和释放，存放函数的参数值、局部变量的值等，其操作方式类似于数据结构中的栈。函数调用及函数退出时自动处理！栈：向低地址扩展！ 4、scatter 分散加载文件 keil 默认使用自定义链接文件 link.sct（scatter 分散加载文件。扩展：对应 gcc 编译器就是链接脚本，文件扩展名一般为 .ld，链接参数 -T，用法如：-Txxx.ld），简单的 IAP 则建议不用它，使用 keil 图形化配置即可（下图）。更多 scatter 分散加载文件知识以后再深入了解，可参考下面几篇网文： 网文 1：《如何在C代码中获取编译后的BIN文件的大小》 网文 2：《keil如何生成scatter文件》 网文 3：《试图搞懂MDK程序下载到flash(二)–分散加载文件scatter》《搞懂MDK的分散加载文件》 ","date":"2021-03-18","objectID":"/20210318/:0:4","tags":["ARM Cortex-M","Keil MDK"],"title":"获取 ARM 编译后的 ROM 及 RAM 大小方法及原理","uri":"/20210318/"},{"categories":["software"],"content":"介绍 X-MACRO 数据与代码序列化的原理及使用","date":"2020-12-24","objectID":"/20201224/","tags":["宏定义","X-MACRO"],"title":"X-MACRO 数据与代码序列化","uri":"/20201224/"},{"categories":["software"],"content":"概述 X-MACRO（X-宏）是一种可靠的维护代码或数据的并行列表技术，其保证这些并行列表以相同（匹配）顺序出现。它可应用于数组、枚举、结构体、列表，以及代码段生成等。X-MACRO 定义的是【汇总集合表】，当使用时可以从它【批量】取出某(几)类元素。 ","date":"2020-12-24","objectID":"/20201224/:0:1","tags":["宏定义","X-MACRO"],"title":"X-MACRO 数据与代码序列化","uri":"/20201224/"},{"categories":["software"],"content":"一、原理与语法 点击展开内容 typedef int (*PF)(void *); const PF pfunc[] = { func_play, func_pause, func_stop, func_play_next, func_play_prev }; 对于上面的数组，我们不希望使用pfunc[0]这种方式来访问，我们希望使用宏pfunc[PLAY]方式来访问，这样可以更直观明了。使用枚举enum {PLAY, PAUSE, STOP, PLAY_NEXT, PLAY_PREV}方式定义每个组员编号对应的宏，但是这样需要维护两个表（要匹配它们相同顺序相同个数），极容易出错。那么如何使用预编译为我们生成组员编号对应的宏呢？ 语法如下：（点击展开） //事先编排的宏与组员关系表（注：DEF_X() 还没有定义，后面使用时才定义-用完即时取消定义） #define XCMD_PFUNC \\ DEF_X(PLAY , func_play ) \\ DEF_X(PAUSE , func_pause ) \\ DEF_X(STOP , func_stop ) \\ DEF_X(PLAY_NEXT, func_play_next) \\ DEF_X(PLAY_PREV, func_play_prev) //利用预编译生成组员编号对应的宏(表)：enum {PLAY, PAUSE, STOP, PLAY_NEXT, PLAY_PREV} typedef enum { #define DEF_X(n,p) n, XCMD_PFUNC #undef DEF_X XCMD_MAX }tXCMD; //利用预编译生成指针数组(表)：pfunc[] = {func_play, func_pause, func_stop, func_play_next, func_play_prev} typedef int (*PF)(void *); const PF pfunc[] = { #define DEF_X(n,p) p, XCMD_PFUNC #undef DEF_X }; ","date":"2020-12-24","objectID":"/20201224/:0:2","tags":["宏定义","X-MACRO"],"title":"X-MACRO 数据与代码序列化","uri":"/20201224/"},{"categories":["software"],"content":"二、通讯的用法 点击展开内容 当我们设计一个播放器时，通过串口开放给第三方控制时，我们协议一般是定义为命令+参数，通过不同的命令来控制播放器执行不同的动作。对命令解码的写法演变如下： 1、常规写法：（点击展开） 这种写法代码结构单一、执行效率高（前提：命令连续），但可读性差、耦合性过高、难维护。 补充说明：此代码不完整，只是为了展示写法。 switch (cmd) { case 0: //播放 /* 略（执行代码 或 调用控制函数） */ break; case 1: //暂停 /* 略（执行代码 或 调用控制函数） */ break; case 2: //停止 /* 略（执行代码 或 调用控制函数） */ break; case 3: //下一曲 /* 略（执行代码 或 调用控制函数） */ break; case 4: //上一曲 /* 略（执行代码 或 调用控制函数） */ break; default: break; } 2、查表写法：（点击展开） 这种写法代码结构简单，可读性好、耦合低、容易维护、灵活、支持命令不连续，不过查表会对效率有一定损耗。 补充说明：此代码不完整，只是为了展示写法。 #define XCMD_PLAY 0 #define XCMD_PAUSE 1 #define XCMD_STOP 2 #define XCMD_PLAY_NEXT 3 #define XCMD_PLAY_PREV 50 struct _tFunc { unsigned char cmd; //命令 int (*pfunc)(void *); //对应执行函数(指针) }; struct _tFunc pfunc[] = { /*------平常只需维护此表-------*/ {XCMD_PLAY , func_play }, {XCMD_PAUSE , func_pause }, {XCMD_STOP , func_stop }, {XCMD_PLAY_NEXT, func_play_next}, {XCMD_PLAY_PREV, func_play_prev} } void player_cmd(unsigned char cmd, void *p) { int i; for (i=0; i\u003csizeof(pfunc)/sizeof(pfunc[0]); i++) { //查表，对效率有一定损耗 if ((pfunc[i].cmd == cmd) \u0026\u0026 (pfunc[i].pfunc != NULL)) { (*pfunc[cmd])(p); return; } } printf(\"cmd(%d) invalid!\\r\\n\", cmd); } 3、X 宏写法：（点击展开） 这种写法代码结构简单、执行效率高，可读性好、耦合低、容易维护，但要求命令必须是连续的。 补充说明：此代码不完整，只是为了展示写法。 #include \u003cstdio.h\u003e //事先编排的宏与组员关系表： /*----------平常只需维护此表----------*/ #define XCMD_PFUNC \\ DEF_X(XCMD_PLAY , func_play ) \\ DEF_X(XCMD_PAUSE , func_pause ) \\ DEF_X(XCMD_STOP , func_stop ) \\ DEF_X(XCMD_PLAY_NEXT, func_play_next) \\ DEF_X(XCMD_PLAY_PREV, func_play_prev) //利用预编译生成函数声明： #define DEF_X(n,p) extern int p(void *); XCMD_PFUNC #undef DEF_X //利用预编译生成组员编号对应的宏(表)： typedef enum { #define DEF_X(n,p) n, XCMD_PFUNC #undef DEF_X XCMD_MAX }tXCMD; //利用预编译生成指针数组(表)： typedef int (*PF)(void *); const PF pfunc[] = { #define DEF_X(n,p) p, XCMD_PFUNC #undef DEF_X }; //命令解码函数 int func_play(void *p) { printf(\"%s() decode\\r\\n\", __FUNCTION__); } int func_pause(void *p) { printf(\"%s() decode\\r\\n\", __FUNCTION__); } int func_stop(void *p) { printf(\"%s() decode\\r\\n\", __FUNCTION__); } int func_play_next(void *p) { printf(\"%s() decode\\r\\n\", __FUNCTION__); } int func_play_prev(void *p) { printf(\"%s() decode\\r\\n\", __FUNCTION__); } //应用与演示 void player_cmd(tXCMD xcmd, void *p) { // xcmd -= 20; //偏移量移到0点位置 if (xcmd \u003c XCMD_MAX) { //直接访问，高效 (*pfunc[xcmd])(p); } else { printf(\"xcmd(%d) invalid!\\r\\n\", xcmd); } } int main(int argc, char *argv[]) { player_cmd(XCMD_PLAY, (void *)0); player_cmd(XCMD_PAUSE, (void *)0); player_cmd(XCMD_PLAY_NEXT, (void *)0); } ","date":"2020-12-24","objectID":"/20201224/:0:3","tags":["宏定义","X-MACRO"],"title":"X-MACRO 数据与代码序列化","uri":"/20201224/"},{"categories":["software"],"content":"三、数据的重构 点击展开内容 在通讯应用中，我们往往使用字节对齐方式定义数据结构体。某特殊情况下，为了提高数据处理效率，我们会把以单字节对齐数据结构体转成默认的多字节对齐数据结构体。利用 X-Macros 实现数据重构，可方便以后代码维护。注意：对有嵌套的结构体可能不支持，但你可以增加宏参数指出特别处理，因为它的灵活性超乎你的想像！ 语法如下：（点击展开） #define XSTRUCT_DATA \\ DEF_XDATA(x, unsigned char) \\ DEF_XDATA(y, unsigned short) \\ DEF_XDATA(z, int) //多字节对齐--------------------------------------- typedef struct { #define DEF_XDATA(var, type) type var; XSTRUCT_DATA #undef DEF_XDATA }tXDATA1; //单字节对齐--------------------------------------- #pragma pack(push,1) //(push)与(pop)要配对, 可以嵌套 typedef struct { #define DEF_XDATA(var, type) type var; XSTRUCT_DATA #undef DEF_XDATA }tXDATA2; #pragma pack(pop) //重构 tXDATA2 数据到 tXDATA1 结构体 void xdata2_to_xdata1(tXDATA1 *const pxdat1, const tXDATA2 *const pxdat2) { #define DEF_XDATA(var, type) \\ memcpy(\u0026(pxdat1-\u003evar), \u0026(pxdat2-\u003evar), sizeof(pxdat1-\u003evar)); XSTRUCT_DATA #undef DEF_XDATA } //重构 tXDATA1 数据到 buffer[] 缓冲 void xdata1_to_buf(unsigned char *buffer, const tXDATA1 *const pxdat1) { #define DEF_XDATA(var, type) \\ memcpy(buffer, \u0026(pxdat1-\u003evar), sizeof(pxdat1-\u003evar)); \\ buffer += sizeof(pxdat1-\u003evar); XSTRUCT_DATA #undef DEF_XDATA } //重构 buffer[] 数据到 tXDATA1 缓冲 void buf_to_xdata1(tXDATA1 *const pxdat1, const unsigned char *buffer) { #define DEF_XDATA(var, type) \\ memcpy(\u0026(pxdat1-\u003evar), buffer, sizeof(pxdat1-\u003evar)); \\ buffer += sizeof(pxdat1-\u003evar); XSTRUCT_DATA #undef DEF_XDATA } ","date":"2020-12-24","objectID":"/20201224/:0:4","tags":["宏定义","X-MACRO"],"title":"X-MACRO 数据与代码序列化","uri":"/20201224/"},{"categories":["software"],"content":"四、知识的扩展 点击展开内容 从上面的例子可以看到，宏定义每行都使用了＼续行符，正常情况是没有什么影响的，但当要想使用#if这些预编译判断语句时，这样就出现问题了（因为#if要求必须是单独占一行，不能与其它语句共用一行）。那么如何解决这个限制问题？用#include包含功能来解决！以播放器为例说明，它有两个版本，新版本才支持上一曲控制： 语法如下：（点击展开） 新建《xmacro.h》文件，在里面添加内容： //《xmacro.h》 DEF_X(PLAY , func_play ) DEF_X(PAUSE , func_pause ) DEF_X(STOP , func_stop ) DEF_X(PLAY_NEXT, func_play_next) #if (SWF_VER == 2) DEF_X(PLAY_PREV, func_play_prev) #endif 使用#include来解决＼续行符限制问题： typedef enum { #define DEF_X(n,p) n, #include \"xmacro.h\" #undef DEF_X XCMD_MAX }tXCMD; typedef int (*PF)(void *); const PF pfunc[] = { #define DEF_X(n,p) p, #include \"xmacro.h\" #undef DEF_X }; 上面只是一些基本功能应用，其实还有很多就高级应用。X-MACRO 里面的内容你尽情利用，你可以用它来生成函数名称、变量声明等，它只是保证为你生成一段相同顺序的东西（数据、代码、声明等）。下面简单做了几个例子，更多应用等你发掘。 例子如下：（点击展开） //打印出所有函数名称 void print_finc(void) { #define DEF_X(n,p) printf(\"int %s(void *)\\n\", #p); XCMD_PFUNC #undef DEF_X } //利用预编译生成函数声明： #define DEF_X(n,p) extern int p(void *); XCMD_PFUNC #undef DEF_X //生成另一组功能函数声明： #define DEF_X(n,p) extern int callback_##p(void *); XCMD_PFUNC #undef DEF_X ","date":"2020-12-24","objectID":"/20201224/:0:5","tags":["宏定义","X-MACRO"],"title":"X-MACRO 数据与代码序列化","uri":"/20201224/"},{"categories":["software"],"content":"介绍 CRC 数据校验原理和应用","date":"2020-12-12","objectID":"/20201212/","tags":["CRC"],"title":"CRC 数据校验原理和应用","uri":"/20201212/"},{"categories":["software"],"content":"一、简介 CRC 循环冗余校验（Cyclic Redundancy Check） 是一种根据网络数据包或计算机文件等数据产生简短固定位数校验码的一种信道编码技术，主要用来检测或校验数据传输或者保存后可能出现的错误。它是利用除法及余数的原理来作错误侦测的。CRC 成为计算机信息通信领域最为普遍的校验方式。常见应用有以太网/USB通信，压缩解压，视频编码，图像存储，磁盘读写等。 常用的校验算法 有奇偶校验、校验和、CRC，还有 LRC、BCC 等不常用的校验算法。 常规数据帧格式 帧头 + 长度 + 数据 + 校验 ","date":"2020-12-12","objectID":"/20201212/:0:1","tags":["CRC"],"title":"CRC 数据校验原理和应用","uri":"/20201212/"},{"categories":["software"],"content":"二、原理 点击展开内容 单纯谈 CRC 的 模 2 除法 其实并不困难，但实际计算中经常会遇到计算出来的结果和实际不一致的情况，这就需要我们知道几个组成部分或者说计算概念：多项式公式、多项式简记式、数据宽度、初始值、输入值反转、输出值反转、结果异或值、参数模型。 多项式公式 对于 CRC 标准除数，一般使用多项式（或二项式）公式表示，例如除数 11011 的二项式为 X4+X3+X+1，X 的指数就代表了该 bit 位上的数据为 1。 多项式简记式（POLY） 通过对 CRC 的基本了解我们知道，多项式的头部和首尾必定为 1，所以就把头部这个 1 给省略掉了，出现了一个叫简记式的东西，例如除数 11011 的简记式为 1011。对于CRC_16标准下 X16+X15+X2+1（0x18005）的 poly 值实际上是 8005，这里使用的就是简记式。 数据宽度（WIDTH） 数据宽度指的就是 CRC 校验码的长度（二进制位数），知道了 CRC 的运算概念和多项式，就可以理解这个概念了，CRC 长度始终要比除数位数少1，与简记式长度是一致的。 ① CRC 初始值（INIT） 在一些标准中，规定了运算寄存先赋初始值，之后才会与原始数据进行运算。初始值位数要求与数据宽度一致。 ② 输入值反转（REFIN - 是/否） 输入值反转的意思是在计算之前先将二项式反转，之后一直用得到的新值和数据进行计算。如对于 X16+X15+X2+1（0x18005），其正向值为 1 1000 0000 0000 0101，反转值则为 1010 0000 0000 0001 1 ③ 输出值反转（REFOUT - 是/否） 输出值反转则是将与多项式运算后得到最终的 CRC 结果进行反转。例如计算得到的 CRC 值：0x97 = 1001 0111，如果 REFOUT 为 true，进行翻转之后为 1110 1001 = 0xE9。 通常，输入值反转后的结果值也会是反转的，所以这两个选项一般是同向的，我们只有在在线CRC计算器中会看到自由选择正反转的情况存在。 ④ 结果异或值（XOROUT） 在所有运算得出的最后 CRC 结果值与[结果异或值]进行一次异或计算，得到的最终值才是我们需要的 CRC 校验码。结果值的位数要求与数据宽度一致。 模2除法运算例子：设需要发送的信息为 1010001101，产生多项式为 110101（共6bit），则发送信息后面需要加5个0，然后对信息做模2除法运算，得余数为 01110。故实际需要发送的数据是 1010001101（信息）01110（校验）。 以上内容主要解析 CRC 基本概念及原理，下面三图才是实际使用的 CRC 种类和运算过程： ","date":"2020-12-12","objectID":"/20201212/:0:2","tags":["CRC"],"title":"CRC 数据校验原理和应用","uri":"/20201212/"},{"categories":["software"],"content":"三、使用 点击展开内容 比如由网友whik分享的C语言版本： https://gitee.com/whik/crc-lib-c 直接把“crcLib.c”“crcLib.h”加入工程使用即可。 uint16_t crc16; uint32_t crc32; unsigned char datasrc[13] = {12, 214, 234, 3, 4, 5, 89, 21, 48, 92, 14, 7, 10}; //要运算的数据 crc16 = crc16_usb(datasrc, sizeof(datasrc)); //计算CRC crc32 = crc32_mpeg_2(datasrc, sizeof(datasrc)); //计算CRC 补充说明： 为什么我们使用 STM32 处理器的 CRC 硬件运算器 与 crc32_mpeg_2()或 网上一些 CRC 计算工具计算的结果不一样？ 那是因为 STM32 处理器为小端数据处理方式，CRC 规则要求为大端数据处理方式；同时 STM32 处理器 CRC 硬件运算器以 4 字节对齐方式处理，最后几字节不足 4 字节需要用户补齐（如：补齐填充 0）。 标准的 CRC 函数的入口以及内部处理都是以字节作为基本处理单元，这样可避免出现大小端格式问题，所以用户调用计算函数时无须关心大小端问题。 ","date":"2020-12-12","objectID":"/20201212/:0:3","tags":["CRC"],"title":"CRC 数据校验原理和应用","uri":"/20201212/"},{"categories":["software"],"content":"四、工具 点击展开内容 CRC 在线计算工具 CRC 离线计算工具下载-CRC_Calc v0.1 CRC 离线计算工具下载-格西CRC计算器 ","date":"2020-12-12","objectID":"/20201212/:0:4","tags":["CRC"],"title":"CRC 数据校验原理和应用","uri":"/20201212/"},{"categories":["software"],"content":"简单介绍 MD5 对数据加密与校验的应用","date":"2020-12-11","objectID":"/20201211/","tags":["MD5"],"title":"MD5 对数据加密与校验","uri":"/20201211/"},{"categories":["software"],"content":"一、前言 对于网络传输的数据，无非就是三点要求：一、保证数据传输的正确性；二、防止数据被篡改；三、对数据进行加密。对于前两点要求，普遍使用 MD5 来处理。 ","date":"2020-12-11","objectID":"/20201211/:0:1","tags":["MD5"],"title":"MD5 对数据加密与校验","uri":"/20201211/"},{"categories":["software"],"content":"二、介绍 点击展开内容 MD5 的全称是 Message-Digest Algorithm 5，在90年代初由 MIT 的计算机科学实验室和 RSA Data Security Inc 发明，经 MD2、MD3 和 MD4 发展而来。MD5 将任意长度的“字节串”变换成一个 128bit（即：16字节） 的大整数，相当于这串数据的“数据指纹”。主要用于确保信息传输完整一致，更多用在文档校验上，用来生成密钥检测文档是否被篡改。是计算机广泛使用的摘要算法（哈希算法）之一，主流编程语言普遍已有 MD5 实现。 MD5 算法具有以下特点： 压 缩 性：任意长度的数据，算出的 MD5 值长度都是固定的。 容易计算：从原数据计算出 MD5 值很容易。 抗修改性：对原数据进行任何改动，哪怕只修改1个字节，所得到的 MD5 值都有很大区别。 强抗碰撞：已知原数据和其 MD5 值，想找到一个具有相同 MD5 值的数据（即伪造数据）是非常困难的。 不可逆性：加密过程本身就是一个有损的加密过程，因此几乎不能还原出原始数据。 ","date":"2020-12-11","objectID":"/20201211/:0:2","tags":["MD5"],"title":"MD5 对数据加密与校验","uri":"/20201211/"},{"categories":["software"],"content":"三、用途 点击展开内容 本人理解它有三大类用途： 校验数据传输/存储是否出错。例如：我们使用电脑读取文件时，曾经就遇过提示文件破损。那么电脑如何知道文件破损了？其原理就是读文件前先运算 MD5 码，再与文件保存那时存储的 MD5 码进行比较，MD5 码不一样，那就说明文件破损了。 校验用户密码，保护用户隐私。例如：在手机输入登录某网站密码，手机 APP 发送的是由密码生成的 MD5 码给网站服务器。服务器则是使用用户注册密码生成的 MD5 码与手机 APP 发来的 MD5 码进行比较。如果一样，则表示密码正确。这样的好处是保护用户密码在传输过程中不被泄漏。（补注：实际应用中服务器是不保存用户原始密码，只保存 MD5 码，这样连服务器也不知道用户原始密码，可以更有效保护用户私隐） 校验证书的唯一性，防止证书或内容被篡改。例如：一个简单支付业务操作，把用户支付帐号、支付金额、支付密码拼接起来生成 MD5 码证书，最后把支付帐号、支付金额、MD5 码证书三项内容发给支付平台进行支付操作。因为坏人不知道你密码，如果他中途拦截并恶意篡修支付金额，但支付平台使用相同方法运算的 MD5 码证书发现不一致，就会拒绝本次支付操作，这样就有效地保护用户的支付安全。 ","date":"2020-12-11","objectID":"/20201211/:0:3","tags":["MD5"],"title":"MD5 对数据加密与校验","uri":"/20201211/"},{"categories":["software"],"content":"四、应用 点击展开内容 比如由网友 talent518 分享的 C 语言版本： https://github.com/talent518/md5 直接把“md5.c”“md5.h”加入工程使用即可。 MD5_CTX md5; //MD5对象 unsigned char datasrc[13] = {12, 214, 234, 3, 4, 5, 89, 21, 48, 92, 14, 7, 10}; //要运算的数据 unsigned char decrypt[16]; //结果寄存器 //每次运算 MD5 码，必须依次调用 3 个函数进行操作 MD5Init(\u0026md5); //初始化 MD5Update(\u0026md5, datasrc, sizeof(datasrc)); //导入数据（此处可以多次导入多段数据） MD5Final(\u0026md5, decrypt); //计算并输出 16 字节 MD5 到 decrypt[] ","date":"2020-12-11","objectID":"/20201211/:0:4","tags":["MD5"],"title":"MD5 对数据加密与校验","uri":"/20201211/"},{"categories":["linux"],"content":"linux 编译构建工具使用","date":"2020-09-15","objectID":"/20200915/","tags":["编译","GNU","GCC","linux 工具/应用"],"title":"linux 编译构建工具","uri":"/20200915/"},{"categories":["linux"],"content":"前言 Linux 下可用的编译器有 GCC、EGCS 和 PGCC，其中 GCC 是绝对的老大（不接受反驳）！GCC（GNU Compiler Collection）是由 GNU 开发的编程语言译器套件。GNU 编译器套件包括 C、C++、Objective-C、Fortran、Ada、Go 及 D 语言前端，也包括了这些语言的库（如：libstdc++，libgcj 等） 1、关于工具链关系 ●CMake是一种跨平台编译构建工具，其将程序员编写 CMakeLists.txt 文件转化 makefile 文件，最后调用 make 命令执行相关工作。 ●make是一个脚本工具，用于解释执行 Makefile 脚本的命令工具。 ●makefile是脚本语言，用于描述了整个工程的编译、链接等规则，调用 GCC（也可以是其它编译器）命令执行编译、链接动作。 ●gcc是编译器，用于编译源文件，链接生成执行文件。 ●gdb是调试器，用于调试 c/c++ 程序，也可以调试 Ada、Objective-C、Pascal 及其它语言。 2、关于交叉编译器 GNU 的 GCC 主要用于编译电脑软件，主要针对 x86 体系的处理器；对于 ARM 、MIPS 等体系的处理器，我们需要使用交叉编译器（如：arm-none-linux-gnueabi-gcc）来编译，其过程：先在电脑上使用交叉编译器编译生成执行文件，再将执行文件复制/烧录到控制板上运行。 3、工具或源码下载 工具 源码包 make 官网下载、清华镜像 gcc 官网下载、清华镜像 ","date":"2020-09-15","objectID":"/20200915/:0:1","tags":["编译","GNU","GCC","linux 工具/应用"],"title":"linux 编译构建工具","uri":"/20200915/"},{"categories":["linux"],"content":"一、gcc 编译器 1、linux 系统下安装 ● 1.1、Ubuntu 系统下的在线安装 在 Ubuntu 下安装 GCC 和其他一些 Linux 系统有点不一样。默认的 Ubuntu 存储库包含一个名为build-essential的元包，它包含 GCC 编译器以及编译软件所需的许多库和其他实用程序。 #####方法一##### sudo apt update #首先更新包列表， sudo apt install build-essential #安装`build-essential`软件包， gcc --version #查看 gcc 版本用于验证是否安装成功。 #####方法二##### # sudo apt-get build-dep gcc #安装`gcc` # gcc -v #查看 gcc 版本用于验证是否安装成功。 #####方法三##### # sudo apt-get install gcc #安装`gcc` # sudo apt-get install g++ #安装`g++` # gcc -v #查看 gcc 版本用于验证是否安装成功。 1.2、Ubuntu 下在线安装最新版 因为个别工程需要多个 GCC 的编译器或者是库来支持，我们可能需要在同一个 Linux 系统当中安装多个 GCC 版本来实现支持的目的。从低版本到高版本，以及最新版本的 GCC，都可从 Ubuntu Toolchain PPA 获得。虽然 Ubuntu 官方软件仓库尽可能囊括所有的开源软件，但仍有很多软件包由于各种原因不能进入官方软件仓库，为了方便 Ubuntu 用户使用，Ubuntu 为软件开发者提供了 launchpad 平台来创建自己的 repositories（仓库）提供了个人软件包集，即 PPA（Personal Package Archives）个人软件包档案。从网上找到的 ppa:ubuntu-toolchain-r/test 支持很多 gcc 版本，列表【Package】项表示 gcc 软件包名称，【Version】项表示具体版本及支持 Ubuntu 版本，例如：版本10.3.0-1ubuntu1~20.04表示 gcc 10.3.0 以及支持 Ubuntu 20.04（备注：原以为支持 1~20.04 全部版本，结果测试 Ubuntu 16.04 提示找不到软件包，即是只支持 Ubuntu 20.04）。其实从 gcc 官网也找到此作者的仓库，其路径：https://gcc.gnu.org\u003e\u003eDownload\u003e\u003eBinaries → GFortran Wiki → GNU/Linux\u003e\u003eMost Linux distributions offer gfortran packages → Ubuntu\u003e\u003eminor updates（小更新）或 new testing versions（新的测试版本）。 #####安装仓库以及gcc##### sudo apt install software-properties-common #安装`PPA`仓库工具（只需安装一次） sudo add-apt-repository ppa:ubuntu-toolchain-r/test #加入`PPA`仓库 sudo apt update #更新`PPA`仓库信息 sudo apt install gcc-9 g++-9 #安装`GCC`和`G++`(需要安装什么版本就输入什么版本) #如果没找到软件包，则提示“E: Unable to locate package XXX” #####加gcc版本优先级#### sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-9 90 --slave /usr/bin/g++ g++ /usr/bin/g++-9 sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-5 999 --slave /usr/bin/g++ g++ /usr/bin/g++-5 #我的系统 Ubuntu 16.04 已安装官方版本为：gcc 5.4.0，上面的 --slave 的 g++ 表示的默认版本由 gcc 配置决定 #####配置gcc默认版本#### sudo update-alternatives --config gcc #配置gcc默认版本，根据界面提示输入对应数字+回车选择 #####移除PPA仓库方法##### # sudo add-apt-repository --remove ppa:ubuntu-toolchain-r/test #####移除gcc版本优先级### # sudo update-alternatives --remove gcc /usr/bin/gcc-9 #移除 gcc 9 的优先级（将从优先级列表中移除） 1.3、Ubuntu 下自己编译与安装 待续…… 2、windows 下安装 ● 2.1、可选工具： ● GNU 并没提供 Windows 的 GCC 版本，但我们可以安装第三方制作的 GCC Windows 版本，其中集成 GCC 编译器的软件主要有：MinGW/MinGW-w64、TDM-GCC、Cygwin。 2.2、工具区别： ● MinGW/MinGW-w64（Minimalist GNU for Windows）是为 windows 系统打造的编译器套件，其主要是把 GNU 的 gcc、make 等编译工具移植到 Windows 平台下，使得原是在 linux 写的 C 源代码可以在 windows 上编译及运行（exe 执行文件）。 ● TDM-GCC 衍生自 MinGW 和 MinGW-w64 的项目（功能是一样的），也是分为 32 位与 64 位两个版本，32 位版本的编译目标仅兼容 32 位应用程序，64 位版本的编译目标兼容 32 和 64 位应用程序。TDM-GCC 对比 MinGW-w64 会集成更新的 gcc 编译器，目前集成的版本为 GCC 10.3.0。 ● Cygwin 是一个在 windows 平台上运行的类 unix 模拟环境，其集成绝大部分的 linux 软件包（其中就包括 GCC 编译工具）。 2.3、工具特点： ● Cygwin 大而全面，提供完整的类 Unix 环境，凡是在 Cygwin 环境中编译构建的软件在运行时必须依赖 cygwin1.dll 库文件。 ● MinGW / MinGW-w64 / TDM-GCC 小而高效，其主要是编译器，一般只支持编译使用 C/C++ 标准库的程序。 2.4、工具安装： ● 关于 Cygwin 的安装与使用，请移步《linux-工具-linux 模拟环境 cygwin》。 ● 关于 MinGW-w64 的安装与使用，请移步《MinGW-w64 编译套件(GNU 工具集)》。 ● 下载 TDM-GCC 编译工具，不需要勾选检测是否最新版本，直接点击Creat安装即可，最后在命令窗口输入gcc -v可查看 gcc 版本。特别说明：查看 make 版本的命令为mingw32-make -v。 3、GCC 的编译方法 ● 3.1、一步编译方法： gcc -o hello hello.c # 1步完成:预处理-\u003e编译-\u003e汇编-\u003e链接（可多个C文件编译） 3.2、两步编译方法： gcc -c -o hello.o hello.c -I./inc # 编译 (生成二进制机器码) → Makefile 中一般都是使用两步编译方式（[-I]为源文件的包含文件所在路径(如:头文件所在路径[./inc])）（绝大部分选项参数都在编译这里设置） gcc -o hello hello.o # 链接 (生成可执行文件)　→ Makefile 中一般都是使用两步编译方式（链接时常用选项参数：-Txxx.lds -Wl,-Map=xxx.map,--cref -Wl,--gc-sections） 3.3、多步编译方法： # ┌→指定生成文件名 （可多个C文件编译） gcc -E -o hello.i hello.c # 预处理(经过预处理的C原始程序) ┐ gcc -S -o hello.s hello.i # 编译 (编译生成汇编语言代码) ├→ ★助记★: 选项-\u003eESc, 生成文件-\u003eiso gcc -c -o hello.o hello.s # 汇编 (汇编生成二进制机器码) ┘ gcc -o hello hello.o # 链接 (链接生成可执行文件) 4、GCC 的编译参数 ● # 一些编译常用选项 gcc --version # 查看gcc版本 gcc -v # 查看gcc版本(包括配置参数信息) gcc -std=c99 hello.c -o hello # 使用[C99]标准编译（gcc 默认使用的是 C89 的标准，而 -std=gun99 是 GNU 的 C99，及 -std=gnu11 是 C11 与 GNU 的拓展）） gcc -static hello.c -o hello # 静态编译生成的可执行文件(优点:独立无依赖,缺点:文件很大) gcc -g hello.c -o hello # 在可执行程序中包含标准调试信息 gcc -O2 hello.c -o hello # 用[-O2]优化选项编译生成可执行文件(常用优化级别:-O0,-O1,-O2,-","date":"2020-09-15","objectID":"/20200915/:0:2","tags":["编译","GNU","GCC","linux 工具/应用"],"title":"linux 编译构建工具","uri":"/20200915/"},{"categories":["linux"],"content":"二、交叉编译器 1、交叉编译器命名规则 ● 1.1、arch(架构)-vendor(厂商)-os(系统)-eabi(接口) 分类 说明 arch（架构） 体系架构：ARM 、MIPS、x86 等 vendor（厂商） 工具链的供应商：苹果、none（无供应商）等 os（系统） 目标的操作系统：linux、none（裸机）等 eabi（接口） 嵌入式应用二进制接口：eabi、gnueabi 等 arch # 'ɑːrtʃ vendor # 'vendə(r) eabi # Embedded Application Binary Interface # ɪm'bedɪd 'baɪnəri 1.2、abi 与 eabi 的区别 ● ABI： 二进制应用程序接口。在计算机中，应用二进制接口描述了应用程序（或者其他类型）和操作系统之间或其他应用程序的低级接口。 ● EABI：嵌入式 ABI。嵌入式应用二进制接口指定了文件格式、数据类型、寄存器使用、堆积组织优化和在一个嵌入式软件中的参数的标准约定。开发者使用自己的汇编语言也可以使用 EABI 作为与兼容的编译器生成的汇编语言的接口。 ● 两者区别总结：ABI 用于计算机上，EABI 用于嵌入式平台上（如 ARM，MIPS 等）。 2、arm 框架交叉编译器 ● 2.1、armcc armcc 是 RM 公司推出的商用收费编译工具，功能和 arm-none-eabi-gcc 类似，用于编译裸机程序（u-boot、kernel、单片机程序），但是不能编译 Linux 应用程序。armcc 一般和 ARM 开发工具一起，例如 Keil MDK、ADS、RVDS 和 DS-5 中的编译器都是 armcc。 2.2、arm-none-eabi-gcc arm-none-eabi-gcc 为 ARM 框架、无供应商、无系统、嵌入式二进制接口，一般适合 ARM7、Cortex-M、Cortex-R 内核的芯片使用，它使用的是 newlib 这个专用于嵌入式系统的 C 库，用于编译裸机程序（u-boot、kernel、单片机程序），但是不能编译 Linux 应用程序。注意：交叉编译器目前都是 32 位执行程序，依赖 32 位库，事前需要安装 ia32-libs（网文）或 lsb-core。进入网页选择你需要的版本下载：官网最新版、官网 2021 版、Ubuntu-launchpad 软件开发者平台 及依赖 lsb-core。补充：关于 Windows 版本，为直接安装文件，双击安装即可，还有安装后需要手工加入环境变量【如图】。 wget https://launchpad.net/gcc-arm-embedded/5.0/5-2016-q3-update/+download/gcc-arm-none-eabi-5_4-2016q3-20160926-linux.tar.bz2 #下载交叉编译器压缩包 sudo tar -xjvf gcc-arm-none-eabi-5_4-2016q3-20160926-linux.tar.bz2 -C /usr/lib/gcc #将交叉编译器压缩包解压到：/usr/lib/gcc sudo gedit /etc/profile #打开环境变量,在文件最后添加内容：export PATH=$PATH:/usr/lib/gcc/gcc-arm-none-eabi-5_4-2016q3/bin source /etc/profile #使能环境变量。 sudo apt-get install lsb-core #64位操作系统需要安装32位依赖库：lsb-core （arm-none-eabi-gcc 用到） sudo apt-get install lib32ncurses5 #64位操作系统需要安装32位依赖库：lib32ncurses5（arm-none-eabi-gdb 用到） arm-none-eabi-gcc -v #查看版本(验证是否安装成功) #arm-none-eabi-gcc hello.c -o hello #编译一个程序例子 2.3、arm-none-linux-gnueabi-gcc arm-none-linux-gnueabi-gcc 是 Codesourcery 公司（目前已经被 Mentor 收购）基于 GCC（使用 Glibc 库）推出的的 ARM 交叉编译器。主要用于基于 ARM 架构的 Linux 系统，可用于编译 ARM 架构的 u-boot、Linux 内核、linux 应用等。一般 ARM9、ARM11、Cortex-A 内核，带有 Linux 操作系统的会用到。注意：交叉编译器目前都是 32 位执行程序，依赖 32 位库，事前需要安装 ia32-libs（网文）或 lsb-core。 wget http://www.codesourcery.com/sgpp/lite/arm/portal/package4571/public/arm-none-linux-gnueabi/arm-2014.05-29-arm-none-linux-gnueabi-i686-pc-linux-gnu.tar.bz2 #下载交叉编译器压缩包 sudo tar -xjvf arm-2014.05-29-arm-none-linux-gnueabi-i686-pc-linux-gnu.tar.bz2 -C /usr/lib/gcc #将交叉编译器压缩包解压到：/usr/lib/gcc sudo gedit /etc/profile #打开环境变量,在文件最后添加内容：export PATH=$PATH:/usr/lib/gcc/arm-2014.05/bin source /etc/profile #使能环境变量。 sudo apt-get install lsb-core #64位操作系统需要安装32位依赖库：lsb-core （arm-none-eabi-gcc 用到） sudo apt-get install lib32ncurses5 #64位操作系统需要安装32位依赖库：lib32ncurses5（arm-none-eabi-gdb 用到） arm-none-linux-gnueabi-gcc -v #查看版本(验证是否安装成功) #arm-none-linux-gnueabi-gcc hello.c -o hello #编译一个程序例子 不同系统/软件环境下的版本 ● Linux 解压版：在 Linux 系统（如：Ubuntu、RedHat 等）直接解压即可使用。推荐方式！ ● Linux 安装版：在 Linux 系统下执行后按照提示安装后使用。 ● Windows 解压版：在 Windows 系统下解压后使用，但是需要 MinGW32。 ● Windows 安装版：在 Windows 系统下安装后使用。 ● 源码版：交叉编译器源代码，按需编译生成相应版本。 下面为多种版本下载，同时增加网友博文提供的网盘下载： Linux 解压版 网友网盘 arm-2006q1-3-arm-none-linux-gnueabi-i686-pc-linux-gnu.tar.bz2 网盘 arm-2006q1-6-arm-none-linux-gnueabi-i686-pc-linux-gnu.tar.bz2 网盘 arm-2006q3-26-arm-none-linux-gnueabi-i686-pc-linux-gnu.tar.bz2 网盘 arm-2007q1-10-arm-none-linux-gnueabi-i686-pc-linux-gnu.tar.bz2 网盘 arm-2007q1-21-arm-none-linux-gnueabi-i686-pc-linux-gnu.tar.bz2 网盘 arm-2007q3-51-arm-none-linux-gnueabi-i686-pc-linux-gnu.tar.bz2 网盘 arm-2008q1-126-arm-none-linux-gnueabi-i686-pc-linux-gnu.tar.bz2 网盘 arm-2008q3-41-arm-none-linux-gnueabi-i686-pc-linux-gnu.tar.bz2 网盘 arm-2008q3-72-arm-none-linux-gnueabi-i686-pc-linux-gnu.tar.bz2 网盘 arm-2009q1-176-arm-none-linux-gnueabi-i686-pc-linux-gnu.tar.bz2 网盘 arm-2009q1-203-arm-none-linux-gnueabi-i686-pc-linux-gnu.bz2 网盘 arm-2009q3-67-arm-none-linux-gnueabi-i686-pc-linux-gnu.tar.bz2 网盘 arm-2010.09-50-arm-none-linux-gnueabi-i686-pc-linux-gnu.tar.bz2 网盘 arm-2010q1-202-arm-none-linux-gnueabi-i686-pc-linux-gnu.tar.bz2 网盘 arm-2011.03-41-arm-none-linux-gnueabi-i686-pc-linux-gnu.tar.bz2 网盘 arm-2012.09-64-arm-none-linux-gnueabi-i6","date":"2020-09-15","objectID":"/20200915/:0:3","tags":["编译","GNU","GCC","linux 工具/应用"],"title":"linux 编译构建工具","uri":"/20200915/"},{"categories":["linux"],"content":"三、make+Makefile 脚本 1、make、Makefile 关系 ● ● make是一个脚本工具，用于解释执行 Makefile 脚本的命令工具。 ● makefile是脚本语言，用于描述整个工程的编译、链接等规则，调用 GCC（也可以是其它编译器）命令执行编译、链接动作。脚本文件默认名称为 Makefile 或 makefile。 2、make 命令的使用方法 ● make 命令常用格式为：make [选项] [目标(操作)]。 make 命令是用来解释和执行 Makefile 脚本命令，所以[目标(操作)]是由 Makefile 脚本提供的，如果不指出则 make 工具默认使用 Makefile 中的第一个目标。 2.1、【目标】目标的名称约定常常有以下惯例： 目标名称 作用 all 表示编译所有并生成执行文件 install 表示安装刚刚生成的执行文件 clean 表示清除全部目标及执行文件 distclean 表示清除全部目标及执行文件，包括 Makefile dist 包装成一个压缩文件以供发布 distcheck 同上，并检查压缩包是否正常 2.2、【选项】选项参数较少用到，其主要包括： 选项 含义 -ffilename 指定执行名称为 filename 的 Makefile 文件 -Cdirname 指定执行目录为 dirname（Makefile 文件所在目录） -e 不允许在 Makefile 中替换环境变量的赋值 -k 执行命令出错时，放弃当前目标，继续维护其他目标 -n 按实际运行时的执行顺序模拟执行命令（包括用 @ 开头的命令），没有实际执行效果，仅仅用于显示执行过程 -p 显示 Makefile 中所有的变量和内部规则 -r 忽略内部规则 -s 执行但不显示命令，常用来检查 Makefile 的正确性 -S 如果执行命令出错就退出 -t 修改每个目标文件的创建日期 -I 忽略运行 make 中执行命令的错误 -V 显示 make 的版本号 2.3、【返回】make 命令执行后的三个返回码： 选项 含义 0 表示成功执行，则返回【0】 1 如果 make 运行时出现任何错误，则返回【1】 2 如果你使用了make的“-q”选项，并且 make 使得一些目标不需要更新，则返回【2】 2.4、【步骤】配置、编译、安装/卸载： 步骤 作用 configure 配置操作。configure 是一个 shell 脚本，它可以自动设定源程序以符合各种不同平台上 Unix 系统的特性，并且根据系统参数及环境产生合适的 Makefile 文件或是 C 的头文件，让源程序可以很方便地在这些不同的平台上被编译连接。待续…… make 编译操作（操作第一个目标） make install 安装操作 2.5、【使用】演示例子： 在命令窗口运行命令： make # 默认执行 Makefile 第一个目标 make all # 指定执行 Makefile 目标为 all（常见目标：all、install、clean） make -f mkf # 同`make` , 只是 Makefile 文件名称为 mkf make -f mkf all # 同`make all`，只是 Makefile 文件名称为 mkf 3、Makefile 的语法+例子 ● 3.1、【语法：基本知识】 3.1.1、Makefile 包含五项内容：1、显式规则，2、隐含规则，3、变量定义，4、文件指示，5、注释。 分类 使用 显式规则 书写者明显指出依赖文件或命令操作等规则 隐含规则 make 自动推导依赖文件或命令操作等规则 变量定义 变量只是定义一串字符串，其相当于宏定义 文件指示 预处理（引用另一个 Makefile、哪些代码不处理、变量定义处理） 注释 “#”为行注释符（没块注释，强烈建议独占一行并且在行首加“#”注释），如果需要使用“#”字符，则书写格式为\\# 3.1.2、Makefile 处理文件分为：目标、依赖。其中目标分为：实目标、伪目标。 分类 含义 实目标 真正要生成的以文件形式存放在磁盘上的目标（最终的目标只能是一个）。如果想生成多个实目标（文件），则在伪目标的依赖中加入若干个其它实目标（文件）。 伪目标 伪目标不要求生成实际的文件，它后面可以没有依赖文件（也可以加别的目标），它主要是用于完成一些辅助操作。其中典型案例：clean:清除操作。 多目标 一句依赖中有多个目标，它只是语法一种表达，实质多目标就是根据规则拆解为多个的单目标语句，目的只是简化书写。 关系 处理方式 目标与依赖的执行顺序关系 先执行最深层的依赖，再逐级往上执行目标！ 目标与依赖的搜索对象关系 只要目标有依赖，make 工具就会尝试在搜索目录中寻找依赖文件是否存在或者是否为别的目标。如果都为否，则 make 运行就会抛出错误！备注：Makefile 搜索目录为当前 Makefile 根目录及 VPATH、vpath 设置的目录。 目标与依赖的路径定义关系 目标文件在书写时没写明路径表示为当前 Makefile 根目录文件，否则就是指定目录文件。依赖文件没写明路径时由 Makefile 搜索目录中找出文件（没找出就默认为当前 Makefile 根目录文件），否则就是指定目录中找出文件（没找出也是认为书写的指定目录文件）；如果最后依赖文件没找出时，就会从另一个同路径同名称的目标中尝试生成！总结：对于实目标和实依赖，都必须现场得出确定的路径，之后才可以进一步的操作。备注：Makefile 搜索目录为当前 Makefile 根目录及 VPATH、vpath 设置的目录。 目标与依赖的规则执行关系 只有目标文件不存在或依赖文件更新（依赖新于目标），才会去运行规则(执行他们下面的操作命令)！对于编译工作来说，依赖就是代码的源文件与头文件，只有依赖文件发生改变，才会编译更新目标，否则不执行（会提示：无更新或已更新）！如果想重新全编译，则需要删除全部中间目标文件再运行编译！ 目标与依赖的包含文件关系 当使用 include 包含文件时，还会运行固有规则：搜索与包含文件同路径同名称的目标并尝试运行规则！具体有如下：只有当【包含文件存在】并且【没找到对应目标 或者 找到同路径同名称新于规则的实目标(实目标新于依赖、实目标无依赖)】才放弃运行规则，否则必定运行规则(它优先在用户操作的所有目标前执行，它总是会尝试创建或更新包含文件)。除上面情形外，当出现包含文件不存在、或找不到对应目标都会抛出错误！ 3.1.3、Makefile 整体执行顺序： 整体执行顺序 1、读入主 Makefile 2、读入被include包含进来的其他 Makefile 3、初始化文件中的变量 4、推导隐含规则，并分析所有规则 5、为所有的目标文件创建依赖关系链 6、根据依赖关系，决定哪些目标要重新生成 7、执行生成命令 3.1.4、Makefile 几个重要特殊字符：$ # ; \\ % * ? ~ -。 特殊字符 作用 $$$$ 随机号，自动产生的一个随机编号 $$ 变量符，是访问一个 shell 命令中定义的变量（如：$$var），而非 makefile 的变量。如果某规则在同一个 shell 运行多条命令，则这些命令之间使用“;”连接起来，这样命令相互之间共享变量；否则（多行命令或空格分隔命令）相互之间为没有关联的 shell 命令，不能共享变量 $ 变量符，定义一串字符串，其相当于宏定义。如：$(abc) 表示变量 abc # 注释符，如果通过 \\# 转义则为普通的 # 字符 ; 分隔符，命令与命令之间加入“;”，表示同一 shell 执行命令，可继承前面命令结果（典型例子：cd ~/123/ ; pwd 则结果是“~/123/”，否则是原目录下！） \\ 转义符 或 换行符（注意：换行符后面不能有任何字符，包括空格！） % 通配符，表示匹配零个或若干字符 * 所有符，表示任意一个或多个字符。如：*.c 表示所有 C 文件 ? 任一符，表示任意一个字符 或 对新的变量或文件执行操作 ~ 家目录。也可以指定用户目录（~xiaomin/test 表示用户 xiaomin 的宿主目录下的 test 目录），但 windows 系统需要由环境变量“HOME”决定 3.1.5、Makefile 命令前缀 命令前缀 作用 不加前缀 输出（打印）命令本身，输出（打印）命令执行的结果 @ 在命令前面加@，表示只输出命令执行的结果，不输出命令本身 - 在命令前面加-，表示忽略 Makefile 因命令出错而终止运行，典型应用：-include包含源码文件依赖信息，在源码文件依赖信息文件没创建(不存在)时忽略错误 3.1.6、Makefile 常用文件类型： 文件类型 unix/linux windows 描述 源文件 .c… .c… 源代码文件 关系文件 .d .d 源文件依赖关系信息，GNU 组织建议用编译器为每一个源文件自动生成依赖关系的内容放到一个文件中 中间文件 .o .obj 中间目标文件，是二进制机器码，把它们链接起来就是执行文件 库文件 .a .so .lib .dll 由于源文件太多，编译生成的中间目标文件太多，或是某个相对独立功能模块，可以打包为一个库文件 执行文件 .exe 执行文件 3.1.7、Makefile 的基本语法： target: prerequisites # 目标: 依赖(可多个文件)。（注：只要声明目标，则表明新的语段开始） command # 命令，前面必须加【tab键】 command1 ; co","date":"2020-09-15","objectID":"/20200915/:0:4","tags":["编译","GNU","GCC","linux 工具/应用"],"title":"linux 编译构建工具","uri":"/20200915/"},{"categories":["linux"],"content":"四、相关的编译构建工具 CMake XMake Meson SCons BusyBox 待续…… ","date":"2020-09-15","objectID":"/20200915/:0:5","tags":["编译","GNU","GCC","linux 工具/应用"],"title":"linux 编译构建工具","uri":"/20200915/"},{"categories":["software"],"content":"简单介绍面向对象的 C 语言实现方法","date":"2020-09-13","objectID":"/20200913/","tags":["面向对象"],"title":"面向对象的 C 语言实现方法","uri":"/20200913/"},{"categories":["software"],"content":"一、前言 面向对象编程，也就是大家说的 OOP（Object Oriented Programming）。面向对象的三个基本特征：封装、继承、多态。 封装：根据职责将属性(参数)和方法(函数)封装到一个抽象的类中。 继承：指可以让某个类型的对象获得另一个类型的对象的属性的方法。 多态：以封装和继承为前提，相同的方法调用不同的子类对象，产生不同的执行结果。 备注：本文只是简单介绍面向对象的概念，以及使用 C 语言实现的方法，为以后介绍一些面向对象功能模块打基础。 ","date":"2020-09-13","objectID":"/20200913/:0:1","tags":["面向对象"],"title":"面向对象的 C 语言实现方法","uri":"/20200913/"},{"categories":["software"],"content":"二、封装 点击展开内容 封装：根据职责将属性(参数)和方法(函数)封装到一个抽象的类中。以显示屏作为一个例子，显示屏最重要一个 属性(参数) 是分辨率大小，它最基本几个操作（方法(函数)）是初始化、读、写： 补充说明：显示屏的读写操作入口参数还有其它参数（如：x、y 坐标等），这里为了简单，不深入显示屏具体操作。 ","date":"2020-09-13","objectID":"/20200913/:0:2","tags":["面向对象"],"title":"面向对象的 C 语言实现方法","uri":"/20200913/"},{"categories":["software"],"content":"三、继承 点击展开内容 继承：指可以让某个类型的对象获得另一个类型的对象的属性的方法。继承与派生区别：只是角度不同，继承是从子类的角度讲的，派生是从基类的角度讲的。 以显示屏作为一个例子，新进了一个显示屏，其硬件支持待机操作： 补充说明：如果子类想操作父类的一些操作，只需把子类指针强制转成父类指针，之后按父类操作规范操作即可。 ","date":"2020-09-13","objectID":"/20200913/:0:3","tags":["面向对象"],"title":"面向对象的 C 语言实现方法","uri":"/20200913/"},{"categories":["software"],"content":"四、多态 点击展开内容 多态：以封装和继承为前提，相同的方法调用不同的子类对象，产生不同的执行结果。以显示屏作为一个例子，支持多种接口类型显示屏： ","date":"2020-09-13","objectID":"/20200913/:0:4","tags":["面向对象"],"title":"面向对象的 C 语言实现方法","uri":"/20200913/"},{"categories":["linux"],"content":"linux 集成开发工具 Eclipse 安装与使用","date":"2020-08-04","objectID":"/20200804/","tags":["Eclipse","IDE","linux 工具/应用"],"title":"linux 开发工具 Eclipse","uri":"/20200804/"},{"categories":["linux"],"content":"Eclipse 简介 Eclipse 是一个开放源代码的、基于 Java 的可扩展开发平台。就其本身而言，它只是一个框架和一组服务，用于通过插件组件构建开发环境。 ","date":"2020-08-04","objectID":"/20200804/:0:1","tags":["Eclipse","IDE","linux 工具/应用"],"title":"linux 开发工具 Eclipse","uri":"/20200804/"},{"categories":["linux"],"content":"Ubuntu 平台 系统版本：16.04.7（ubuntu-16.04.7-desktop-amd64.iso） 软件版本：4.14.0（eclipse-cpp-2019-12-R-linux-gtk-x86_64.tar.gz）【官网最新版】【4.14各种开发语言版】 官方网址：https://www.eclipse.org 软件依赖：JDK（因为 Eclipse 是用 Java 编写的 IDE） 软件简介 ● Eclipse 是一个用 Java 所撰写 IDE，因此可跨平台，所以在 Linux 和 Windows 平台下皆可使用 Eclipse，可降低程序员熟悉 IDE 的学习曲线。Eclipse 虽然主要拿来开发 Java 程序，但事实上 Eclipse 为一个『万用语言』的 IDE，只要挂上 plugin 后，就可以在 Eclipse 开发各种语言程序，所以我们只要挂上 CDT(C/C++ Development Toolkit) 后，就可以在 Eclipse 开发 C/C++ 程序了。（具体介绍请查看百度百科） 版本说明 ● 经常用到的是前五个版本： Eclipse IDE for Java EE Developers：是为 J2EE 开发的版本； Eclipse Classic：是 Eclipse 的经典版本(纯净版)，没有插件需要自己安装； Eclipse IDE for Java Developers：适用于 Java 开发； Eclipse IDE for C/C++ Developers：适用于 C/C++ 开发； Eclipse for Mobile Developers：适用于 Java 手机开发； Eclipse for RCP/Plug-in Developers：用于 RCP 和插件开发； 不同的 Eclipse 版本之间就是 plugins/features 目录下的文件不同而已。 初时安装 Eclipse 2020-06 (4.16)，使用时出现各种各样问题，基于兼容性稳定性以及插件支持度考虑，最后选用大约半年前一个版本：Eclipse 2019-12 (4.14) 来安装（使用过程中暂未发现问题）。 Eclipse 的发行版本： 代号 平台版本 项目 主要版本发行日期 N/A 3.0 [1] N/A 2004-6-21 N/A 3.1 N/A 2005-6-28 Callisto 3.2 Callisto projects 2006-6-30 Europa 3.3 Europa projects 2007-6-29 Ganymede 3.4 Ganymede projects 2008-6-25 Galileo 3.5 Galileo projects 2009-6-24 Helios 3.6 Helios projects 2010-6-23 Indigo 3.7 Indigo projects 2011-6-22 Juno 4.2 [2] Juno projects 2012-6-27 Kepler 4.3 Kepler projects 2013-6-26 Luna 4.4 Luna projects 2014-6-25 Mars 4.5 Mars projects 2015-6-24 Neon 4.6 2016-6-22 Oxygen 4.7 2017-6-28 Photon 4.8 2018-6-27 4.9 2018-09 4.10 2018-12 4.11 2019-03 4.12 2019-06 4.13 2019-09 4.14 2019-12 4.15 2020-03 4.16 2020-06 安装步骤 ● 3.1. 将压缩包解压（如图） # 解压 eclipse 压缩包到 opt 文件夹 sudo tar -zxvf eclipse-cpp-2019-12-R-linux-gtk-x86_64.tar.gz -C /opt 3.2. 制作启动脚本（如图） # 在/usr/bin目录下创建一个启动脚本eclipse，执行下面的命令来创建： sudo gedit /usr/bin/eclipse # 然后在该文件中添加以下内容（注意：#!/bin/sh 后必须使用 \\n 来换行!）： #!/bin/sh export MOZILLA_FIVE_HOME=\"/usr/lib/mozilla/\" export ECLIPSE_HOME=\"/opt/eclipse\" $ECLIPSE_HOME/eclipse $* # 再修改该脚本的权限，让它变成可执行，执行下面的命令： sudo chmod +x /usr/bin/eclipse 3.3. 添加应用图标（如图） # 在应用程序菜单上添加一个图标，执行下面的命令： sudo gedit /usr/share/applications/eclipse.desktop # 然后在该文件中添加以下内容（注意：行尾不能有空格!）： [Desktop Entry] Encoding=UTF-8 Name=Eclipse Comment=Eclipse IDE Exec=/opt/eclipse/eclipse Icon=/opt/eclipse/icon.xpm Terminal=false StartupNotify=true Type=Application Categories=Application;Development; # 再修改该应用图标的权限，让它变成可执行，执行下面的命令： sudo chmod +x /usr/share/applications/eclipse.desktop 网文：《Linux Desktop Entry 文件深入解析》，IBM Developer 中文网站，专为开发者打造的技术资源平台。 3.4. 运行应用方法（如图） 点击左上角的 Search your computer 功能图标，再输入 Eclipse，单击下面显示 Eclipse 图标打开即可。 3.5. 创建桌面启动（如图） 在 /usr/share/applications 目录下将 Eclipse 图标右键复制到桌面，双击桌面图即可打开软件。 3.6. 相关注意事项 如果按照上述方法安装了 eclipse 后能够创建图标但是运行不起来 eclipse，就可能是 Linux 位数与 Eclipse 的位数不一致！我就因为一时疏忽遇到这个问题，浪费了很多时间。 运行工程 ● 以 littlevGL/LVGL 开源的 GUI 演示工程作为例子说明 Eclipse 的基本使用： 4.1. 先从 github 下载 LVGL 整套 Eclipse 工程代码（网址） # 克隆LVGL项目（注：--recursive 用于把当前项目依赖的一些项目同时下载下来） git clone --recursive https://github.com/littlevgl/pc_simulator_sdl_eclipse.git 补注：关于 git 相关知识，请查《git学习笔记》。 4.2. 安装 gcc 和 g++ 编译工具链 sudo apt-get install gcc g++ 4.3. 安装 SDL 库（官网） 介绍：SDL 库的作用说白了就是封装了复杂的视音频底层操作，简化了视音频处理的难度。SDL（Simple DirectMedia Layer）是一套开放源代码的跨平台多媒体开发库，使用 C 语言写成。SDL 提供了数种控制图像、声音、输出入的函数，让开发者只要用相同或是相似的代码就可以开发出跨多个平台（Linux、Windows、Mac OS X 等）的应用软件。目前 SDL 多用于开发游戏、模拟器、媒体播放器等多媒体应用领域。SDL 使用 GNU 宽通用公共许可证为授权方式，意指动态链接（dynamic link）其库并不需要开放本身的源代码。因此诸如《雷神之锤4》等商业游戏也使用 SDL 来开发。 网文：《SDL 库安装、环境配置与使用》 sudo apt-get update \u0026\u0026 sudo apt-get install -y build-essential libsdl2-dev 4.4. 安装 CDT 插件（如图）（官网） 插件介绍：因为 Eclipse 是用 Java 开发的，其原设计主要进行 Jave 开发。如果要进行 C/C++ 开发，则需要安装一个 CDT 插件，不过现在官方已把 CDT 插件集成到了安装包里，可以在官网选择【Eclipse IDE for C/C++ Developers】下载就可以了。 手动安装： a) 在菜单打开：Help / Install New Software… / Add（进入另一个窗口操作） b) 在窗口上输入内容并点击 Add 按钮（本例 CDT 版本只能匹配 Eclipse 4.14.0）： Name: CDT Location: http://download.eclipse.org/tools/cdt/releases/9.10 c) 在窗口操作：SelectAll / Next / Next / 选择同意 / Finsh（进入另一个窗口操作） 注意事项：CDT 与 Eclipse 的版本必须要匹配！ 关于 CDT 各个版本汇总网址：https://www.eclipse.org/cdt/downloads.php 4.5. 导入工程（如图） File / Import / General / Ex","date":"2020-08-04","objectID":"/20200804/:0:2","tags":["Eclipse","IDE","linux 工具/应用"],"title":"linux 开发工具 Eclipse","uri":"/20200804/"},{"categories":["linux"],"content":"linux JAVA 开发环境 JDK 安装简介","date":"2020-08-03","objectID":"/20200803/","tags":["JDK","JAVA","linux 工具/应用"],"title":"linux JAVA 开发环境 JDK","uri":"/20200803/"},{"categories":["linux"],"content":"JDK 简介 JDK 是 Java 语言的软件开发工具包，主要用于移动设备、嵌入式设备上的 java 应用程序。JDK 是整个 java 开发的核心，它包含了 JAVA 的运行环境（JVM+Java系统类库）和 JAVA 工具。 ","date":"2020-08-03","objectID":"/20200803/:0:1","tags":["JDK","JAVA","linux 工具/应用"],"title":"linux JAVA 开发环境 JDK","uri":"/20200803/"},{"categories":["linux"],"content":"Ubuntu 平台 系统版本：16.04.7（ubuntu-16.04.7-desktop-amd64.iso） 软件版本：1.8.0_221（jdk-8u221-linux-x64.tar.gz (密码: m3eh)）【官网最新版】 官方网址：https://www.oracle.com 一、软件简介 工具 功能 JDK 开发工具包 JRE 运行环境 JVM Java 虚拟机 ● １.１、JDK 包含 JRE，JRE 包含 JVM。也可以说 JDK 是 JRE+Java 的开发工具。JRE 包含了 JVM+Java 语言的核心类库。JDK 用于开发，是给开发人员用的。JRE 用于运行 java 程序，和 JVM 一起是给普通用户使用的。如果只是运行 Java 程序，可以只安装 JRE，无需安装 JDK。也就是说：使用 JDK 开发完成的 java 程序，交给 JRE 去运行。 ● １.２、OracleJDK 替代版：AdoptOpenJDK，支持平台广泛。可到国内镜像【清华大学开源软件镜像站（tuna）】下载。 ● １.３、OpenJDK 可能有兼容问题，比如最近我在安装 eclipse 时就遇到了 OpenJDK 不能用的问题，所以最后还是建议安装 oracle jdk。 二、版本说明 ● ２.１、JAVA 有 3 个版本：J2SE、J2EE、J2ME，分别面向桌面应用、企业级应用、手机移动领域的应用。（注：JAVA 就是指 JDK 开发工具，所以我们可以理解为 JAVA 等价于 JDK） ● ２.２、关于版本的选择，推荐使用 jdk8（1.8.0），目前企业大多数都用的 jdk8，而且 jdk8 可以说是一个很经典的版本，虽然 oracle 停止维护了 jdk8。另外 JDK9/JDK10 这种非 LTS 还是别花力气了，直接上 JDK11，因为 Java11 是 Java8 后的首个长期支持版本。 ● ２.３、JDK 的历史版本（JDK 发行说明）： 版本 名称 发行日期 JDK 1.0 Oak(橡树) 1996-01-23 JDK 1.1 none（无） 1997-02-19 JDK 1.1.4 Sparkler（宝石） 1997-09-12 JDK 1.1.5 Pumpkin（南瓜） 1997-12-13 JDK 1.1.6 Abigail（阿比盖尔–女子名） 1998-04-24 JDK 1.1.7 Brutus（布鲁图–古罗马政治家和将军） 1998-09-28 JDK 1.1.8 Chelsea（切尔西–城市名） 1999-04-08 J2SE 1.2 Playground（运动场） 1998-12-04 J2SE 1.2.1 none（无） 1999-03-30 J2SE 1.2.2 Cricket（蟋蟀） 1999-07-08 J2SE 1.3 Kestrel（美洲红隼） 2000-05-08 J2SE 1.3.1 Ladybird（瓢虫） 2001-05-17 J2SE 1.4.0 Merlin（灰背隼） 2002-02-13 J2SE 1.4.1 grasshopper（蚱蜢） 2002-09-16 J2SE 1.4.2 Mantis（螳螂） 2003-06-26 Java SE 5.0 (1.5.0) Tiger（老虎） 2004-09-30 Java SE 6.0 (1.6.0) Mustang（野马） 2006-04 Java SE 7.0 (1.7.0) Dolphin（海豚） 2011-07-28 Java SE 8.0 (1.8.0) Spider（蜘蛛） （LTS 长期支持版本） 2014-03-18 Java SE 9.0 none（无） 2017-09-21 Java SE 10.0 none（无） 2018-03-21 Java SE 11.0 none（无） （LTS 长期支持版本） 2018-09-25 Java SE 12.0 none（无） 2019-03 Java SE 13.0 none（无） 2019-09 Java SE 14.0 none（无） 2020-03 Java SE 15.0 none（无） 2020-10 Java SE 16.0 none（无） 2021-04 Java SE 17.0 none（无） （LTS 长期支持版本） 2021-10 Java SE 18.0 none（无） 2022-04 三、安装步骤 3.1. 将压缩包解压（如图） # 解压 jdk 压缩包到 opt 文件夹 sudo tar -zxvf jdk-8u221-linux-x64.tar.gz -C /opt 3.2. 环境变量配置（如图） # 执行命令打开文件进行编辑： sudo gedit /etc/profile # 在打开的文件末尾添加如下脚本代码： export JAVA_HOME=/opt/jdk1.8.0_221 #定义变量（路径） export JRE_HOME=$JAVA_HOME/jre #定义变量（路径） export CLASSPATH=.:$JAVA_HOME/lib:$JRE_HOME/lib:$CLASSPATH #环境变量：`CLASSPATH`是[javac]编译器专用的一个环境变量 export PATH=$JAVA_HOME/bin:$JRE_HOME/bin:$PATH #环境变量：普通可执行文件路径 扩展知识：环境变量 ● 介绍：环境变量主要的目的是告诉系统知道应用程序所在哪个路径下，让系统可直接运行应用程序（如果应用程序已在系统标准位置下，则不需要增加环境变量。linux系统几个标准位置：/bin、/sbin、/usr/bin、/usr/sbin、/usr/local/bin等）。在安装一些软件（特别是工具链）时，必须要配置环境变量。对于 linux 系统环境变量，主要在两个文件增加环境变量：/etc/profile和/root/.bashrc，不过用户主目录上有个~/.bash_profile文件只对这个用户有效。配置环境变量后，还需要使用命令或重启系统才能生效。（参考网址） ● 语法：export PATH=$PATH:路径1:路径2:…:路径n ● 解析：export在子 shell 运行应用程序，不写时表示在当前 shell 运行。$PATH表示增加环境变量，注意不要漏掉。:为分隔符。$表示一个变量，如下面代码$JAVA_HOME代表/opt/jdk1.8.0_221的变量。 ● 注意：与 Windown 系统不同，linux 系统使用冒号分隔，而不是分号。 3.3. 环境变量生效（如图） # 文件保存退出后执行命令使环境变量即时生效： source /etc/profile 3.4. 查看 jdk 版本（如图） # 执行命令查看jdk版本信息（能查出版本信息表示安装成功） java -version ","date":"2020-08-03","objectID":"/20200803/:0:2","tags":["JDK","JAVA","linux 工具/应用"],"title":"linux JAVA 开发环境 JDK","uri":"/20200803/"},{"categories":["linux"],"content":"介绍 Ubuntu 系统及工具的安装","date":"2020-08-02","objectID":"/20200802/","tags":["Ubuntu","linux 工具/应用"],"title":"Ubuntu 系统与工具","uri":"/20200802/"},{"categories":["linux"],"content":"一、系统篇 1. Ubuntu 系统下载 虚拟机版本：VMware-Workstation-10.0.7 系统的版本：Ubuntu-16.04.7、【网易镜像】 官方网下载：http://releases.ubuntu.com/xenial Ubuntu 中文论坛 2. Ubuntu 版本说明 Ubuntu 系统是一个以桌面应用为主的 Linux 操作系统，Ubuntu 基于 Debian 发行版和 GNOME 桌面环境。Ubuntu 的目标在于为一般用户提供一个最新的、同时又相当稳定的主要由自由软件构建而成的操作系统，它可免费使用，并带有社团及专业的支持。 版本 别名（codename） 发布日期 4.10 Warty Warthog(长疣的疣猪) 2004年10月20日 5.04 Hoary Hedgehog(灰白的刺猬) 2005年4月8日 5.10 Breezy Badger(活泼的獾) 2005年10月13日 6.06 Dapper Drake(整洁的公鸭) 2006年6月1日(LTS) 6.10 Edgy Eft(急躁的水蜥) 2006年10月6日 7.04 Feisty Fawn(坏脾气的小鹿) 2007年4月19日 7.10 Gutsy Gibbon(勇敢的长臂猿) 2007年10月18日 8.04 Hardy Heron(耐寒的苍鹭) 2008年4月24日(LTS) 8.10 Intrepid Ibex (勇敢的野山羊) 2008年10月30日 9.04 Jaunty Jackalope(得意洋洋的怀俄明野兔) 2009年4月23日 9.10 Karmic Koala(幸运的考拉) 2009年10月29日 10.04 Lucid Lynx(清醒的猞猁) 2010年4月29日 11.10 Oneiric Ocelot(梦幻的豹猫) 2010年10月13日 11.04 Natty Narwhal(敏捷的独角鲸) 2011年4月28日 12.04 Precise Pangolin(精准的穿山甲) 2012年的4月26日(LTS) 12.10 Quantal Quetzal(量子的绿咬鹃) 2012年的10月20日 13.04 Raring Ringtail(铆足了劲的猫熊) 2013年4月25日 13.10 Saucy Salamander(活泼的蝾螈) 2013年10月17日 14.04 Trusty Tahr (可靠的塔尔羊) 2014年4月18日 (LTS) 14.10 Utopic Unicorn(乌托邦独角兽) 2014年10月23日 15.04 Vivid Vervet (活泼的小猴) 2015年4月 15.10 Wily Werewolf (狡猾的狼人) 2015年10月 16.04 Xenial Xerus (好客的非洲地松鼠) 2016年4月 （LTS） 16.10 Yakkety Yak（牦牛） 2016年10月 17.04 Zesty Zapus(开心的跳鼠) 2017年4月 17.10 Artful Aardvark(机灵的土豚) 2017年10月 18.04 Bionic Beaver（仿生海狸） 2018年4月(LTS) 备注：LTS 表示长期支持版本！ 3. Ubuntu 安装步骤 3.1. Ubuntu 在 VM 虚拟机上的安装过程 安装一般分为典型安装和自定义安装，本文为了更深入了解虚拟机相关知识而选择了自定义安装。 网友更详尽安装说明 网友介绍NAT模式和桥接模式文章 3.2. 如何在 VM 虚拟机打开 Ubuntu 系统 4. Ubuntu 操作界面基础 Ubuntu 拥有多个操作终端（使用Ctrl+Alt+F1~F7切换），F7为系统默认启动系统默认加载的操作终端是图形界面，其余都是为命令行界面终端。 Ctrl+Alt+F1：切换到命令行界面终端。 Ctrl+Alt+F7：切换到图形界面终端。 Ctrl+Alt+t： 在图形界面下打开命令行终端机。 $命令行前字符，表示用户权限操作。 #命令行首字符，表示管理员权限操作。（root权限） 为 Ubuntu 增加显示桌面快捷键：System setting / Keyboard / Navigation / Hide all normal windows 设置即可。 为 Ubuntu 加显示桌面到启动器：System setting / Appearance / Behavior / Add show desktop icon to the launcher 勾选上即可。 5. Ubuntu 版本查看命令 ctrl + alt + t快捷键打开终端机 uname -a内核 cat /proc/version具体 cat /etc/lsb-release具体 cat /etc/issue简单 6. Ubuntu 网络基本配置 介绍：在 Ubuntu 系统上安装软件，多数情况下都是使用apt-get指令在线安装。如果网络没有配置好（一般情况下系统默认配置为 DHCP），则造成软件（工具）无法安装，相关工作将无法开展。 ctrl + alt + t快捷键打开终端机（注：以后不再提及需要打开终端） sudo gedit /etc/network/interfaces编辑网络参数 sudo /etc/init.d/networking restart重启网络 某些情况需要静态ip： auto lo iface lo inet loopback auto eth0 iface eth0 inet static address 192.168.1.28 netmask 255.255.255.0 gateway 192.168.1.1 dns-nameservers 8.8.8.8 7. Ubuntu 磁盘扩容方法 在 VMware 安装 Ubuntu 时磁盘容量分配过小，或者是用了一段时间后 Ubuntu 的磁盘容量不足时，那我们就需要对 Ubuntu 磁盘进行扩容。备注：在命令窗口输入命令df -h查看硬盘容量使用情况。分两大步：一、在 VMware 设置菜单调整磁盘容量；二、在 Ubuntu 系统里面调整分区大小。 修改磁盘总容量大小：VMware/虚拟机/设置/硬盘/实用工具/扩展。 通过命令安装 Gparted：sudo apt-get install gparted。 打开 Gparted 软件（图示），在可视界面上操作，总体操作为 删除扩展分区（以及交换分区）→ 调整主分区大小 → 创建扩展分区（以及交换分区）。 使用右键 Delete 菜单依次删除 linux-swap 交换分区、extended 扩展分区，若 Delete 选项灰色不可用，则先点击 SwapOff（图示）。 使用右键 Resize/Move 菜单调整 /dev/sda1 主分区大小，在里面调整主分区大小，但必须留大约 2G 给扩展分区使用。 使用右键 New 菜单对 unallocated 未分配空间进行分配，在里面创建为 Extended Partition 扩展分区。 使用右键 New 菜单对 extended 扩展分区进行分配，在里面创建为 linux-swap 交换分区（图示）。 然后点击主界面的打勾按钮确认并执行操作。 使用右键 SwapOn 菜单激活 linux-swap 交换分区。 使用右键 Information 菜单查看 linux-swap 交换分区的 UUID。 将新建的 linux-swap 中的 UUID 值更新到/etc/fstab文件中，打开文件的命令：sudo gedit /etc/fstab 具体请参考网文：《VMware 下对 Ubuntu 进行扩充磁盘大小》、《查看最后一节：更换 UUID》、《fstab 是什么？被谁用？怎么写？》 8. 解决系统之间复制粘贴问题 介绍：解决 ubuntu16.04 和 windows 电脑之间无法复制粘贴问题。 sudo apt-get autoremove open-vm-tools移除系统原来的虚拟工具条 sudo apt-get install open-vm-tools安装开源工具包 sudo apt-get install open-vm-tools-desktop安装桌面版的虚拟工具条 安装过程中，yes 或者 y 一路通过。 重启 Ubuntu 即可。 工具 作用 open-vm-tools 虚拟机显示驱动，屏幕可以自适应大小 open-vm-tools-desktop 实现主机和虚拟机之间的文件复制粘贴 open-vm-tools-dkms 实现文件夹共享。在 VMware 虚拟机菜单依次点击→虚拟机→设置→选项→共享文件夹→总是启用→添加目录即可，在 Unbuntu 系统的访问的共享文件夹在/mnt/hgfs对应目录 9. 解决系统分辨率自适应问题 介绍：相信很多人在装虚拟机的时候，遇到了窗口过小不能自适应的问题。我在网上查了好多资料，有说安装 Vmware Tools 解决，也有说修改分辨率解决。但 Vmware Tools 工具官方已经不建议，更提倡开源的 open-vm-tools。 sudo apt-get install open-vm-tools安装开源工具包； sudo apt-get install open-vm*安装一些依赖包； shutdown -r now重启，完美解决窗口自适应问题。 还有在 VMware 勾选：查看/自动调节大小/自动适应客户机 和 自动适应窗口","date":"2020-08-02","objectID":"/20200802/:0:1","tags":["Ubuntu","linux 工具/应用"],"title":"Ubuntu 系统与工具","uri":"/20200802/"},{"categories":["linux"],"content":"二、工具篇 1. Ubuntu 上安装 JDK 教程 请阅读：《linux JAVA 开发环境 JDK》 2. Ubuntu 上安装 Eclipse 教程 请阅读：《linux 开发工具 Eclipse》 3. Ubuntu 上更新 Firefox 教程 1、下载：直接在官网《下载》 2、更新：请参考官网《在 Linux 中安装 Firefox》 备注：我的系统是 Ubuntu（注：命令操作需要权限时要加sudo），因为只是增加 Firefox-98 新版本，没有删除旧版本，所以做法有少许不一样： ###[不同对照表]### # ln -s /opt/firefox/firefox /usr/local/bin/firefox --命令改为--\u003e sudo ln -s /opt/firefox/firefox /usr/local/bin/firefox98 # /usr/local/share/applications ----------------------路径改为--\u003e /usr/share/applications # firefox.desktop ----------------------名称改为--\u003e firefox98.desktop # Name=Firefox Web Browser ----------------------参数改为--\u003e Name=Firefox98 Web Browser # Exec=firefox %u ----------------------参数改为--\u003e Exec=/opt/firefox/firefox %u ###[具体操作]#### cd ~/Downloads # 进入文件包下载到的目录 tar xjf firefox-98.0.2.tar.bz2 # 解压下载的软件包 sudo mv firefox /opt # 将刚解压的软件包移到/opt目录下 sudo ln -s /opt/firefox/firefox /usr/local/bin/firefox98 # 创建软件快捷启动方式 touch firefox98.desktop # 创建桌面快捷启动方式，使用文本工具编辑其内容（具体请复制[firefox98.desktop文件内容]） sudo chmod 777 firefox98.desktop # 修改桌面快捷启动方式权限 sudo mv firefox98.desktop /usr/share/applications # 将桌面快捷启动方式移到应用启动图标管理文件夹 ######[firefox98.desktop文件内容]###### ######[备注]：凡是脚本,行尾不应有多余的空格 [Desktop Entry] Version=1.0 Name=Firefox98 Web Browser Comment=Browse the World Wide Web GenericName=Web Browser Keywords=Internet;WWW;Browser;Web;Explorer Exec=/opt/firefox/firefox %u Terminal=false X-MultipleArgs=false Type=Application Icon=/opt/firefox/browser/chrome/icons/default/default128.png Categories=GNOME;GTK;Network;WebBrowser; MimeType=text/html;text/xml;application/xhtml+xml;application/xml;application/rss+xml;application/rdf+xml;image/gif;image/jpeg;image/png;x-scheme-handler/http;x-scheme-handler/https;x-scheme-handler/ftp;x-scheme-handler/chrome;video/webm;application/x-xpinstall; StartupNotify=true 3、最后：在可视窗口里进入 /usr/share/applications 文件夹，点右键菜单复制 Firefox98 Web Browser 桌面快捷启动图标，然后到桌面点右键菜单粘贴，最后点击图标即可在桌面启动 Firefox98 浏览器。 ","date":"2020-08-02","objectID":"/20200802/:0:2","tags":["Ubuntu","linux 工具/应用"],"title":"Ubuntu 系统与工具","uri":"/20200802/"},{"categories":["software"],"content":"介绍 json 基本语法","date":"2020-03-09","objectID":"/20200309/","tags":["json"],"title":"json 基本语法介绍","uri":"/20200309/"},{"categories":["software"],"content":"一、前言 JSON 指的是 JavaScript 对象表示法（JavaScript Object Notation）。 JSON 是轻量级的文本数据交换格式，目前大部分智能家居系统数据交换都使用了 Json 格式。 ","date":"2020-03-09","objectID":"/20200309/:0:1","tags":["json"],"title":"json 基本语法介绍","uri":"/20200309/"},{"categories":["software"],"content":"二、语法 JSON 数据的书写格式是：key : value，即： 键 : 键值，也就是：名称 : 数值。 数组：\"名称\" : [ 组员 , 组员 , ……组员], 组员：为 无名数组、无名对象、无名数值 说明：“无名”表示没有名称的一个对象体/数组体/数值 对象：\"名称\" : { 成员 , 成员 , ……成员}, 成员：为 有名数组、有名对象、有名成员 成员：\"名称\" : \"数值\", 数值：任意字符；如果 数值 没有双引号，只能数字、ture、false、null 要点：整个Json数据需要 { } 括号括住， } 或 ] 前面不能有逗号。 ","date":"2020-03-09","objectID":"/20200309/:0:2","tags":["json"],"title":"json 基本语法介绍","uri":"/20200309/"},{"categories":["software"],"content":"三、例子 点击展开内容 { \"web-app\": { \"servlet\": [ { \"servlet-name\": \"cofaxCDS\", \"servlet-class\": \"org.cofax.cds.CDSServlet\", \"init-param\": { \"useDataStore\": true, \"useJSP\": false, \"xxx\": null, \"dataStoreMaxConns\": 100, \"maxUrlLength\": 500, \"dataStoreLogLevel\": \"debug\", \"configGlossary:adminEmail\": \"ksm@pobox.com\", \"configGlossary:poweredByIcon\": \"/images/cofax.gif\", \"configGlossary:staticPath\": \"/content/static\", \"jspListTemplate\": \"listTemplate.jsp\", \"searchEngineFileTemplate\": \"forSearchEngines.htm\", \"searchEngineRobotsDb\": \"WEB-INF/robots.db\", \"dataStoreClass\": \"org.cofax.SqlDataStore\" } }, { \"servlet-name\": \"cofaxEmail\", \"servlet-class\": \"org.cofax.cds.EmailServlet\", \"init-param\": { \"mailHost\": \"mail1\", \"mailHostOverride\": \"mail2\" } }, { \"servlet-name\": \"cofaxAdmin\", \"servlet-class\": \"org.cofax.cds.AdminServlet\" }, { \"servlet-name\": \"fileServlet\", \"servlet-class\": \"org.cofax.cds.FileServlet\" }, { \"servlet-name\": \"cofaxTools\", \"servlet-class\": \"org.cofax.cms.CofaxToolsServlet\", \"init-param\": { \"templatePath\": \"toolstemplates/\", \"log\": 1, \"logLocation\": \"/usr/local/tomcat/logs/CofaxTools.log\", \"logMaxSize\": \"\", \"dataLog\": 1, \"betaServer\": true } } ], \"servlet-mapping\": { \"cofaxCDS\": \"/\", \"cofaxEmail\": \"/cofaxutil/aemail/*\", \"cofaxAdmin\": \"/admin/*\", \"fileServlet\": \"/static/*\", \"cofaxTools\": \"/tools/*\" }, \"taglib\": { \"taglib-uri\": \"cofax.tld\", \"taglib-location\": \"/WEB-INF/tlds/cofax.tld\" }, \"oil-price\": { \"status\": \"ok\", \"msg\": \"全国各省份汽柴油价格信息\", \"update\": \"2019-07-21 11:00\", \"data\": [ [\"地区\", \"92号汽油\", \"95号汽油\", \"98号汽油\", \"0号柴油\"], \"直辖市：\", [\"北京\", \"6.78\", \"7.21\", \"8.19\", \"6.45\"], [\"上海\", \"6.74\", \"7.17\", \"7.87\", \"6.39\"], [\"重庆\", \"6.75\", \"7.18\", \"8.06\", \"6.37\"], \"省份：\", [\"广东\", \"6.77\", \"7.15\", \"8.07\", \"6.41\"] ], \"About\": \"xiaomin\", \"Blog\": [\"www.xxxxx1.com\", \"www.xxxxx2.com\"] } } } ","date":"2020-03-09","objectID":"/20200309/:0:3","tags":["json"],"title":"json 基本语法介绍","uri":"/20200309/"},{"categories":["software"],"content":"四、工具 点击展开内容 JSONedit-格式化与语法检测工具下载 JSONEditorOnline-在线格式化与语法检测工具 菜鸟工具JSON在线解析-在线格式化与语法检测工具 ","date":"2020-03-09","objectID":"/20200309/:0:4","tags":["json"],"title":"json 基本语法介绍","uri":"/20200309/"},{"categories":["software"],"content":"五、资料 点击展开内容 官网、Json中国 ","date":"2020-03-09","objectID":"/20200309/:0:5","tags":["json"],"title":"json 基本语法介绍","uri":"/20200309/"},{"categories":["linux"],"content":"linux 学习方向","date":"2020-03-05","objectID":"/20200305/","tags":["linux"],"title":"linux 学习索引","uri":"/20200305/"},{"categories":["linux"],"content":"一、前言 当我们做一件事时，方向很重要，如果方向错了，之前的努力会白白浪费掉，再努力也不会成功！学习 linux 也一样，一、首先需要了解它有哪些知识点，结合自己情况决定向哪个方向发展；二、先学习用到的知识点，以后才深化及补全。 ","date":"2020-03-05","objectID":"/20200305/:0:1","tags":["linux"],"title":"linux 学习索引","uri":"/20200305/"},{"categories":["linux"],"content":"二、认识 linux 1. linux 发行版本 ● deb派系--桌面版系统 Debian（读音：‘debeen 待宾） Ubuntu（读音：u’bʌntu 乌班图） Deepin（读音：diːpin 低评） …… ● rpm派系--服务器系统 RedHat（读音：‘redhæt [红帽]） CentOS（读音：sen’tus 圣斗士） Fedora（读音：fɪ’dɔːrə 费多拉帽） …… 2. linux 基础知识 ● 系统 Ubuntu CentOS …… ● 命令 权限命令 网络命令 文件命令 …… ● 编辑 中文输入法 vi/vim 编辑器 gedit 编辑器 …… ● 编程 进程 线程 管道 …… ● 编译 gcc 编译 Makefile 构建工具 gdb 调试 …… ● 工具 网络终端工具 ssh 网络文件系统 nfs 轻巧脚本语言 lua …… 3. 就业发展方向 ● linux 运维 ● linux 系统应用开发 ● 嵌入式 linux Bootloader Linux 内核 根文件系统 Linux 驱动 Linux 应用 ","date":"2020-03-05","objectID":"/20200305/:0:2","tags":["linux"],"title":"linux 学习索引","uri":"/20200305/"},{"categories":["linux"],"content":"三、嵌入式 linux 1. BootLLoad 2. linux 内核 3. 根文件系统 4. linux 驱动 5. linux 应用 ","date":"2020-03-05","objectID":"/20200305/:0:3","tags":["linux"],"title":"linux 学习索引","uri":"/20200305/"},{"categories":["MCU"],"content":"利用 j-link 的 RTT 也可以实现调试打印的功能","date":"2019-01-19","objectID":"/20190119/","tags":["J-link","RTT"],"title":"J-link 调试器日志打印工具-RTT","uri":"/20190119/"},{"categories":["MCU"],"content":"前言 在线仿真器（J-link）与 MCU 之间实现的是硬件级-即时性的信息交互，平时调试时可直接读取 MCU 内部任何数据，那就意味着可以划一段共享内存用来缓存打印信息，当有信息就读取出来，从而实现 MCU 向仿真器终端软件打印信息的功能。 ","date":"2019-01-19","objectID":"/20190119/:0:1","tags":["J-link","RTT"],"title":"J-link 调试器日志打印工具-RTT","uri":"/20190119/"},{"categories":["MCU"],"content":"简介 点击展开内容 ● RTT（Real Time Terminal）是 SEGGER 公司新出的可以在嵌入式应用中与用户进行交互的实时终端。J-Link 驱动 4.90 之后的版本都支持 RTT。 ● RTT 既可以从 MCU 上输出信息、也可以向应用程序发送信息，由于其高速的特性，所以不影响 MCU 的实时性。实现原理就是 J-link 与 MCU 共享内存。 ● MCU 通过 J-link 与电脑连接并将打印信息输出到电脑上，电脑同时可以通过键盘等向 MCU 发送数据。 ","date":"2019-01-19","objectID":"/20190119/:0:2","tags":["J-link","RTT"],"title":"J-link 调试器日志打印工具-RTT","uri":"/20190119/"},{"categories":["MCU"],"content":"移植 点击展开内容 1、RTT 源代码在 J-link 安装目录下：C:\\Program Files (x86)\\SEGGER\\JLink_V630e\\Samples\\RTT\\SEGGER_RTT_V630e.zip， 2、解压并将文件添加到你的工程中：SEGGER_RTT_printf.c、SEGGER_RTT.c、SEGGER_RTT_Conf.h、SEGGER_RTT.h。 3、先调用初始化函数：SEGGER_RTT_ConfigUpBuffer(0, NULL, NULL, 0, SEGGER_RTT_MODE_NO_BLOCK_SKIP); 4、之后可打印字符串: SEGGER_RTT_WriteString(0, \"txt\\r\\n\"); 5、打印格式化字符串: SEGGER_RTT_printf(0，\"%d_txt\\r\\n\"，2019); 6、打开打印调试窗口，在 SEGGER 安装目录下找到 JLink RTT Viewer.exe 这软件双击运行。 后记： ● 使用 V4.90 版 → 测试 → 不成功； ● 使用 V6.30 版 → 测试 → 成功。 ● 听说 RTT 共有三个输出工具，网友解释如下： RTT Viewer：不支持中文。至少要进入一次 Debugger 才能正常显示输出。建议进入 Debugger 之后再打开，否则经常不能正常显示输出。 RTT Logger：支持中文，并且可以保存为 log 文件。使用具体的正确使用方法不清楚。根据手册说明，log 只接收 RTT 通道 1 的输出，即SEGGER_RTT_printf(1，\"字符串\"，输出格式)。但是实测，只能输出 RTT 通道 0 的信息，并且要求代码中要有使用到通道 1 的语句。否则收不到数据。 RTT Client：必须配合 RTT Logger 或者 keil 的 Debugger 来使用，而 RTT Logger 也必须配合 Debugger 使用。Client、Logger 和 Debugger 三个窗口都打开的时候，Client 和 Logger 只有其中一个能正常显示，另外一个会严重丢失数据。 ","date":"2019-01-19","objectID":"/20190119/:0:3","tags":["J-link","RTT"],"title":"J-link 调试器日志打印工具-RTT","uri":"/20190119/"},{"categories":["software"],"content":"Markdown 语法与工具的介绍","date":"2018-11-01","objectID":"/20181101/","tags":["Markdown"],"title":"Markdown 语法与工具","uri":"/20181101/"},{"categories":["software"],"content":"一、前言 Markdown 是一种轻量级标记语言，创始人为约翰·格鲁伯（John Gruber）。它允许人们使用易读易写的纯文本格式编写文档，然后转换成有效的 HTML 文档。这种语言吸收了很多在电子邮件中已有的纯文本标记的特性。由于 Markdown 的轻量化、易读易写特性，并且对于图片、图表、数学式都有支持，所以许多网站都广泛使用 Markdown 来撰写帮助文档或是用于论坛上发表消息。 如 GitHub、Reddit、Diaspora、Stack Exchange、OpenStreetMap、SourceForge、简书等，甚至还能被使用来撰写电子书。本人所有博文都是使用 Markdown 语法编写，通过对应工具制作或转换后发表到各类平台上。 ","date":"2018-11-01","objectID":"/20181101/:0:1","tags":["Markdown"],"title":"Markdown 语法与工具","uri":"/20181101/"},{"categories":["software"],"content":"二、语法 1、Markdwon 基本语法： 写一篇文章，主要包括：目录、标题、文本、表格、图片 这几项内容，通过 Markdwon 语法以统一版式为我们格式化文章，让我们专注写作上，而不是排版上。下表已列出 Markdwon 基本语法及作用说明，直接打开一个排版器（如：aclickall）复制下面 Markdwon 语法把效果展示出来（备注：如果本文使用详细文字说明 Markdwon 语法反而把它说的复杂化）。 语法 功能 说明 \\ 转义符 用来可显示语法特殊符号。 *** --- ___ 分割线 前行空行+单独一行及至少三个其符号+空格，特别是 --- 前面必须要加一行空行。三种语句一样的！ # text1 ### text3 ###### text6 标题 1…6 行首加其符号及空格，下行加 === 或 --- 也可表示标题 1 和 2，其中 ### 常用作分类标题。 \u003e text \u003e text 区块 行首加其符号及空格，后面加多一行空行表示结束，\u003e\u003e text 可嵌套 1 层、…。 ``` text ``` 代码区 前个 ``` 不要带空格，后个 ``` 要带有空格。第一个可指出代码语言 (如: ```c)。 每行行首加4个空格或1个Tab符 代码区 全部字符默认颜色显示，关健字不会上色。 1. text1 2. text2 有序列表 行首加其数字和点及空格。 + text1 + text2 无序列表 行首加其符号及空格。 * text1 * text2 无序列表 同上。 - text1 - text2 无序列表 同上。 - [ ] text1 - [x] text2 选项列表 行首加其符号及空格 (注意空格)。 *text* 斜体 文字两侧加其符号 (可嵌套到一些语法中)。 **text** 粗体 文字两侧加其符号 (可嵌套到一些语法中)。 ***text*** 粗斜体 文字两侧加其符号 (可嵌套到一些语法中)。 ~~text~~ 删除线 文字两侧加其符号 (可嵌套到一些语法中)。 `text` 代码段 文字两侧加其符号 (可嵌套到一些语法中)。 [TOC] 文章目录 单独一行，前后多一行空行，文章索引及跳转。 \u003clink或Email\u003e 网址或 Email 直接显示网址或 Email 链接，例如：\u003c99770525@qq.com\u003e 。 [text](https://link \"title\") 文字链接 可链接网址，也可链接本地文件(./01.html)，\"title\"气泡文字，可不写。 ![text](link) 图片导入 可网络图片，也可本地图片(./01.png)。 [![text](link)](https://link2) 图片链接 可网络图片，也可本地图片(./01.png)。 [text][XXX] [XXX]: https://link 链接引用 前行的 XXX 引用后行的 XXX（相当于宏定义），最终结果为 [text](https://link)。 \u003c!-- text --\u003e 有用扩展： 隐藏内容 隐藏内容，可隐藏多行内容 (gitHub支持)。 \u0026nbsp; 有用扩展： 强加空格 强加空格，支持单元格内加空格 (gitHub支持)。 \u003cbr\u003e 有用扩展： 强制换行 强制换行，支持单元格内换行 (gitHub支持)。 \u003cu\u003e下划线文字\u003c/u\u003e 有用扩展： 加下划线 加下划线，可包含Markdwon语法存在 (gitHub支持)。 \u003ci\u003e斜体文字\u003c/i\u003e 有用扩展： 斜体文字 斜体文字，可包含Markdwon语法存在 (gitHub支持)。 \u003cstrong\u003e文字加粗\u003c/strong\u003e 有用扩展： 文字加粗 文字加粗，可包含Markdwon语法存在 (gitHub支持)。 \u003ccenter\u003e居中内容\u003c/center\u003e 有用扩展： 文字居中 文字居中，html 语法实现的文字居中 (gitHub支持)。 \u003cdetails close=\"\"\u003e\u003csummary\u003e折叠标题\u003c/summary\u003e 折叠内容 \u003c/details\u003e 有用扩展： 折叠内容 折叠内容，可包含Markdwon语法存在 (gitHub支持)。 \u003ca href=\"https://link\" title=\"提示文字\"\u003e文字链接\u003c/a\u003e 有用扩展： 强加链接 强加链接，折叠标题中强加文字链接 (gitHub支持)。 \u003cspan id=\"jump\"\u003e跳转到的位置\u003c/span\u003e [点击跳转](#jump) 有用扩展： 页内跳转 页内跳转，Markdwon＋html 语法实现 (gitHub支持)。 \u003cspan style=\"color: #AE87FA;\"\u003e彩色文字\u003c/span\u003e 有用扩展： 彩色文字 彩色文字，html语法实现文字加颜色 (gitHub支持)。 \u003cdiv style=\"width:16px\"\u003e单元格宽度\u003c/div\u003e 有用扩展： 单元格宽 单元格宽，保证单元格至少宽度 16px (gitHub支持)。 备注： 1.1、关于【行首语法符号】的使用，与后面内容必须使用【一个空格】分隔开，这样有效避免一些兼容问题； 1.2、关于【集合性质符号】的使用，在整体前后面各加【一行空行】表示集合，这样有效避免一些兼容问题； 1.3、关于【常规段落换行】的问题，在段落结尾加多【两个空格】再回车换行，这样有效避免一些兼容问题； 1.4、关于【分割线的语法】，前面最好加多【一行空行】，防止【===】和【---】与上行内容组合为【标题1】和【标题2】等问题； 1.5、关于【列表嵌套语法】，要求子列表前加多【4个空格】或【1个TAB格】； 1.6、关于【引用嵌套语法】，增多一个【\u003e】表示嵌套多一层，减少至 n 个【\u003e】且后面只有两个空格时表示退回到第 n 层嵌套； 1.7、关于【单元宽度单位】，分为 pt:点数或磅、px:像素、cm:厘米，常用中文字大小为 14px 或 16px； 2、Markdwon 扩展语法： 一、表格：● | 左对齐 | 居中对齐 | 右对齐 | | :---- | :-----: | ----: | | **粗体字** | [![图片链接](https://www.zybuluo.com/static/img/logo.png)](https://www.zybuluo.com) | [~~加删除线链接~~](https://www.163.com) \u003cbr\u003e [表格内换行内容](https://www.163.com) | 表现为: 左对齐 居中对齐 右对齐 粗体字 加删除线链接 表格内换行内容 二、数学式：● 待续…… 三、流程图：● 待续…… 3、Markdwon 字符转义： 字符 说明 \\ 反斜线（必须要加转义） | 竖线号（专注表格使用，其它位置可不用转义！） ! 感叹号（专注插图使用，其它位置可不用转义！） # 井字号（专在行首使用，其它位置可不用转义！） = 等号　（专在行首使用，其它位置可不用转义！） - 减号　（专在行首使用，其它位置可不用转义！） _ 下划线（专在行首使用，其它位置可不用转义！） + 加号　（专在行首使用，其它位置可不用转义！） . 点号　（专在行首使用，其它位置可不用转义！） * 星号　（任意位置使用，显示字符本身须转义！） ` 反引号（任意位置使用，显示字符本身须转义！） {} 花括号（任意位置使用，其中 “}” 可不加转义。） [] 方括号（任意位置使用，其中 “]” 可不加转义。） () 圆括号（任意位置使用，其中 “)” 可不加转义。） \u003c\u003e 角括号（任意位置使用，其中 “\u003e” 不能加转义！还有:“\u003c\u003e”里面有内容才能对“\u003c”使用“\\”转义） 备注： 3.1、某些 Markdown 解释器不支持表格内使用【``】符号包裹【|】符号！ 3.2、关于【$】和【\u0026】，在 Markdown 不能转义，但在 HTML 则是特殊用途！特别是【$】符号，必须使用文本【\u0026#36;】表示，否则极容易引起格式错乱！而【\u0026】有自己格式【\u0026xxx;】，一旦符合其格式则显示为不是我们想要的文本，需要使用文本【\u0026#38;】表示，例如显示【\u0026nbsp;】文本，则使用文本【\u0026#38;nbsp;】表示！更多的 HTML 转义符，请查看【网文】。 ","date":"2018-11-01","objectID":"/20181101/:0:2","tags":["Markdown"],"title":"Markdown 语法与工具","uri":"/20181101/"},{"categories":["software"],"content":"三、工具 1、Markdwon 编辑工具： 1.1、Typora 目前免费，可导出包括 HTML 和 PDF 等多种文件，编辑与预览同一个窗口，使用上可能不太习惯； 1.2、MarkdownPad2 要收费，只能导出 HTML 和 PDF 两种文件，编辑与预览分开两窗口，不支持列表也不支持其它扩展功能； 1.3、Cmd Markdown 作业部落出品，要收费，有网页版和离线版，主要导出 HTML 和 PDF 两种文件，编辑与预览分开两窗口； 1.4、Editor.md 是一款开源的、可嵌入的 Markdown 在线编辑器，支持语法很完整，编辑与预览分开两窗口，可以对标 Cmd Markdown 作业部落编辑器； 2、Markdwon 排版工具： 2.1、aclickall（服务器2）在线版，自带很多排版样式并且用户可自行定制，支持复制至微信公众号，可生成 HTML 保存到本地。 2.2、Markdown Nice（开源网址）在线版，自带很多排版样式并且用户可自行定制，支持复制至微信公众号、知乎和稀土掘金。 2.3、Dooc 在线版，只自带一种排版样式（有 3 种简单配色），支持复制至微信公众号，可生成 HTML 保存到本地。 2.4、MPEditor 在线版，只自带一种排版样式，支持复制至微信公众号。 2.5、Markdown Here 为安装在浏览器插件，好像只能在 Email 里一键转换，具体没怎样用过。 ● 关于使用 aclickall 生成的 html 网页, 建议手工改如下几处内容： 调整网页相关信息: \u003cmeta name=\"author\" content=\"作者相关信息\"\u003e \u003cmeta name=\"email\" content=\"99770525@qq.com\"\u003e \u003cmeta name=\"description\" content=\"描述内容\"\u003e \u003ctitle\u003e网页标题\u003c/title\u003e 改前: #export_content { margin: 40px 20%; //上下空出40px板边, 左右空出20%板边 改后: #export_content { max-width: 900px; margin: 40px auto; //上下空出40px板边, 左右自动伸展并最大限制为900px（同时适配手机和电脑显示） 3、Markdwon 图标素材： 3.1、96微信编辑器，有图标素材，有模板(要收费)，还有一些小工具(二维码工具也不错)。 ","date":"2018-11-01","objectID":"/20181101/:0:3","tags":["Markdown"],"title":"Markdown 语法与工具","uri":"/20181101/"},{"categories":["software"],"content":"三、参考 https://www.runoob.com/markdown/md-tutorial.html https://cloud.tencent.com/developer/article/1748874 ","date":"2018-11-01","objectID":"/20181101/:0:4","tags":["Markdown"],"title":"Markdown 语法与工具","uri":"/20181101/"},{"categories":["其它"],"content":"记录工作、生活点滴","date":"2018-08-01","objectID":"/other/","tags":["其它"],"title":"【other 其它杂谈索引】","uri":"/other/"},{"categories":["其它"],"content":"前言 工作、生活上必定经历一些事情，有好的、有坏的、有一次的、有多次的，有的过眼云烟、有的印象深刻，没经验的记录下来，有经验总结下来，或许这就是人生。 ","date":"2018-08-01","objectID":"/other/:0:1","tags":["其它"],"title":"【other 其它杂谈索引】","uri":"/other/"},{"categories":["其它"],"content":"索引 👉 法律-人生无常之继承法 👉 职业-竞业限制协议 👉 职业-我的社保缴纳情况 👉 职业-对技术型创业团队的看法 👉 生活-无产权公寓 ","date":"2018-08-01","objectID":"/other/:0:2","tags":["其它"],"title":"【other 其它杂谈索引】","uri":"/other/"},{"categories":null,"content":"我的博客 ","date":"2019-08-02","objectID":"/about/:0:1","tags":null,"title":"关于 o2ospring's blog","uri":"/about/"},{"categories":null,"content":"我的公众号 为什么有了微信公众号还要博客？ 微信公众号代表个人或者组织官方媒体，要求发表的文章严谨规范，不允许随便修改（可改几个错别字，可删除文章）。微信公众号以一篇一推的方式推送文章，媒体一般最多一天一文、一天一话题，基本上不会连续发表一系列专题文章。微信公众号没有提供自动分类、归档功能，文章显得碎片化，不便于管理。数落微信公众号这么多并不是说它不好，而是为了想办法弥补它的不足之处。于是找到了个人博客，它可自由组织、编写、修改、删除自己的文章，并提供主页、所有、标签、分类、归档的文章自动管理功能，还有附加搜索、评论系统等，非常适合用于编写个人技术文章。目的：利用微信公众号强大的传媒能力传播个人技术文章，利用个人博客自由组织、修改能力为大家提供一系列的、最新的技术文章。做法：先在博客组织编写技术文章，待文章无大错后再推送到微信公众号，公众号发表的文章都会在尾部指出文章的最新链接，读者可通过链接浏览博客上这篇文章的最新版。其实还有一个重要原因，就是本人是一个容易犯错的人，不得不这样做 。 ","date":"2019-08-02","objectID":"/about/:0:2","tags":null,"title":"关于 o2ospring's blog","uri":"/about/"}]